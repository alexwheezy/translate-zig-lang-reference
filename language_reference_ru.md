### –í—Å—Ç—É–ø–ª–µ–Ω–∏–µ

**Zig** - —ç—Ç–æ —Å–∏—Å—Ç–µ–º–Ω—ã–π —è–∑—ã–∫ –ø—Ä–æ–≥—Ä–∞–º–º–∏—Ä–æ–≤–∞–Ω–∏—è –æ–±—â–µ–≥–æ –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è –∏ –Ω–∞–±–æ—Ä –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –Ω–∞–¥–µ–∂–Ω–æ–≥–æ,
–æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–≥–æ –∏ –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º–æ–≥–æ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ–≥–æ –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è.

- –ù–∞–¥—ë–∂–Ω—ã–π
    - –ü–æ–≤–µ–¥–µ–Ω–∏–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –¥–∞–∂–µ –≤ –∫—Ä–∞–π–Ω–∏—Ö —Å–ª—É—á–∞—è—Ö, —Ç–∞–∫–∏—Ö –∫–∞–∫ –Ω–µ—Ö–≤–∞—Ç–∫–∞ –ø–∞–º—è—Ç–∏.
- –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π
    - –ü–∏—à–∏—Ç–µ –ø—Ä–æ–≥—Ä–∞–º–º—ã —Ç–∞–∫, —á—Ç–æ–±—ã –æ–Ω–∏ –º–æ–≥–ª–∏ —Ä–∞–±–æ—Ç–∞—Ç—å –Ω–∞–∏–ª—É—á—à–∏–º –æ–±—Ä–∞–∑–æ–º.
- –ú–Ω–æ–≥–æ—Ä–∞–∑–æ–≤—ã–π
    - –û–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –∫–æ–¥ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤–æ –º–Ω–æ–≥–∏—Ö —Å—Ä–µ–¥–∞—Ö —Å —Ä–∞–∑–ª–∏—á–Ω—ã–º–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è–º–∏.
- –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π
    - –¢–æ—á–Ω–æ –ø–µ—Ä–µ–¥–∞–µ—Ç –Ω–∞–º–µ—Ä–µ–Ω–∏—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –∏ –¥—Ä—É–≥–∏–º –ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç–∞–º.
    - –≠—Ç–æ—Ç —è–∑—ã–∫ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –±–æ–ª—å—à–∏—Ö –∑–∞—Ç—Ä–∞—Ç –Ω–∞ —á—Ç–µ–Ω–∏–µ –∫–æ–¥–∞ –∏ —É—Å—Ç–æ–π—á–∏–≤ –∫ –º–µ–Ω—è—é—â–∏–º—Å—è —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º –∏ —Å—Ä–µ–¥–∞–º.

–ß–∞—Å—Ç–æ —Å–∞–º—ã–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π —Å–ø–æ—Å–æ–± —É–∑–Ω–∞—Ç—å —á—Ç–æ-—Ç–æ –Ω–æ–≤–æ–µ - —ç—Ç–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –ø—Ä–∏–º–µ—Ä—ã, –ø–æ—ç—Ç–æ–º—É –≤ —ç—Ç–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ–∫–∞–∑–∞–Ω–æ –∫–∞–∫
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∂–¥—É—é –∏–∑ —Ñ—É–Ω–∫—Ü–∏–π **Zig**. –í—Å–µ —ç—Ç–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –Ω–∞ –æ–¥–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ, —Ç–∞–∫ —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å –ø–æ–∏—Å–∫ —Å –ø–æ–º–æ—â—å—é
–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø–æ–∏—Å–∫–∞ –≤–∞—à–µ–≥–æ –±—Ä–∞—É–∑–µ—Ä–∞.

–ü—Ä–∏–º–µ—Ä—ã –∫–æ–¥–∞ –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω—ã –∏ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ —Ä–∞–º–∫–∞—Ö –æ—Å–Ω–æ–≤–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ —Ç–µ—Å—Ç–æ–≤ **Zig**.

–≠—Ç–æ—Ç HTML-–¥–æ–∫—É–º–µ–Ω—Ç –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö —Ñ–∞–π–ª–æ–≤, –ø–æ—ç—Ç–æ–º—É –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ –≤ –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–º —Ä–µ–∂–∏–º–µ.

------------
### –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ **Zig**

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ **Zig** –∏–º–µ–µ—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é.

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ **Zig** —Å–æ–¥–µ—Ä–∂–∏—Ç —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã, —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö –∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç –≤–∞–º
—Å–æ–∑–¥–∞–≤–∞—Ç—å –ø—Ä–æ–≥—Ä–∞–º–º—ã –∏–ª–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏. –í —ç—Ç–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –≤—ã —É–≤–∏–¥–∏—Ç–µ –º–Ω–æ–∂–µ—Å—Ç–≤–æ –ø—Ä–∏–º–µ—Ä–æ–≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ **Zig**,
–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –≤ —ç—Ç–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏. –ß—Ç–æ–±—ã —É–∑–Ω–∞—Ç—å –±–æ–ª—å—à–µ –æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ **Zig**, –ø–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –≤—ã—à–µ.

------------
### –ü—Ä–∏–≤–µ—Ç, –ú–∏—Ä!

```zig
const std = @import("std");

pub fn main() !void {
    const stdout = std.io.getStdOut().writer();
    try stdout.print("Hello, {s}!\n", .{"World"});
}
```
```bash
$ zig build-exe hello.zig
$ ./hello_world
Hello, World!
```


–í –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–µ —Å–ª—É—á–∞–µ–≤ –±–æ–ª–µ–µ —Ü–µ–ª–µ—Å–æ–æ–±—Ä–∞–∑–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å –∑–∞–ø–∏—Å—å –≤ `stderr`, –∞ –Ω–µ –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –≤—ã–≤–æ–¥ –∏ –Ω–µ –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è
–±—É–¥–µ—Ç –ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ –≤ –ø–æ—Ç–æ–∫. –î–ª—è —ç—Ç–æ–≥–æ –æ–±—â–µ–≥–æ —Å–ª—É—á–∞—è —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –±–æ–ª–µ–µ –ø—Ä–æ—Å—Ç–æ–π API:

```zig
const std = @import("std");

pub fn main() !void {
    std.debug.print("Hello, {s}!\n", .{"World"});
}
```
```bash
$ zig build-exe hello_again.zig
$ ./hello_world_again
Hello, World!
```

–í —ç—Ç–æ–º —Å–ª—É—á–∞–µ —Å–∏–º–≤–æ–ª `!` –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—É—â–µ–Ω –≤ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–º —Ç–∏–ø–µ, –ø–æ—Å–∫–æ–ª—å–∫—É —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–æ–∫.

------------
### –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏

**Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç 3 —Ç–∏–ø–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤. –û–±—ã—á–Ω—ã–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è, –Ω–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ `doc` –∏
–∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ –ø–∞–∫–µ—Ç—É.

–°–æ–∑–¥–∞–Ω–Ω–∞—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –≤—Å–µ –µ—â–µ —è–≤–ª—è–µ—Ç—Å—è —ç–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–æ–π –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω–∞ —Å –ø–æ–º–æ—â—å—é:

```bash
$ zig test -femit-docs main.zig
```

```zig
const print = @import("std").debug.print;

pub fn main() !void {
    // –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ Zig –Ω–∞—á–∏–Ω–∞—é—Ç—Å—è —Å "//" –∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è –Ω–∞ —Å–ª–µ–¥—É—é—â–µ–º LF-–±–∞–π—Ç–µ (–∫–æ–Ω—Ü–µ —Å—Ç—Ä–æ–∫–∏).
    // –°—Ç—Ä–æ–∫–∞ –Ω–∏–∂–µ —è–≤–ª—è–µ—Ç—Å—è –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–º –∏ –Ω–µ –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.

    //print("Hello?", .{});
    print("Hello, World!\n", .{});
}
```
```bash
$ zig build-exe comments.zig
$ ./comments
Hello, World!
```

–í **Zig** –Ω–µ—Ç –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã—Ö –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Ç–∞–∫–∏—Ö –∫–∞–∫ /* */ comments –≤ C). –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç **Zig** –æ–±–ª–∞–¥–∞—Ç—å
—Å–≤–æ–π—Å—Ç–≤–æ–º –ø–æ–∑–≤–æ–ª—è—é—â–∏–º –≤—ã–¥–µ–ª—è—Ç—å –∫–∞–∂–¥—É—é —Å—Ç—Ä–æ–∫—É –∫–æ–¥–∞ –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.


#### –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É

–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É `doc`–Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ä–æ–≤–Ω–æ —Å —Ç—Ä–µ—Ö –∫–æ—Å—ã—Ö —á–µ—Ä—Ç (—Ç.–µ. ///, –Ω–æ –Ω–µ —Å ////); –Ω–µ—Å–∫–æ–ª—å–∫–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –∫
–¥–æ–∫—É–º–µ–Ω—Ç—É `doc`–ø–æ–¥—Ä—è–¥ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è –≤ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É `doc`. –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ—Ç
–≤—Å–µ, —á—Ç–æ —Å–ª–µ–¥—É–µ—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∑–∞ –Ω–∏–º.

```zig
/// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ–π –º–µ—Ç–∫–∏ —Å —Ç–æ—á–Ω–æ—Å—Ç—å—é –¥–æ –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥—ã (—ç—Ç–æ
/// –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É).
const Timestamp = struct {
    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–µ–∫—É–Ω–¥, –ø—Ä–æ—à–µ–¥—à–∏—Ö —Å –º–æ–º–µ–Ω—Ç–∞ –Ω–∞—á–∞–ª–∞ —ç–ø–æ—Ö–∏ (—ç—Ç–æ —Ç–∞–∫–∂–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É).
    seconds: i64, // signed so we can represent pre-1970 (not a doc comment)
    /// –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –Ω–∞–Ω–æ—Å–µ–∫—É–Ω–¥, –ø—Ä–æ—à–µ–¥—à–∏—Ö –ø–æ—Å–ª–µ –≤—Ç–æ—Ä–æ–π (—Å–Ω–æ–≤–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É).
    nanos: u32,

    /// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É `Timestamp`, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â—É—é —ç–ø–æ—Ö—É Unix; —Ç–æ –µ—Å—Ç—å
    /// –º–æ–º–µ–Ω—Ç –≤—Ä–µ–º–µ–Ω–∏ 1 —è–Ω–≤–∞—Ä—è 1970 –≥–æ–¥–∞, 1 00:00:00 UTC (—ç—Ç–æ —Ç–æ–∂–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É).
    pub fn unixEpoch() Timestamp {
        return Timestamp{
            .seconds = 0,
            .nanos = 0,
        };
    }
};
```

–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ `doc` —Ä–∞–∑—Ä–µ—à–µ–Ω—ã —Ç–æ–ª—å–∫–æ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö –º–µ—Å—Ç–∞—Ö; –Ω–∞–ª–∏—á–∏–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è `doc` –≤ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ–º –º–µ—Å—Ç–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä, –≤
—Å–µ—Ä–µ–¥–∏–Ω–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏–ª–∏ –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–¥ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–º –Ω–µ –æ—Ç–Ω–æ—Å—è—â–∏–º—Å—è –∫ `doc` —è–≤–ª—è–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.

```zig
/// doc-comment
//! top-level doc-comment
const std = @import("std");
```
```bash
$ zig build-obj invalid_doc-comment.zig
doc/langref/invalid_doc-comment.zig:1:16: error: expected type expression, found 'a document comment'
/// doc-comment
```

```zig
pub fn main() void {}

/// End of file
```
```bash
$ zig build-obj unattached_doc-comment.zig
doc/langref/unattached_doc-comment.zig:3:1: error: unattached documentation comment
/// End of file
^~~~~~~~~~~~~~~
```

–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ `doc` –º–æ–≥—É—Ç —á–µ—Ä–µ–¥–æ–≤–∞—Ç—å—Å—è —Å –æ–±—ã—á–Ω—ã–º–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è–º–∏. –í –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ
–≤–∞—à–µ–º—É –≤–Ω–∏–º–∞–Ω–∏—é –æ–±—â–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –∫–æ—Ç–æ—Ä—ã–µ –æ–±—ä–µ–¥–∏–Ω—è—é—Ç—Å—è —Å —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è–º–∏ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–µ `doc`.

#### –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è

–ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å –¥–≤—É—Ö –∫–æ—Å—ã—Ö —á–µ—Ä—Ç –∏ –≤–æ—Å–∫–ª–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–≥–æ –∑–Ω–∞–∫–∞: //!; –æ–Ω –¥–æ–∫—É–º–µ–Ω—Ç–∏—Ä—É–µ—Ç
—Ç–µ–∫—É—â–∏–π –º–æ–¥—É–ª—å. –û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç, –µ—Å–ª–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –Ω–µ –ø–æ–º–µ—â–∞–µ—Ç—Å—è –≤ –Ω–∞—á–∞–ª–æ
–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –ø–µ—Ä–µ–¥ –∫–∞–∫–∏–º–∏-–ª–∏–±–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏.

```zig
//! –≠—Ç–æ—Ç –º–æ–¥—É–ª—å –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–µ–∫—É—â–µ–π –¥–∞—Ç—ã –∏
//! –≤—Ä–µ–º–µ–Ω–∏ —Å —Ä–∞–∑–ª–∏—á–Ω–æ–π —Å—Ç–µ–ø–µ–Ω—å—é —Ç–æ—á–Ω–æ—Å—Ç–∏. –û–Ω –Ω–µ
//! –∑–∞–≤–∏—Å–∏—Ç –æ—Ç libc, –Ω–æ –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –Ω–µ–≥–æ, –µ—Å–ª–∏ –æ–Ω–∏ –¥–æ—Å—Ç—É–ø–Ω—ã.

const S = struct {
    //! –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è —Ä–∞–∑—Ä–µ—à–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞, –æ—Ç–ª–∏—á–Ω–æ–≥–æ –æ—Ç –º–æ–¥—É–ª—è,
    //! –Ω–æ —ç—Ç–æ –Ω–µ –æ—á–µ–Ω—å –ø–æ–ª–µ–∑–Ω–æ.  –í –Ω–∞—Å—Ç–æ—è—â–µ–µ –≤—Ä–µ–º—è –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –ø–æ –ø–∞–∫–µ—Ç—É
    //! —ç—Ç–∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∏–≥–Ω–æ—Ä–∏—Ä—É—é—Ç—Å—è.
};
```
------------
### –ó–Ω–∞—á–µ–Ω–∏—è

```zig
// –û–±—ä—è–≤–ª–µ–Ω–∏—è –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è –Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞:
const print = std.debug.print;
const std = @import("std");
const os = std.os;
const assert = std.debug.assert;

pub fn main() !void {
    // integers
    const one_plus_one: i32 = 1 + 1;
    print("1 + 1 = {d}\n", .{one_plus_one});

    // floats
    const seven_div_three: f32 = 7.0 / 3.0;
    print("7.0 / 3.0 = {any}\n", .{seven_div_three});

    // booleans
    print("{any}\n{any}\n{any}\n\n", .{
        true and false,
        true or false,
        !true,
    });

    // optional
    var optional_value: ?[]const u8 = null;
    assert(optional_value == null);

    print("optional 1\ntype: {any}\nvalue: {?s}\n\n", .{
        @TypeOf(optional_value),
        optional_value,
    });

    optional_value = "hi";
    assert(optional_value != null);

    print("optional 2\ntype: {any}\nvalue: {?s}\n\n", .{
        @TypeOf(optional_value),
        optional_value,
    });

    // error union
    var number_or_error: anyerror!i32 = error.ArgNotFound;

    print("error union 1\ntype: {any}\nvalue: {any}\n\n", .{
        @TypeOf(number_or_error),
        number_or_error,
    });

    number_or_error = 1234;

    print("error union 2\ntype: {any}\nvalue: {any}\n\n", .{
        @TypeOf(number_or_error),
        number_or_error,
    });
}
```
```bash
$ zig build-exe values.zig
$ ./values
1 + 1 = 2
7.0 / 3.0 = 2.3333333e0
false
true
false

optional 1
type: ?[]const u8
value: null

optional 2
type: ?[]const u8
value: hi

error union 1
type: anyerror!i32
value: error.ArgNotFound

error union 2
type: anyerror!i32
value: 1234
```

**<center>Primitive Types</center>**
|Type|C Equivalent|Description|
|----|------------|-----------|
| <font color="blue">`i8`</font>| `int8_t` | signed 8-bit integer
| <font color="blue">`u8`</font>| `uint8_t` | unsigned 8-bit integer
| <font color="blue">`i16`</font>| `int16_t` | signed 16-bit integer |
| <font color="blue">`u16`</font>| `uint16_t` | unsigned 16-bit integer
| <font color="blue">`i32`</font>| `int32_t` | signed 32-bit integer
| <font color="blue">`u32`</font>| `uint32_t` | unsigned 32-bit integer
| <font color="blue">`i64`</font>| `int64_t` | signed 64-bit integer
| <font color="blue">`u64`</font>| `uint64_t` | unsigned 64-bit integer
| <font color="blue">`i128`</font>| `__int128` | signed 128-bit integer
| <font color="blue">`u128`</font>| `unsigned __int128` | unsigned 128-bit integer
| <font color="blue">`isize`</font>| `intptr_t` | signed pointer sized integer
| <font color="blue">`usize`</font>| `uintptr_t`, `size_t` | unsigned pointer sized integer. Also see #5185
| <font color="blue">`c_char`</font>| `char` | for ABI compatibility with C
| <font color="blue">`c_short`</font>| `short` | for ABI compatibility with C
| <font color="blue">`c_ushort`</font>| `unsigned short` | for ABI compatibility with C
| <font color="blue">`c_int`</font> | `int` | for ABI compatibility with C
| <font color="blue">`c_uint`</font>| `unsigned int` | for ABI compatibility with C
| <font color="blue">`c_long`</font> | `long` | for ABI compatibility with C
| <font color="blue">`c_ulong`</font>| `unsigned long` | for ABI compatibility with C
| <font color="blue">`c_longlong`</font>| `long long` | for ABI compatibility with C
| <font color="blue">`c_ulonglong`</font>| `unsigned long long` | for ABI compatibility with C
| <font color="blue">`c_longdouble`</font>| `long double` | for ABI compatibility with C
| <font color="blue">`f16`</font>| `_Float16` | 16-bit floating point (10-bit mantissa) IEEE-754-2008 binary16
| <font color="blue">`f32`</font>| `float` | 32-bit floating point (23-bit mantissa) IEEE-754-2008 binary32
| <font color="blue">`f64`</font>| `double` | 64-bit floating point (52-bit mantissa) IEEE-754-2008 binary64
| <font color="blue">`f80`</font>| `double` | 80-bit floating point (64-bit mantissa) IEEE-754-2008 80-bit extended precision
| <font color="blue">`f128`</font>| `_Float128` | 128-bit floating point (112-bit mantissa) IEEE-754-2008 binary128
| <font color="blue">`bool`</font>| `bool` | true or false
| <font color="blue">`anytype`</font>| `void` | Used for type-erased pointers.
| <font color="blue">`void`</font>| `(none)` |  Always the value void{}
| <font color="blue">`noreturn`</font>| `(none)` | the type of break, continue, return, unreachable, and while (true) {}
| <font color="blue">`type`</font>| `(none)` | the type of types
| <font color="blue">`anyerror`</font>| `(none)` | an error code
| <font color="blue">`comptime_int`</font>| `(none)` | Only allowed for comptime-known values. The type of integer literals.
| <font color="blue">`comptime_float`</font>| `(none)` | Only allowed for comptime-known values. The type of float literals.

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–º —Ç–∏–ø–∞–º, —É–∫–∞–∑–∞–Ω–Ω—ã–º –≤—ã—à–µ, –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫–∏ –Ω–∞ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç–∏,
–∏—Å–ø–æ–ª—å–∑—É—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä `i` –∏–ª–∏ `u`, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É—é—Ç —Ü–∏—Ñ—Ä—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä i7 –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ 7-—Ä–∞–∑—Ä—è–¥–Ω–æ–º—É
—Ü–µ–ª–æ–º—É —á–∏—Å–ª—É —Å–æ –∑–Ω–∞–∫–æ–º. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å –¥–ª—è —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ —Ä–∞–≤–Ω–∞ 65535.

**<center>Primitive Values</center>**
|Name|Description|
|---|---|
| <font color="red">`true`</font> and <font color="red">`false`</font> | <font color="blue">`bool`</font> values |
| <font color="red">`null`</font> | used to set an optional type to <font color="red">`null`</font> |
| <font color="red">`undefined`</font> | used to leave a value unspecified |


#### –°—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –∏ –ª–∏—Ç–µ—Ä–∞–ª—ã —Å –∫–æ–¥–æ–≤–æ–π —Ç–æ—á–∫–æ–π –≤ –Æ–Ω–∏–∫–æ–¥–µ

–°—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã - —ç—Ç–æ –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω—ã–µ –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –º–∞—Å—Å–∏–≤—ã –±–∞–π—Ç–æ–≤ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –Ω—É–ª–µ–º. –¢–∏–ø —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö
–ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –∫–æ–¥–∏—Ä—É–µ—Ç –∫–∞–∫ –¥–ª–∏–Ω—É, —Ç–∞–∫ –∏ —Ç–æ—Ç —Ñ–∞–∫—Ç, —á—Ç–æ –æ–Ω–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è –Ω—É–ª–µ–º –∏ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –æ–Ω–∏ –º–æ–≥—É—Ç –±—ã—Ç—å
–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –∫–∞–∫ –≤ —Å—Ä–µ–∑—ã, —Ç–∞–∫ –∏ –≤ —É–∫–∞–∑–∞—Ç–µ–ª–∏, –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –Ω—É–ª–µ–º. –†–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç
–∏—Ö –≤ –º–∞—Å—Å–∏–≤—ã.

–ü–æ—Å–∫–æ–ª—å–∫—É –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ **Zig** –∑–∞–∫–æ–¥–∏—Ä–æ–≤–∞–Ω –≤ UTF-8, –ª—é–±—ã–µ –±–∞–π—Ç—ã, –æ—Ç–ª–∏—á–∞—é—â–∏–µ—Å—è –æ—Ç ASCII, –ø–æ—è–≤–ª—è—é—â–∏–µ—Å—è –≤ —Å—Ç—Ä–æ–∫–æ–≤–æ–º –ª–∏—Ç–µ—Ä–∞–ª–µ –≤
–∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ, –ø–µ—Ä–µ–¥–∞—é—Ç —Å–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ —Ñ–æ—Ä–º–∞—Ç–µ UTF-8 –≤ —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Å—Ç—Ä–æ–∫–∏ –≤ –ø—Ä–æ–≥—Ä–∞–º–º–µ **Zig**; –±–∞–π—Ç—ã –Ω–µ –∏–∑–º–µ–Ω—è—é—Ç—Å—è
–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º. –ú–æ–∂–Ω–æ –≤—Å—Ç–∞–≤–∏—Ç—å –±–∞–π—Ç—ã, –æ—Ç–ª–∏—á–Ω—ã–µ –æ—Ç UTF-8, –≤ —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª, –∏—Å–ø–æ–ª—å–∑—É—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏–µ \xNN.

–ü—Ä–∏ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å—Ç—Ä–æ–∫–∏, —Å–æ–¥–µ—Ä–∂–∞—â–µ–π –±–∞–π—Ç—ã, –æ—Ç–ª–∏—á–Ω—ã–µ –æ—Ç ASCII, –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω—ã–µ –±–∞–π—Ç—ã, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ,
—è–≤–ª—è–µ—Ç—Å—è –ª–∏ –¥–æ–ø—É—Å—Ç–∏–º—ã–º UTF-8 –∏–ª–∏ –Ω–µ—Ç.

–õ–∏—Ç–µ—Ä–∞–ª—ã —Å –∫–æ–¥–æ–≤–æ–π —Ç–æ—á–∫–æ–π –≤ –Æ–Ω–∏–∫–æ–¥–µ –∏–º–µ—é—Ç —Ç–∏–ø `comptime_int`, —Ç–∞–∫–æ–π –∂–µ, –∫–∞–∫ –∏ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã. –í—Å–µ —É–ø—Ä–∞–≤–ª—è—é—â–∏–µ
–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –¥–æ–ø—É—Å—Ç–∏–º—ã –∫–∞–∫ –≤ —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–∞—Ö, —Ç–∞–∫ –∏ –≤ –ª–∏—Ç–µ—Ä–∞–ª–∞—Ö —Å –∫–æ–¥–æ–≤–æ–π —Ç–æ—á–∫–æ–π –≤ –Æ–Ω–∏–∫–æ–¥–µ.

```zig
const print = @import("std").debug.print;
const mem = @import("std").mem;

pub fn main() !void {
    const bytes = "hello";
    print("{any}\n", .{@TypeOf(bytes)});
    print("{d}\n", .{bytes.len});
    print("{c}\n", .{bytes[1]});
    print("{d}\n", .{bytes[5]});
    print("{}\n", .{'e' == '\x65'});
    print("{d}\n", .{'\u{1f4a9}'});
    print("{d}\n", .{'üíØ'}); // 128175
    print("{u}\n", .{'‚ö°'});
    print("{}\n", .{mem.eql(u8, "hello", "h\x65llo")}); // true
    print("{}\n", .{mem.eql(u8, "üíØ", "\xf0\x9f\x92\xaf")}); // also true

    const invalid_utf8 = "\xff\xfe"; // non-UTF-8 strings are possible with \xNN notation.
    print("0x{x}\n", .{invalid_utf8[1]}); // indexing them returns individual bytes...
    print("0x{x}\n", .{"üíØ"[1]}); // ...as does indexing part-way through non-ASCII characters
}
```
```bash
$ zig build-exe string_literals.zig
$ ./string_literals
*const [5:0]u8
5
e
0
true
128169
128175
‚ö°
true
true
0xfe
0x9f
```

##### –£–ø—Ä–∞–≤–ª—è—é—â–∏–µ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

**<center>Escape Sequences</center>**
|Escape Sequence|Name|
|---------------|----|
|`\n` |Newline
|`\r` | Carriage Return
|`\t` | Tab
|`\\` | Backslash
|`\'` | Single Quote
|`\"` | Double Quote
|`\xNN` | hexadecimal 7-bit byte value (2 digits)
|`\u{NNNNNN}` | hexadecimal Unicode code point UTF-8 encoded (1 or more digits)

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ç–æ—á–∫–∞ –≤ –Æ–Ω–∏–∫–æ–¥–µ —Ä–∞–≤–Ω–∞ <font color="red">`0x10ffff`</font>.

##### –ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã

–ú–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–µ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –Ω–µ –∏–º–µ—é—Ç —ç–∫—Ä–∞–Ω–∏—Ä—É—é—â–∏—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏ –º–æ–≥—É—Ç –∑–∞–Ω–∏–º–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å—Ç—Ä–æ–∫. –ß—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å
–º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏–º–≤–æ–ª \\. –ö–∞–∫ –∏ –≤ —Å–ª—É—á–∞–µ —Å –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–º, —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –¥–æ
–∫–æ–Ω—Ü–∞ —Å—Ç—Ä–æ–∫–∏. –ö–æ–Ω–µ—Ü —Å—Ç—Ä–æ–∫–∏ –Ω–µ –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª. –û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä–æ–∫–∞ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å \\, —Ç–æ
–¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –Ω–æ–≤–∞—è —Å—Ç—Ä–æ–∫–∞ –∏ —Å—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è.

```zig
const hello_world_in_c =
    \\#include <stdio.h>
    \\
    \\int main(int argc, char **argv) {
    \\    printf("hello world\n");
    \\    return 0;
    \\}
;
```

#### –ü—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `const` –¥–ª—è –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—É:

```zig
const x = 1234;

fn foo() void {
    // –û–Ω —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –≤ –æ–±–ª–∞—Å—Ç–∏ –¥–µ–π—Å—Ç–≤–∏—è —Ñ–∞–π–ª–∞, —Ç–∞–∫ –∏ –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π.
    const y = 5678;

    // –ü–æ—Å–ª–µ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω.
    y += 1;
}

pub fn main() void {
    foo();
}
```
```bash
$ zig build-exe constant_identifier_cannot_change.zig
/home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:8:7: error: cannot assign to constant
    y += 1;
    ~~^~~~
referenced by:
    main: /home/andy/src/zig/doc/langref/constant_identifier_cannot_change.zig:12:5
    callMain: /home/andy/src/zig/lib/std/start.zig:514:17
    remaining reference traces hidden; use '-freference-trace' to see all reference traces
```
–ó–Ω–∞—á–µ–Ω–∏–µ `const` –ø—Ä–∏–º–µ–Ω—è–µ—Ç—Å—è –∫–æ –≤—Å–µ–º –±–∞–π—Ç–∞–º –∫ –∫–æ—Ç–æ—Ä—ã–º –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä. –£–∫–∞–∑–∞—Ç–µ–ª–∏ –∏–º–µ—é—Ç —Å–≤–æ—é
—Å–æ–±—Å—Ç–≤–µ–Ω–Ω—É—é –∫–æ–Ω—Å—Ç–∞–Ω—Ç—É.

–ï—Å–ª–∏ –≤–∞–º –Ω—É–∂–Ω–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–∂–µ—Ç–µ –∏–∑–º–µ–Ω—è—Ç—å, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `var`:
```zig
const print = @import("std").debug.print;

pub fn main() void {
    var y: i32 = 5678;

    y += 1;

    print("{d}", .{y});
}
```
```bash
$ zig build-exe mutable_var.zig
$ ./mutable_var
5679
```
–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã:
```zig
pub fn main() void {
    var x: i32;

    x = 1;
}
```
```bash
$ zig build-exe var_must_be_initialized.zig
/home/andy/src/zig/doc/langref/var_must_be_initialized.zig:2:15: error: expected '=', found ';'
    var x: i32;
```

##### –ù–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–π

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ <font color="red">`undefined`</font> —á—Ç–æ–±—ã –æ—Å—Ç–∞–≤–∏—Ç—å –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–º–∏:
```zig
const print = @import("std").debug.print;

pub fn main() void {
    var x: i32 = undefined;
    x = 1;
    print("{d}", .{x});
}
```
```bash
$ zig build-exe assign_undefined.zig
$ ./assign_undefined
1
```

–ó–Ω–∞—á–µ–Ω–∏–µ <font color="red">`undefined`</font> –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –∫ –ª—é–±–æ–º—É —Ç–∏–ø—É. –ö–∞–∫ —Ç–æ–ª—å–∫–æ —ç—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç, —É–∂–µ
–Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –±—É–¥–µ—Ç –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ. –ó–Ω–∞—á–µ–Ω–∏–µ <font color="red">`undefined`</font> –º–æ–∂–µ—Ç –±—ã—Ç—å
–ª—é–±—ã–º, –¥–∞–∂–µ –±–µ—Å—Å–º—ã—Å–ª–µ–Ω–Ω—ã–º –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å —Ç–∏–ø–æ–º. –í –ø–µ—Ä–µ–≤–æ–¥–µ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–∏–π <font color="red">`undefined`</font>
–æ–∑–Ω–∞—á–∞–µ—Ç "–ù–µ –∏–º–µ—é—â–µ–µ —Å–º—ã—Å–ª–∞ –∑–Ω–∞—á–µ–Ω–∏–µ". –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –æ—à–∏–±–∫–µ. –ó–Ω–∞—á–µ–Ω–∏–µ –±—É–¥–µ—Ç
–Ω–µ–∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–º –∏–ª–∏ –ø–µ—Ä–µ–∑–∞–ø–∏—Å–∞–Ω–Ω—ã–º –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º.

–í —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏ **Zig** –∑–∞–ø–∏—Å—ã–≤–∞–µ—Ç <font color="red">`0xaa`</font> –±–∞–π—Ç –≤ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é –ø–∞–º—è—Ç—å. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è –¥–ª—è
—Ä–∞–Ω–Ω–µ–≥–æ –≤—ã—è–≤–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫ –∏ –ø–æ–º–æ–≥–∞–µ—Ç –æ–±–Ω–∞—Ä—É–∂–∏—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç–∏ –≤ –æ—Ç–ª–∞–¥—á–∏–∫–µ. –û–¥–Ω–∞–∫–æ —Ç–∞–∫–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
—è–≤–ª—è–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –æ—Å–æ–±–µ–Ω–Ω–æ—Å—Ç—å—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –∞ –Ω–µ —Å–µ–º–∞–Ω—Ç–∏–∫–æ–π —è–∑—ã–∫–∞, –ø–æ—ç—Ç–æ–º—É –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è, —á—Ç–æ –æ–Ω–æ –±—É–¥–µ—Ç –Ω–∞–±–ª—é–¥–∞—Ç—å—Å—è –≤
–∫–æ–¥–µ.

------------
### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ Zig

–ö–æ–¥, –Ω–∞–ø–∏—Å–∞–Ω–Ω—ã–π –≤ —Ä–∞–º–∫–∞—Ö –æ–¥–Ω–æ–≥–æ –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–µ—Å—Ç–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è
–ø–æ–≤–µ–¥–µ–Ω–∏—è –æ–∂–∏–¥–∞–Ω–∏—è–º –ø—Ä–æ–≥—Ä–∞–º–º—ã:

```zig
const std = @import("std");

test "expect addOne adds one to 41" {
    // –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –ø–æ–º–æ–≥–∞—é—â–∏–µ —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–µ—Å—Ç—ã.
    // `expect` - —ç—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –ø—Ä–æ–≤–µ—Ä—è–µ—Ç, —á—Ç–æ –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω true.
    // –û–Ω–∞ –≤–µ—Ä–Ω–µ—Ç –æ—à–∏–±–∫—É, –µ—Å–ª–∏ –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç —Ä–∞–≤–µ–Ω false, —á—Ç–æ —É–∫–∞–∑—ã–≤–∞–µ—Ç –Ω–∞ —Å–±–æ–π.
    // `try` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏ —Ç–µ—Å—Ç–∏—Ä–æ–≤—â–∏–∫—É, —á—Ç–æ–±—ã —É–≤–µ–¥–æ–º–∏—Ç—å –µ–≥–æ –æ —Ç–æ–º, —á—Ç–æ —Ç–µ—Å—Ç –Ω–µ –ø—Ä–æ—à–µ–ª.
    try std.testing.expect(addOne(41) == 42);
}

test addOne {
    // –ò–º—è —Ç–µ—Å—Ç–∞ —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–ø–∏—Å–∞–Ω–æ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞.
    // –≠—Ç–æ —Ç–µ—Å—Ç–æ–≤—ã–π –¥–æ–∫—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–ª—É–∂–∏—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π –¥–ª—è `addOne`.
    try std.testing.expect(addOne(41) == 42);
}

/// –§—É–Ω–∫—Ü–∏—è `addOne` –¥–æ–±–∞–≤–ª—è–µ—Ç –µ–¥–∏–Ω–∏—Ü—É –∫ —á–∏—Å–ª—É, —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –≤ –∫–∞—á–µ—Å—Ç–≤–µ –µ–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞.
fn addOne(number: i32) i32 {
    return number + 1;
}
```
```bash
$ zig test testing_introduction.zig
1/2 testing_introduction.test.expect addOne adds one to 41...OK
2/2 testing_introduction.decltest.addOne...OK
All 2 tests passed.
```

–ü—Ä–∏–º–µ—Ä –∫–æ–¥–∞ testing_introduction.zig –ø—Ä–æ–≤–µ—Ä—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é `addOne`, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ 42 –ø—Ä–∏
–≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö 41. –° —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞, —Ñ—É–Ω–∫—Ü–∏—è `addOne` —è–≤–ª—è–µ—Ç—Å—è —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–º –∫–æ–¥–æ–º.

`zig test` - —ç—Ç–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–∑–¥–∞–µ—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é —Å–±–æ—Ä–∫—É. –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –æ–Ω —Å–æ–∑–¥–∞–µ—Ç –∏ –∑–∞–ø—É—Å–∫–∞–µ—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º—É—é
–ø—Ä–æ–≥—Ä–∞–º–º—É, –∏—Å–ø–æ–ª—å–∑—É—è —Å—Ä–µ–¥—Å—Ç–≤–æ –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π **Zig**, –≤ –∫–∞—á–µ—Å—Ç–≤–µ
–æ—Å–Ω–æ–≤–Ω–æ–π —Ç–æ—á–∫–∏ –≤—Ö–æ–¥–∞. –í–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ –ø—Ä–∏ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏ –¥–∞–Ω–Ω–æ–≥–æ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ **Zig**,
–≤–∫–ª—é—á–∞—é—Ç—Å—è –≤ –ø—Ä–æ–≥—Ä–∞–º–º—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∏ —Å–æ—Å—Ç–∞–≤–ª–µ–Ω–∏—è –æ—Ç—á–µ—Ç–∞.

>–í —ç—Ç–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—é—Ç—Å—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ–º–æ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π
>–±–∏–±–ª–∏–æ—Ç–µ–∫–æ–π **Zig**. –ï–µ –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ lib/test_runner.zig.

–í –≤—ã–≤–æ–¥–µ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –ø–æ–∫–∞–∑–∞–Ω–Ω–æ–º –≤—ã—à–µ, –ø–æ—Å–ª–µ –∫–æ–º–∞–Ω–¥—ã `zig test` –æ—Ç–æ–±—Ä–∞–∂–∞—é—Ç—Å—è –¥–≤–µ —Å—Ç—Ä–æ–∫–∏. –ü—Ä–æ–≥—Ä–∞–º–º–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ
—É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–≤–æ–¥–∏—Ç —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ —Å–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –æ—à–∏–±–∫–æ–π:
**<br>`1/2 testing_introduction.test.expect addOne adds one to 41...`<br>**
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–°—Ç—Ä–æ–∫–∏, –ø–æ–¥–æ–±–Ω—ã–µ —ç—Ç–æ–π, —É–∫–∞–∑—ã–≤–∞—é—Ç, –∫–∞–∫–æ–π —Ç–µ—Å—Ç –∏–∑
–æ–±—â–µ–≥–æ —á–∏—Å–ª–∞ —Ç–µ—Å—Ç–æ–≤ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è. –í –¥–∞–Ω–Ω–æ–º —Å–ª—É—á–∞–µ 1/2 –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø–µ—Ä–≤—ã–π —Ç–µ—Å—Ç –∏–∑ –æ–±—â–µ–≥–æ —á–∏—Å–ª–∞ –¥–≤—É—Ö —Ç–µ—Å—Ç–æ–≤.
–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –∫–æ–≥–¥–∞ –≤ —Ç–µ—Ä–º–∏–Ω–∞–ª –≤—ã–≤–æ–¥–∏—Ç—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã test runner, —ç—Ç–∏ —Å—Ç—Ä–æ–∫–∏ –æ—á–∏—â–∞—é—Ç—Å—è –ø—Ä–∏
—É—Å–ø–µ—à–Ω–æ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ —Ç–µ—Å—Ç–∞.
**<br>`2/2 testing_introduction.decltest.addOne...`<br>**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–ö–æ–≥–¥–∞ –∏–º—è —Ç–µ—Å—Ç–∞ —è–≤–ª—è–µ—Ç—Å—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–º, –ø—Ä–æ–≥—Ä–∞–º–º–∞
—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ç–µ–∫—Å—Ç decltest –≤–º–µ—Å—Ç–æ test. **<br>`All 2 tests passed.`<br>**
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;–í —ç—Ç–æ–π —Å—Ç—Ä–æ–∫–µ —É–∫–∞–∑–∞–Ω–æ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ–π–¥–µ–Ω–Ω—ã—Ö
—Ç–µ—Å—Ç–æ–≤.

#### –û–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤

–û–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ —Å–æ–¥–µ—Ä–∂–∞—Ç –∫–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `test`, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É–µ—Ç –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –∏–º—è, –∑–∞–ø–∏—Å–∞–Ω–Ω–æ–µ –≤ –≤–∏–¥–µ —Å—Ç—Ä–æ–∫–æ–≤–æ–≥–æ
–ª–∏—Ç–µ—Ä–∞–ª–∞ –∏–ª–∏ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞, –∞ –∑–∞—Ç–µ–º –±–ª–æ–∫, —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –ª—é–±–æ–π –¥–æ–ø—É—Å—Ç–∏–º—ã–π **Zig**-–∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π —Ä–∞–∑—Ä–µ—à–µ–Ω –≤ —Ñ—É–Ω–∫—Ü–∏–∏.

–¢–µ—Å—Ç–æ–≤—ã–µ –±–ª–æ–∫–∏ –±–µ–∑ –∏–º–µ–Ω–∏ –≤—Å–µ–≥–¥–∞ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏ —Ç–µ—Å—Ç–æ–≤ –∏ –Ω–µ –ø–æ–¥–ª–µ–∂–∞—Ç –ø—Ä–æ–ø—É—Å–∫—É —Ç–µ—Å—Ç–æ–≤.

–û–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –ø–æ—Ö–æ–∂–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏: —É –Ω–∏—Ö –µ—Å—Ç—å —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∏ –±–ª–æ–∫ –∫–æ–¥–∞. –ù–µ—è–≤–Ω—ã–π —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ
–∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ - —ç—Ç–æ —Ç–∏–ø –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫ `anyerror!void`, –∏ –µ–≥–æ –Ω–µ–ª—å–∑—è –∏–∑–º–µ–Ω–∏—Ç—å. –ï—Å–ª–∏ –∏—Å—Ö–æ–¥–Ω—ã–π —Ñ–∞–π–ª **Zig** –Ω–µ
—Å–æ–∑–¥–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é `zig test tool`, –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –Ω–µ –≤–∫–ª—é—á–∞—é—Ç—Å—è –≤ —Å–±–æ—Ä–∫—É.

–û–±—ä—è–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤ –º–æ–≥—É—Ç –±—ã—Ç—å –∑–∞–ø–∏—Å–∞–Ω—ã –≤ —Ç–æ–º –∂–µ —Ñ–∞–π–ª–µ, –≤ –∫–æ—Ç–æ—Ä–æ–º –∑–∞–ø–∏—Å–∞–Ω —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –∫–æ–¥, –∏–ª–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –∏—Å—Ö–æ–¥–Ω–æ–º —Ñ–∞–π–ª–µ
**Zig**. –ü–æ—Å–∫–æ–ª—å–∫—É —Ç–µ—Å—Ç–æ–≤—ã–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è —è–≤–ª—è—é—Ç—Å—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è–º–∏ –≤–µ—Ä—Ö–Ω–µ–≥–æ —É—Ä–æ–≤–Ω—è, –æ–Ω–∏ –Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏
–º–æ–≥—É—Ç –±—ã—Ç—å –Ω–∞–ø–∏—Å–∞–Ω—ã –¥–æ –∏–ª–∏ –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ–≥–æ –∫–æ–¥–∞.

##### –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏

–¢–µ—Å—Ç–æ–≤—ã–µ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏–º–µ–Ω—É–µ–º—ã–µ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞ —è–≤–ª—è—é—Ç—Å—è —Ç–µ—Å—Ç–∞–º–∏ doctests. –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –¥–æ–ª–∂–µ–Ω
—Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –¥—Ä—É–≥–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –≤ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏. –¢–µ—Å—Ç doctest, –∫–∞–∫ –∏ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É, —Å–ª—É–∂–∏—Ç –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–µ–π
–¥–ª—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è –∏ –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å—Å—è –≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è.

–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∞–≤—Ç–æ–Ω–æ–º–Ω—ã–º –∏ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–µ–Ω–Ω—ã–º –Ω–∞ —Ç–µ—Å—Ç–∏—Ä—É–µ–º–æ–π –¥–µ–∫–ª–∞—Ä–∞—Ü–∏–∏, –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ –≤–æ–ø—Ä–æ—Å—ã,
–∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –≤–æ–∑–Ω–∏–∫–Ω—É—Ç—å —É –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –æ –µ–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–µ –∏–ª–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏, –∏–∑–±–µ–≥–∞—è –ø—Ä–∏ —ç—Ç–æ–º
–Ω–µ–Ω—É–∂–Ω—ã—Ö –∏–ª–∏ —Å–±–∏–≤–∞—é—â–∏—Ö —Å —Ç–æ–ª–∫—É –¥–µ—Ç–∞–ª–µ–π. Doctest - —ç—Ç–æ –Ω–µ –∑–∞–º–µ–Ω–∞ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏—è –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É, –∞ —Å–∫–æ—Ä–µ–µ –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∏
–∫–æ–º–ø–∞–Ω—å–æ–Ω, –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—â–∏–π —Ç–µ—Å—Ç–∏—Ä—É–µ–º—ã–π –ø—Ä–∏–º–µ—Ä, –æ—Å–Ω–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –∫–æ–¥–µ, –ø—Ä–æ–≤–µ—Ä–µ–Ω–Ω—ã–π —Å –ø–æ–º–æ—â—å—é `zig test`.

#### –û—à–∏–±–∫–∏ –≤ —Ç–µ—Å—Ç–∞—Ö

–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–∫–∏ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω–æ–π –∏–∑ —Ç–µ—Å—Ç–∞. –ö–æ–≥–¥–∞ —Ç–µ—Å—Ç –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É,
—Ç–µ—Å—Ç —Å—á–∏—Ç–∞–µ—Ç—Å—è –Ω–µ—É–¥–∞—á–Ω—ã–º –∏ –µ–≥–æ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏ –≤—ã–≤–æ–¥–∏—Ç—Å—è –≤ –≤–∏–¥–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –æ—à–∏–±–∫–∏. –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –æ—à–∏–±–æ–∫
–±—É–¥–µ—Ç —É–∫–∞–∑–∞–Ω–æ –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤.

```zig
const std = @import("std");

test "expect this to fail" {
    try std.testing.expect(false);
}

test "expect this to succeed" {
    try std.testing.expect(true);
}
```
```bash
$ zig test testing_failure.zig
1/2 testing_failure.test.expect this to fail...FAIL (TestUnexpectedResult)
/home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce3f in expect (test)
    if (!ok) return error.TestUnexpectedResult;
             ^
/home/andy/src/zig/doc/langref/testing_failure.zig:4:5: 0x103cf55 in test.expect this to fail (test)
    try std.testing.expect(false);
    ^
2/2 testing_failure.test.expect this to succeed...OK
1 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/054f0b6f088824f384d1b6c648523593/test
```

#### –ü—Ä–æ–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤

–û–¥–∏–Ω –∏–∑ —Å–ø–æ—Å–æ–±–æ–≤ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç—ã - –æ—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞—Ç—å –∏—Ö —Å –ø–æ–º–æ—â—å—é –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ `zig test --test-filter [text]`.
–í —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –≤ —Ç–µ—Å—Ç–æ–≤—É—é —Å–±–æ—Ä–∫—É –±—É–¥—É—Ç –≤–∫–ª—é—á–µ–Ω—ã —Ç–æ–ª—å–∫–æ —Ç–µ —Ç–µ—Å—Ç—ã, –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω—ã–π —Ç–µ–∫—Å—Ç —Ñ–∏–ª—å—Ç—Ä–∞.
–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –Ω–µ–∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ —Ç–µ—Å—Ç—ã –∑–∞–ø—É—Å–∫–∞—é—Ç—Å—è –¥–∞–∂–µ –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ `--test-filter
[text]`.

–ß—Ç–æ–±—ã –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Ç–µ—Å—Ç, —Å–¥–µ–ª–∞–π—Ç–µ —Ç–∞–∫, —á—Ç–æ–±—ã —Ç–µ—Å—Ç –≤–æ–∑–≤—Ä–∞—â–∞–ª —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ `error.SkipZigTest` –∏ –ø—Ä–æ–≥—Ä–∞–º–º–∞
—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –±—É–¥—É—Ç —Å—á–∏—Ç–∞—Ç—å —Ç–µ—Å—Ç –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º. –ü–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—Å–µ—Ö —Ç–µ—Å—Ç–æ–≤ –±—É–¥–µ—Ç —Å–æ–æ–±—â–µ–Ω–æ –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ
–ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤.

```zig
test "this will be skipped" {
    return error.SkipZigTest;
}
```
```bash
$ zig test testing_skip.zig
1/1 testing_skip.test.this will be skipped...SKIP
0 passed; 1 skipped; 0 failed.h
```

#### –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± —É—Ç–µ—á–∫–∞—Ö –ø–∞–º—è—Ç–∏

–ö–æ–≥–¥–∞ –∫–æ–¥ –≤—ã–¥–µ–ª—è–µ—Ç –ø–∞–º—è—Ç—å —Å –ø–æ–º–æ—â—å—é —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ **Zig**, `std.testing.allocator`,
–ø—Ä–æ–≥—Ä–∞–º–º–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–æ–æ–±—â–∞–µ—Ç –æ –ª—é–±—ã—Ö —É—Ç–µ—á–∫–∞—Ö, –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω—ã—Ö –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∞–ª–ª–æ–∫–∞—Ç–æ—Ä–∞:

```zig
const std = @import("std");

test "detect leak" {
    var list = std.ArrayList(u21).init(std.testing.allocator);
    // –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç `defer list.deinit();`
    try list.append('‚òî');

    try std.testing.expect(list.items.len == 1);
}
```
```bash
$ zig test testing_detect_leak.zig
1/1 testing_detect_leak.test.detect leak...OK
[gpa] (err): memory address 0x7fdbea69e000 leaked:
/home/andy/src/zig/lib/std/array_list.zig:457:67: 0x104f76e in ensureTotalCapacityPrecise (test)
                const new_memory = try self.allocator.alignedAlloc(T, alignment, new_capacity);
                                                                  ^
/home/andy/src/zig/lib/std/array_list.zig:434:51: 0x1045610 in ensureTotalCapacity (test)
            return self.ensureTotalCapacityPrecise(better_capacity);
                                                  ^
/home/andy/src/zig/lib/std/array_list.zig:483:41: 0x1041fe0 in addOne (test)
            try self.ensureTotalCapacity(newlen);
                                        ^
/home/andy/src/zig/lib/std/array_list.zig:262:49: 0x103ef2d in append (test)
            const new_item_ptr = try self.addOne();
                                                ^
/home/andy/src/zig/doc/langref/testing_detect_leak.zig:6:20: 0x103d172 in test.detect leak (test)
    try list.append('‚òî');
                   ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c6a0 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x10428bb in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103f429 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103ef91 in _start (test)
    asm volatile (switch (native_arch) {
    ^

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/4a17198138bf81bcfabd5652b0d6be24/test
```

#### –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–π —Å–±–æ—Ä–∫–∏

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ `@import("builtin").is_test` –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤–æ–π —Å–±–æ—Ä–∫–∏:

```zig
const std = @import("std");
const builtin = @import("builtin");
const expect = std.testing.expect;

test "builtin.is_test" {
    try expect(isATest());
}

fn isATest() bool {
    return builtin.is_test;
}
```
```bash
$ zig test testing_detect_test.zig
1/1 testing_detect_test.test.builtin.is_test...OK
All 1 tests passed.
```

#### –¢–µ—Å—Ç–æ–≤—ã–π –≤—ã–≤–æ–¥ –∏ –≤–µ–¥–µ–Ω–∏–µ –∂—É—Ä–Ω–∞–ª–∞

–ü—Ä–æ–≥—Ä–∞–º–º–∞ –∑–∞–ø—É—Å–∫–∞ —Ç–µ—Å—Ç–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –∏ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º–µ–Ω —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ **Zig** –≤—ã–≤–æ–¥—è—Ç —Å–æ–æ–±—â–µ–Ω–∏—è
–æ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –æ—à–∏–±–∫–µ.

#### –ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º–µ–Ω –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

–ü—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ –∏–º–µ–Ω `testing` —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ **Zig** —Å–æ–¥–µ—Ä–∂–∏—Ç –ø–æ–ª–µ–∑–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–º–æ–≥—É—Ç –≤–∞–º —Å–æ–∑–¥–∞–≤–∞—Ç—å
—Ç–µ—Å—Ç—ã. –í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ —Ñ—É–Ω–∫—Ü–∏–∏ `expect` –≤ —ç—Ç–æ–º –¥–æ–∫—É–º–µ–Ω—Ç–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –µ—â–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ñ—É–Ω–∫—Ü–∏–π, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –Ω–∞ –ø—Ä–∏–º–µ—Ä–µ
–Ω–∏–∂–µ:

```zig
const std = @import("std");

test "expectEqual demo" {
    const expected: i32 = 42;
    const actual = 42;

    // –ü–µ—Ä–≤—ã–π –∞—Ä–≥—É–º–µ–Ω—Ç `expectEqual` - —ç—Ç–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–π –æ–∂–∏–¥–∞–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç.
    // –í—Ç–æ—Ä–æ–π –∞—Ä–≥—É–º–µ–Ω—Ç - —ç—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–µ–∫–æ—Ç–æ—Ä–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è.
    // –¢–∏–ø actual –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ —Ç–∏–ø expected.
    try std.testing.expectEqual(expected, actual);
}

test "expectError demo" {
    const expected_error = error.DemoError;
    const actual_error_union: anyerror!void = error.DemoError;

    // `expectError` –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –æ—à–∏–±–∫–æ–π, –µ—Å–ª–∏ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç
    // –æ–∂–∏–¥–∞–µ–º–æ–π –æ—à–∏–±–∫–∏.
    try std.testing.expectError(expected_error, actual_error_union);
}
```
```bash
$ zig test testing_namespace.zig
1/2 testing_namespace.test.expectEqual demo...OK
2/2 testing_namespace.test.expectError demo...OK
All 2 tests passed.
```

–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ **Zig** —Ç–∞–∫–∂–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è —Å–ª–∞–π—Å–æ–≤, —Å—Ç—Ä–æ–∫ –∏ –º–Ω–æ–≥–æ–≥–æ –¥—Ä—É–≥–æ–≥–æ. –ò–∑—É—á–∏—Ç–µ
–æ—Å—Ç–∞–ª—å–Ω—É—é —á–∞—Å—Ç—å –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–∞ –∏–º–µ–Ω `std.testing` –≤ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–π –±–∏–±–ª–∏–æ—Ç–µ–∫–µ **Zig** –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π.

#### –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—É —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

–í `zig test` –µ—Å—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤–ª–∏—è—é—Ç –Ω–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏—é —Ç–µ—Å—Ç–æ–≤. –ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –ø—Ä–∏–≤–µ–¥–µ–Ω –≤
—Ä–∞–∑–¥–µ–ª–µ `zig test --help`.

------------
### –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è - —ç—Ç–æ –µ–¥–∏–Ω–∏—Ü–∞ —Ö—Ä–∞–Ω–µ–Ω–∏—è –≤ –ø–∞–º—è—Ç–∏.

–ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, –ø—Ä–∏ –æ–±—ä—è–≤–ª–µ–Ω–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `const`, –∞ –Ω–µ `var`. –≠—Ç–æ —Å–æ–∫—Ä–∞—â–∞–µ—Ç —Ä–∞–±–æ—Ç—É –∫–∞–∫
–¥–ª—è –ª—é–¥–µ–π —Ç–∞–∫ –∏ –¥–ª—è –∫–æ–º–ø—å—é—Ç–µ—Ä–æ–≤ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ –∫–æ–¥–∞ –∏ —Å–æ–∑–¥–∞–µ—Ç –±–æ–ª—å—à–µ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏.

–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `extern` –∏–ª–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `@extern` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è —Å–≤—è–∑—ã–≤–∞–Ω–∏—è —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π, —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º–æ–π
–∏–∑ –¥—Ä—É–≥–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞. –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `export` –∏–ª–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `@export` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è —Ç–æ–≥–æ, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å
–ø–µ—Ä–µ–º–µ–Ω–Ω—É—é –¥–æ—Å—Ç—É–ø–Ω–æ–π –¥–ª—è –¥—Ä—É–≥–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤ –≤–æ –≤—Ä–µ–º—è –ª–∏–Ω–∫–æ–≤–∫–∏. –í –æ–±–æ–∏—Ö —Å–ª—É—á–∞—è—Ö —Ç–∏–ø –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Å–æ–≤–º–µ—Å—Ç–∏–º —Å `C
ABI`.

#### –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã

–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ–ª–∂–Ω—ã –∑–∞—Ç–µ–Ω—è—Ç—å –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∏–∑ –≤–Ω–µ—à–Ω–µ–π –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.

–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –¥–æ–ª–∂–Ω—ã –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å –±—É–∫–≤–µ–Ω–Ω–æ–≥–æ —Å–∏–º–≤–æ–ª–∞ –∏–ª–∏ —Å–∏–º–≤–æ–ª–∞ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è –∏ –∑–∞ –Ω–∏–º–∏ –º–æ–∂–µ—Ç —Å–ª–µ–¥–æ–≤–∞—Ç—å –ª—é–±–æ–µ
–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±—É–∫–≤–µ–Ω–Ω–æ-—Ü–∏—Ñ—Ä–æ–≤—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –∏–ª–∏ –∑–Ω–∞–∫–æ–≤ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è. –û–Ω–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã –ø–µ—Ä–µ—Å–µ–∫–∞—Ç—å—Å—è —Å –∫–∞–∫–∏–º–∏-–ª–∏–±–æ –∫–ª—é—á–µ–≤—ã–º–∏
—Å–ª–æ–≤–∞–º–∏.

–ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –∏–º—è, –∫–æ—Ç–æ—Ä–æ–µ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —ç—Ç–∏–º —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º, –Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è —Å–≤—è–∑–∏ —Å –≤–Ω–µ—à–Ω–∏–º–∏ –±–∏–±–ª–∏–æ—Ç–µ–∫–∞–º–∏, –º–æ–∂–Ω–æ
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å `@""`.

```zig
const @"identifier with spaces in it" = 0xff;
const @"1SmallStep4Man" = 112358;

const c = @import("std").c;
pub extern "c" fn @"error"() void;
pub extern "c" fn @"fstat$INODE64"(fd: c.fd_t, buf: *c.Stat) c_int;

const Color = enum {
    red,
    @"really red",
};
const color: Color = .@"really red";
```

#### –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞

–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –∏–º–µ—é—Ç —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –≤—Ä–µ–º—è –∂–∏–∑–Ω–∏, –Ω–µ –∑–∞–≤–∏—Å—è—Ç –æ—Ç –ø–æ—Ä—è–¥–∫–∞ –∏ –ª–µ–Ω–∏–≤–æ –∞–Ω–∞–ª–∏–∑–∏—Ä—É—é—Ç—Å—è.
–ó–Ω–∞—á–µ–Ω–∏–µ–º –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –Ω–µ—è–≤–Ω–æ —è–≤–ª—è–µ—Ç—Å—è `comptime`. –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
—Ä–∞–≤–Ω–∞ `const`, —Ç–æ –µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –æ–Ω–æ –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.

```zig
var y: i32 = add(10, x);
const x: i32 = add(12, 34);

test "container level variables" {
    try expect(x == 46);
    try expect(y == 56);
}

fn add(a: i32, b: i32) i32 {
    return a + b;
}

const std = @import("std");
const expect = std.testing.expect;
```
```bash
$ zig test test_container_level_variables.zig
1/1 test_container_level_variables.test.container level variables...OK
All 1 tests passed.
```

–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω—ã –≤–Ω—É—Ç—Ä–∏ `struct`, `union`, `enum` –∏–ª–∏ `opaque`:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "namespaced container level variable" {
    try expect(foo() == 1235);
    try expect(foo() == 1236);
}

const S = struct {
    var x: i32 = 1234;
};

fn foo() i32 {
    S.x += 1;
    return S.x;
}
```
```bash
$ zig test test_namespaced_container_level_variable.zig
1/1 test_namespaced_container_level_variable.test.namespaced container level variable...OK
All 1 tests passed.
```

#### –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

–¢–∞–∫–∂–µ –≤–æ–∑–º–æ–∂–Ω–æ –∏–º–µ—Ç—å –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —Å–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–º –≤—Ä–µ–º–µ–Ω–µ–º –∂–∏–∑–Ω–∏, –∏—Å–ø–æ–ª—å–∑—É—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä—ã –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "static local variable" {
    try expect(foo() == 1235);
    try expect(foo() == 1236);
}

fn foo() i32 {
    const S = struct {
        var x: i32 = 1234;
    };
    S.x += 1;
    return S.x;
}
```
```bash
$ zig test test_static_local_variable.zig
1/1 test_static_local_variable.test.static local variable...OK
All 1 tests passed.
```

#### –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ—Ç–æ–∫–∞

–ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å —É–∫–∞–∑–∞–Ω–∞ –∫–∞–∫ –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –ø–æ—Ç–æ–∫–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ `threadlocal`, —á—Ç–æ
–ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–∞–∂–¥–æ–º—É –ø–æ—Ç–æ–∫—É —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:

```zig
const std = @import("std");
const assert = std.debug.assert;

threadlocal var x: i32 = 1234;

test "thread local storage" {
    const thread1 = try std.Thread.spawn(.{}, testTls, .{});
    const thread2 = try std.Thread.spawn(.{}, testTls, .{});
    testTls();
    thread1.join();
    thread2.join();
}

fn testTls() void {
    assert(x == 1234);
    x += 1;
    assert(x == 1235);
}
```
```bash
$ zig test test_thread_local_variables.zig
1/1 test_thread_local_variables.test.thread local storage...OK
All 1 tests passed.
```
–î–ª—è –æ–¥–Ω–æ–ø–æ—Ç–æ—á–Ω—ã—Ö —Å–±–æ—Ä–æ–∫ –≤—Å–µ –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ—Ç–æ–∫–∞ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –∫–∞–∫ –æ–±—ã—á–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω—è –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞.

–õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –ø–æ—Ç–æ–∫–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–µ `const`.

#### –õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ

–õ–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –≤—Å—Ç—Ä–µ—á–∞—é—Ç—Å—è –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–π, –±–ª–æ–∫–æ–≤ `comptime` –∏ –±–ª–æ–∫–æ–≤ `@cImport`.

–ï—Å–ª–∏ –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ `const`, —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –Ω–µ
–∏–∑–º–µ–Ω–∏—Ç—Å—è. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π `const` –∏–∑–≤–µ—Å—Ç–Ω–æ –≤ `comptime` –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ —Ç–æ —ç—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è —Ç–∞–∫–∂–µ
–∏–∑–≤–µ—Å—Ç–Ω–∞ –≤ `comptime` –∫–æ–Ω—Ç–µ–∫—Å—Ç–µ.

–õ–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –º–æ–∂–µ—Ç –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ —Å –ø–æ–º–æ—â—å—é –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ `comptime`. –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ç–æ–º—É, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ
–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –∏–∑–≤–µ—Å—Ç–Ω—ã–º –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏ –≤—Å–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –ø—Ä–æ–∏—Å—Ö–æ–¥—è—Ç –≤–æ –≤—Ä–µ–º—è
—Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞ –ø—Ä–æ–≥—Ä–∞–º–º—ã, –∞ –Ω–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –í—Å–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –æ–±—ä—è–≤–ª–µ–Ω–Ω—ã–µ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ `comptime` –Ω–µ—è–≤–Ω–æ
—è–≤–ª—è—é—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–º–∏ `comptime` –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "comptime vars" {
    var x: i32 = 1;
    comptime var y: i32 = 1;

    x += 1;
    y += 1;

    try expect(x == 2);
    try expect(y == 2);

    if (y != 2) {
        // –≠—Ç–∞ –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç, –ø–æ—Ç–æ–º—É —á—Ç–æ y - —ç—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏,
        // –∏ –ø–æ—ç—Ç–æ–º—É `y != 2` - —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∏ —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ if –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏.
        @compileError("wrong y value");
    }
}
```
```bash
$ zig test test_comptime_variables.zig
1/1 test_comptime_variables.test.comptime vars...OK
All 1 tests passed.
```

------------
### –¶–µ–ª—ã–µ —á–∏—Å–ª–∞

#### –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã

```zig
const decimal_int = 98222;
const hex_int = 0xff;
const another_hex_int = 0xFF;
const octal_int = 0o755;
const binary_int = 0b11110000;

// —Å–∏–º–≤–æ–ª—ã –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ–º–µ—â–µ–Ω—ã –º–µ–∂–¥—É –¥–≤—É–º—è —Ü–∏—Ñ—Ä–∞–º–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è
const one_billion = 1_000_000_000;
const binary_mask = 0b1_1111_1111;
const permissions = 0o7_5_5;
const big_address = 0xFF80_0000_0000_0000;
```

#### –¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã –Ω–µ –∏–º–µ—é—Ç –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –ø–æ —Ä–∞–∑–º–µ—Ä—É –∏ –µ—Å–ª–∏ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –∫–∞–∫–æ–µ-–ª–∏–±–æ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ, –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä
–ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –µ–≥–æ.

–û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –±–æ–ª—å—à–µ –∏ –Ω–µ –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ —Ç–æ –æ–Ω–æ –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä –∏
—É—è–∑–≤–∏–º–æ –¥–ª—è –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è.

```zig
fn divide(a: i32, b: i32) i32 {
    return a / b;
}
```

–í —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è `a` –∏ `b` –∏–∑–≤–µ—Å—Ç–Ω—ã —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º —ç—Ç–∞ –æ–ø–µ—Ä–∞—Ü–∏—è –¥–µ–ª–µ–Ω–∏—è —É—è–∑–≤–∏–º–∞ –¥–ª—è
–æ–±–æ–∏—Ö –æ—à–∏–±–æ–∫ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞ –∏ –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å.

–¢–∞–∫–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –∫–∞–∫ `+` –∏ `-` –≤—ã–∑—ã–≤–∞—é—Ç –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –ø—Ä–∏ –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–∏ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª. –ü—Ä–µ–¥—É—Å–º–æ—Ç—Ä–µ–Ω—ã
–∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞ –∏ –Ω–∞—Å—ã—â–µ–Ω–∏—è –∞—Ä–∏—Ñ–º–µ—Ç–∏—á–µ—Å–∫–∏—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ –≤—Å–µ–º —Ü–µ–ª–µ–≤—ã–º –æ–±—ä–µ–∫—Ç–∞–º. `+%` –∏ `-%` –≤—ã–ø–æ–ª–Ω—è—é—Ç
–∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É –ø–µ—Ä–µ–Ω–æ—Å–∞, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ `+|` –∏ `-|` –≤—ã–ø–æ–ª–Ω—è—é—Ç –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É –Ω–∞—Å—ã—â–µ–Ω–∏—è.

**Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç–∏, –¥–ª—è –æ–±–æ–∑–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã—Ö –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä `i` –∏–ª–∏
`u`, –∑–∞ –∫–æ—Ç–æ—Ä—ã–º —Å–ª–µ–¥—É—é—Ç —Ü–∏—Ñ—Ä—ã. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä `i7` –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ 7-—Ä–∞–∑—Ä—è–¥–Ω–æ–º—É —Ü–µ–ª–æ–º—É —á–∏—Å–ª—É —Å–æ –∑–Ω–∞–∫–æ–º. –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ
–¥–æ–ø—É—Å—Ç–∏–º–∞—è —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç—å —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞ —Ä–∞–≤–Ω–∞ `65535`. –î–ª—è —Ü–µ–ª—ã—Ö —Ç–∏–ø–æ–≤ —Å–æ –∑–Ω–∞–∫–æ–º **Zig** –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
–¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –¥–æ –¥–≤—É—Ö.

### –ß–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π

**Zig** –∏–º–µ–µ—Ç —Å–ª–µ–¥—É—é—â–∏–µ —Ç–∏–ø—ã —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π:
- <span style="color:blue">`f16`</span> - IEEE-754-2008 binary16
- <span style="color:blue">`f32`</span> - IEEE-754-2008 binary32
- <span style="color:blue">`f64`</span> - IEEE-754-2008 binary64
- <span style="color:blue">`f80`</span>- IEEE-754-2008 80-bit extended precision
- <span style="color:blue">`f128`</span> - IEEE-754-2008 binary128
- <span style="color:blue">`c_longdouble`</span> - matches `long double` for the target C ABI

#### –õ–∏—Ç–µ—Ä–∞–ª—ã —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π

–õ–∏—Ç–µ—Ä–∞–ª—ã —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –∏–º–µ—é—Ç —Ç–∏–ø `comptime_float`, –∫–æ—Ç–æ—Ä—ã–π –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –∏–º–µ–µ—Ç —Ç—É –∂–µ —Ç–æ—á–Ω–æ—Å—Ç—å –∏ –æ–ø–µ—Ä–∞—Ü–∏–∏, —á—Ç–æ –∏
–¥—Ä—É–≥–æ–π —Å–∞–º—ã–π –±–æ–ª—å—à–æ–π —Ç–∏–ø —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è f128.

–õ–∏—Ç–µ—Ä–∞–ª—ã —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –ø—Ä–∏–≤–æ–¥—è—Ç—Å—è –∫ –ª—é–±–æ–º—É —Ç–∏–ø—É —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –∏ –∫ –ª—é–±–æ–º—É —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–º—É —Ç–∏–ø—É, –µ—Å–ª–∏ –≤ –Ω–µ–º –Ω–µ—Ç
–¥—Ä–æ–±–Ω–æ–π —Å–æ—Å—Ç–∞–≤–ª—è—é—â–µ–π.

```zig
const floating_point = 123.0E+77;
const another_float = 123.0;
const yet_another = 123.0e+77;

const hex_floating_point = 0x103.70p-5;
const another_hex_float = 0x103.70;
const yet_another_hex_float = 0x103.70P-5;

// —Å–∏–º–≤–æ–ª—ã –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ–º–µ—â–µ–Ω—ã –º–µ–∂–¥—É –¥–≤—É–º—è —Ü–∏—Ñ—Ä–∞–º–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è
const lightspeed = 299_792_458.000_000;
const nanosecond = 0.000_000_001;
const more_hex = 0x1234_5678.9ABC_CDEFp-10;
```

–ù–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏–π NaN, infinity –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–π –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏. –î–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —ç—Ç–∏—Ö —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö
–∑–Ω–∞—á–µ–Ω–∏–π –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—É—é –±–∏–±–ª–∏–æ—Ç–µ–∫—É:
```zig
const std = @import("std");

const inf = std.math.inf(f32);
const negative_inf = -std.math.inf(f64);
const nan = std.math.nan(f128);
```

#### –û–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π

–ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–π —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—Ç—Ä–æ–≥–∏–π —Ä–µ–∂–∏–º, –Ω–æ –≤—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π
—Ä–µ–∂–∏–º –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–ª–æ–∫–∞:
```zig
const std = @import("std");
const big = @as(f64, 1 << 40);

export fn foo_strict(x: f64) f64 {
    return x + big - big;
}

export fn foo_optimized(x: f64) f64 {
    @setFloatMode(.optimized);
    return x + big - big;
}
```
```bash
$ zig build-obj float_mode_obj.zig -O ReleaseFast
```

–î–ª—è —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞ –º—ã –¥–æ–ª–∂–Ω—ã —Ä–∞–∑–¥–µ–ª–∏—Ç—å –∫–æ–¥ –Ω–∞ –¥–≤–∞ –æ–±—ä–µ–∫—Ç–Ω—ã—Ö —Ñ–∞–π–ª–∞ - –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –≤—ã—á–∏—Å–ª—è–µ—Ç –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è
–≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Å—Ç—Ä–æ–≥–æ–º —Ä–µ–∂–∏–º–µ.
```zig
const print = @import("std").debug.print;

extern fn foo_strict(x: f64) f64;
extern fn foo_optimized(x: f64) f64;

pub fn main() void {
    const x = 0.001;
    print("optimized = {}\n", .{foo_optimized(x)});
    print("strict = {}\n", .{foo_strict(x)});
}
```

------------
### –û–ø–µ—Ä–∞—Ç–æ—Ä—ã

–ü–µ—Ä–µ–≥—Ä—É–∑–∫–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ –Ω–µ—Ç. –ö–æ–≥–¥–∞ –≤—ã –≤–∏–¥–∏—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä –≤ **Zig**, –≤—ã –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –æ–Ω –≤—ã–ø–æ–ª–Ω—è–µ—Ç —á—Ç–æ-—Ç–æ –∏–∑ —ç—Ç–æ–π —Ç–∞–±–ª–∏—Ü—ã –∏
–Ω–∏—á–µ–≥–æ –±–æ–ª—å—à–µ.

**<center>Table of Operators</center>**

|Name|Syntax|Types|Remarks|Example|
|----|:------:|-----|-------|-------|
|Addition|`a + b`<br>`a += b`|Integers <br>Floats|Can cause overflow for integers. <br>Invokes Peer Type Resolution for the operands.<br>See also `@addWithOverflow`.| `1 + 5 == 7`
|Wrapping<br>Addition|`a +% b`<br>`a +%= b`|Integers|Twos-complement wrapping behavior.<br>Invokes Peer Type Resolution for the operands.<br>See also `@addWithOverflow`.|`@as(u32, 0xffffffff) +% 1 == 0`
|Saturating<br>Addition|`a +\| b`<br>`a +\|= b`|Integers|Invokes Peer Type Resolution for the operands.|`@as(u8, 255) +\| 1 == @as(u8, 255)`
|Subtraction|`a - b`<br>`a -= b`|Integers<br>Floats|Can cause overflow for integers.<br>Invokes Peer Type Resolution for the operands.<br>See also `@subWithOverflow`.|`2 - 5 == -3`
|Wrapping<br>Subtraction|`a -% b`<br>`a -%= b`|Integers|Twos-complement wrapping behavior.<br>Invokes Peer Type Resolution for the operands.<br>See also `@subWithOverflow`.|`@as(u8, 0) -% 1 == 255`
|Saturating<br>Subtraction|`a -\| b`<br>`a -\|= b`|Integers|Invokes Peer Type Resolution for the operands.|`@as(u32, 0) -\| 1 == 0`
|Negation|`-a`|Integers<br>Floats|Can cause overflow for integers.|`-1 == 0 - 1`
|Wrapping<br>Negation|`-%a`|Integers|Twos-complement wrapping behavior.|`-%@as(i8, -128) == -128`
|Multiplication|`a * b`<br>`a *= b`|Integers<br>Floats|Can cause overflow for integers.<br>Invokes Peer Type Resolution for the operands.<br>See also `@mulWithOverflow`.|`2 * 5 == 10`
|Wrapping<br>Multiplication|`a *% b`<br>`a *%= b`|Integers|Twos-complement wrapping behavior.<br>Invokes Peer Type Resolution for the operands.<br>See also `@mulWithOverflow`.|`@as(u8, 200) *% 2 == 144`
|Saturating<br>Multiplication|`a *\| b`<br>`a *\|= b`|Integers|Invokes Peer Type Resolution for the operands.|`@as(u8, 200) *\| 2 == 255`
|Division|`a / b`<br>`a /= b`|Integers<br>Floats|Can cause overflow for integers.<br>Can cause Division by Zero for integers.<br>Can cause Division by Zero for floats in FloatMode.Optimized Mode.<br>Signed integer operands must be comptime-known and positive. In other cases, use `@divTrunc`, `@divFloor`, or `@divExact` instead.<br>Invokes Peer Type Resolution for the operands.|`10 / 2 == 5`
|Remainder<br>Division|`a % b`<br>`a %= b`|Integers<br>Floats|Can cause Division by Zero for integers.<br>Can cause Division by Zero for floats in FloatMode.Optimized Mode.<br>Signed or floating-point operands must be comptime-known and positive. In other cases, use @rem or `@mod` instead.<br>Invokes Peer Type Resolution for the operands.|`10 % 3 == 1`
|Bit Shift Left|`a << b`<br>`a <<= b`|Integers|Moves all bits to the left, inserting new zeroes at the least-significant bit.<br>`b` must be comptime-known or have a type with log2 number of bits as `a`.<br>See also `@shlExact`.<br>See also `@shlWithOverflow`.|`0b1 << 8 == 0b100000000`
|Saturating Bit Shift Left|`a <<\| b`<br>`a <<\|= b`|Integers|See also `@shlExact`.<br>See also `@shlWithOverflow`.|`@as(u8,1) <<\| 8 == 255`
|Bit Shift Right|`a >> b`<br>`a >>= b`|Integers|Moves all bits to the right, inserting zeroes at the most-significant bit.<br>`b` must be comptime-known or have a type with log2 number of bits as `a`.<br>See also `@shrExact`.|`0b1010 >> 1 == 0b101`
|Bitwise And|`a & b`<br>`a &= b`|Integers|Invokes Peer Type Resolution for the operands.|`0b011 & 0b101 == 0b001`
|Bitwise Or|`a \| b`<br>`a \|= b`|Integers|Invokes Peer Type Resolution for the operands.|`0b010 \| 0b100 == 0b110`
|Bitwise Xor|`a ^ b`<br>`a ^= b`|Integers|Invokes Peer Type Resolution for the operands.|`0b011 ^ 0b101 == 0b110`
|Bitwise Not|`~a`|Integers||`~@as(u8, 0b10101111) == 0b01010000`
|Defaulting<br>Optional<br>Unwrap|`a orelse b`|Optionals|If `a` is `null`, returns `b` ("default value"), otherwise returns the unwrapped value of `a`. Note that `b` may be a value of type `noreturn`.|`const value: ?u32 = null;`<br>`const unwrapped = value orelse 1234;`<br>`unwrapped == 1234`
|Optional<br>Unwrap|`a.?`|Optionals|Equivalent to: `a orelse unreachable`|`const value: ?u32 = 5678;`<br>`value.? == 5678`
|Defaulting<br>Error Unwrap|`a catch b`<br>`a catch \|err\| b`|Error<br>Unions|If `a` is an `error`, returns `b` ("default value"), otherwise returns the unwrapped value of `a`. Note that `b` may be a value of type `noreturn`. `err` is the `error` and is in scope of the expression `b`.|`const value: anyerror!u32 = error.Broken;`<br>`const unwrapped = value catch 1234;`<br>`unwrapped == 1234`
|Logical And|`a and b`|bool|If `a` is `false`, returns `false` without evaluating `b`. Otherwise, returns `b`.|`(false and true) == false`
|Logical Or|`a or b`|bool|If `a` is `true`, returns `true` without evaluating `b`. Otherwise, returns `b`.|`(false or true) == true`
|Boolean Not|`!a`|bool||`!false == true`
|Equality|`a == b`|Integers<br>Floats<br>bool<br>type|Returns `true` if `a` and `b` are equal, otherwise returns `false`.<br>Invokes Peer Type Resolution for the operands.|`(1 == 1) == true`
|Null Check|`a == null`|Optionals|Returns `true` if `a` is `null`, otherwise returns `false.`|`const value: ?u32 =null;`<br>`(value == null) == true`
|Inequality|`a != b`|Integers<br>Floats<br>bool<br>type|Returns `false` if `a` and `b` are unequal, otherwise returns `true`.<br>Invokes Peer Type Resolution for the operands.|`(1 != 1) == false`
|Non-Null Check|`a != null`|Optionals|Returns `false` if `a` is `null`, otherwise returns `true.`|`const value: ?u32 = 5;`<br>`(value != null) == true`
|Greater Than|`a > b`|Integers<br>Floats|Returns `true` if `a` is greater than `b`, otherwise returns `false`.<br>Invokes Peer Type Resolution for the operands.|`(2 > 1) == true`
|Greater or Equal|`a >= b`|Integers<br>Floats|Returns `true` if `a` is greater than `b` or equal, otherwise returns `false`.<br>Invokes Peer Type Resolution for the operands.|`(2 >= 1) == true`
|Less Than|`a < b`|Integers<br>Floats|Returns `true` if `a` is less than `b`, otherwise returns `false`.<br>Invokes Peer Type Resolution for the operands.|`(1 < 2) == true`
|Lesser or Equal|`a <= b`|Integers<br>Floats|Returns `true` if `a` is less than `b` or equal, otherwise returns `false`.<br>Invokes Peer Type Resolution for the operands.|`(1 <= 2) == true`
|Array Concatenation|`a ++ b`|Arrays|Only available when the lengths of both `a` and `b` are compile-time known.|`const mem = @import("std").mem;`<br>`const array1 = [_]u32{1,2};`<br>`const array2 = [_]u32{3,4};`<br>`const together = array1 ++ array2;`<br>`mem.eql(u32, &together, &[_]u32{1,2,3,4})`
|Array Multiplication|`a ** b`|Arrays|Only available when the length of `a` and `b` are compile-time known.|`const mem = @import("std").mem;`<br>`const pattern = "ab" ** 3;`<br>`mem.eql(u8, pattern, "ababab")`
|Pointer Dereference|`a.*`|Pointers|Pointer dereference.|`const x: u32 = 1234;`<br>`const ptr = &x;`<br>`ptr.* == 1234`
|Address Of|`&a`|All types||`const x: u32 = 1234;`<br>`const ptr = &x;`<br>`ptr.* = 1234`
|Error Set Merge|`a \|\| b`|Error Set Type| Merging Error Set|`const A = error{One};`<br>`const B = error{Two};`<br>`(A \|\| B) == error{One,Two}`

#### –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç—ã –æ–ø–µ—Ä–∞—Ü–∏–π
```zig
x() x[] x.y x.* x.?
a!b
x{}
!x -x -%x ~x &x ?x
* / % ** *% *| ||
+ - ++ +% -% +| -|
<< >> <<|
& ^ | orelse catch
== != < > <= >=
and
or
= *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=
```
------------
### –ú–∞—Å—Å–∏–≤—ã
```zig
const expect = @import("std").testing.expect;
const assert = @import("std").debug.assert;
const mem = @import("std").mem;

// –º–∞—Å—Å–∏–≤ –ª–∏—Ç–µ—Ä–∞–ª–æ–≤
const message = [_]u8{ 'h', 'e', 'l', 'l', 'o' };

// –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å —É–∫–∞–∑–∞–Ω–∏–µ–º —Ä–∞–∑–º–µ—Ä–∞ –º–∞—Å—Å–∏–≤–∞
const alt_message: [5]u8 = .{ 'h', 'e', 'l', 'l', 'o' };

comptime {
    assert(mem.eql(u8, &message, &alt_message));
}

// –ø–æ–ª—É—á–∏—Ç—å —Ä–∞–∑–º–µ—Ä –º–∞—Å—Å–∏–≤–∞
comptime {
    assert(message.len == 5);
}

// –°—Ç—Ä–æ–∫–æ–≤—ã–π –ª–∏—Ç–µ—Ä–∞–ª - —ç—Ç–æ –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Å—Å–∏–≤.
const same_message = "hello";

comptime {
    assert(mem.eql(u8, &message, same_message));
}

test "iterate over an array" {
    var sum: usize = 0;
    for (message) |byte| {
        sum += byte;
    }
    try expect(sum == 'h' + 'e' + 'l' * 2 + 'o');
}

// –∏–∑–º–µ–Ω—è–µ–º—ã–π –º–∞—Å—Å–∏–≤
var some_integers: [100]i32 = undefined;

test "modify an array" {
    for (&some_integers, 0..) |*item, i| {
        item.* = @intCast(i);
    }
    try expect(some_integers[10] == 10);
    try expect(some_integers[99] == 99);
}

// –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –º–∞—Å—Å–∏–≤–æ–≤ —Ä–∞–±–æ—Ç–∞–µ—Ç, –µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑–≤–µ—Å—Ç–Ω—ã
// –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
const part_one = [_]i32{ 1, 2, 3, 4 };
const part_two = [_]i32{ 5, 6, 7, 8 };
const all_of_it = part_one ++ part_two;
comptime {
    assert(mem.eql(i32, &all_of_it, &[_]i32{ 1, 2, 3, 4, 5, 6, 7, 8 }));
}

// –ø–æ–º–Ω–∏—Ç–µ, —á—Ç–æ —Å—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã - —ç—Ç–æ –º–∞—Å—Å–∏–≤—ã
const hello = "hello";
const world = "world";
const hello_world = hello ++ " " ++ world;
comptime {
    assert(mem.eql(u8, hello_world, "hello world"));
}

// ** –≤—ã–ø–æ–ª–Ω—è–µ—Ç –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–µ—Å—è –¥–µ–π—Å—Ç–≤–∏—è
const pattern = "ab" ** 3;
comptime {
    assert(mem.eql(u8, pattern, "ababab"));
}

// –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –º–∞—Å—Å–∏–≤ —Ä–∞–≤–Ω—ã–º –Ω—É–ª—é
const all_zero = [_]u16{0} ** 10;

comptime {
    assert(all_zero.len == 10);
    assert(all_zero[5] == 0);
}

// –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–¥ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∞—Å—Å–∏–≤–∞
var fancy_array = init: {
    var initial_value: [10]Point = undefined;
    for (&initial_value, 0..) |*pt, i| {
        pt.* = Point{
            .x = @intCast(i),
            .y = @intCast(i * 2),
        };
    }
    break :init initial_value;
};
const Point = struct {
    x: i32,
    y: i32,
};

test "compile-time array initialization" {
    try expect(fancy_array[4].x == 4);
    try expect(fancy_array[4].y == 8);
}

// –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –º–∞—Å—Å–∏–≤–∞
var more_points = [_]Point{makePoint(3)} ** 10;
fn makePoint(x: i32) Point {
    return Point{
        .x = x,
        .y = x * 2,
    };
}
test "array initialization with function calls" {
    try expect(more_points[4].x == 3);
    try expect(more_points[4].y == 6);
    try expect(more_points.len == 10);
}
```
```bash
$ zig test test_arrays.zig
1/4 test_arrays.test.iterate over an array...OK
2/4 test_arrays.test.modify an array...OK
3/4 test_arrays.test.compile-time array initialization...OK
4/4 test_arrays.test.array initialization with function calls...OK
All 4 tests passed.
```

#### –ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã

–ú–Ω–æ–≥–æ–º–µ—Ä–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω—ã –ø—É—Ç–µ–º –≤–ª–æ–∂–µ–Ω–∏—è –º–∞—Å—Å–∏–≤–æ–≤ –æ–¥–Ω–æ–≥–æ –≤ –¥—Ä—É–≥–æ–π:
```zig
const std = @import("std");
const expect = std.testing.expect;

const mat4x4 = [4][4]f32{
    [_]f32{ 1.0, 0.0, 0.0, 0.0 },
    [_]f32{ 0.0, 1.0, 0.0, 1.0 },
    [_]f32{ 0.0, 0.0, 1.0, 0.0 },
    [_]f32{ 0.0, 0.0, 0.0, 1.0 },
};
test "multidimensional arrays" {
    // –ü–æ–ª—É—á–∏—Ç–µ –¥–æ—Å—Ç—É–ø –∫ –¥–≤—É–º–µ—Ä–Ω–æ–º—É –º–∞—Å—Å–∏–≤—É, –ø—Ä–æ–∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–≤ –≤–Ω–µ—à–Ω–∏–π –º–∞—Å—Å–∏–≤, –∞ –∑–∞—Ç–µ–º –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –º–∞—Å—Å–∏–≤.
    try expect(mat4x4[1][1] == 1.0);

    // –ó–¥–µ—Å—å –º—ã –≤—ã–ø–æ–ª–Ω—è–µ–º –∏—Ç–µ—Ä–∞—Ü–∏—é —Å –ø–æ–º–æ—â—å—é —Ü–∏–∫–ª–æ–≤ for.
    for (mat4x4, 0..) |row, row_index| {
        for (row, 0..) |cell, column_index| {
            if (row_index == column_index) {
                try expect(cell == 1.0);
            }
        }
    }
}
```
```bash
$ zig test test_multidimensional_arrays.zig
1/1 test_multidimensional_arrays.test.multidimensional arrays...OK
All 1 tests passed.
```

#### –ù—É–ª—å —Ç–µ—Ä–º–µ–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã

–°–∏–Ω—Ç–∞–∫—Å–∏—Å `[N:x]T` –æ–ø–∏—Å—ã–≤–∞–µ—Ç –º–∞—Å—Å–∏–≤, –∫–æ—Ç–æ—Ä—ã–π –∏–º–µ–µ—Ç –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–æ –∑–Ω–∞—á–µ–Ω–∏–µ–º `x` —Å –∏–Ω–¥–µ–∫—Å–æ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º
–¥–ª–∏–Ω–µ `N`.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "0-terminated sentinel array" {
    const array = [_:0]u8{ 1, 2, 3, 4 };

    try expect(@TypeOf(array) == [4:0]u8);
    try expect(array.len == 4);
    try expect(array[4] == 0);
}

test "extra 0s in 0-terminated sentinel array" {
    // –ö–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –ø–æ—è–≤–∏—Ç—å—Å—è —Ä–∞–Ω—å—à–µ, –Ω–æ –æ–Ω–æ –Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ 'len'.
    const array = [_:0]u8{ 1, 0, 0, 4 };

    try expect(@TypeOf(array) == [4:0]u8);
    try expect(array.len == 4);
    try expect(array[4] == 0);
}
```
```bash
$ zig test test_null_terminated_array.zig
1/2 test_null_terminated_array.test.0-terminated sentinel array...OK
2/2 test_null_terminated_array.test.extra 0s in 0-terminated sentinel array...OK
All 2 tests passed.
```
------------
### –í–µ–∫—Ç–æ—Ä—ã

–í–µ–∫—Ç–æ—Ä - —ç—Ç–æ –≥—Ä—É–ø–ø–∞ –ª–æ–≥–∏—á–µ—Å–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏–π, —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª, —á–∏—Å–µ–ª —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π –∏–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –∫–æ—Ç–æ—Ä—ã–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è
–ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ, –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∏—Å–ø–æ–ª—å–∑—É—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ SIMD. –¢–∏–ø—ã –≤–µ–∫—Ç–æ—Ä–æ–≤ —Å–æ–∑–¥–∞—é—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ `@Vector`.

–í–µ–∫—Ç–æ—Ä—ã –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç —Ç–µ –∂–µ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã, —á—Ç–æ –∏ –∏—Ö –±–∞–∑–æ–≤—ã–µ —Ç–∏–ø—ã. –≠—Ç–∏ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –ø–æ—ç–ª–µ–º–µ–Ω—Ç–Ω–æ –∏
–≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –≤–µ–∫—Ç–æ—Ä —Ç–æ–π –∂–µ –¥–ª–∏–Ω—ã, —á—Ç–æ –∏ –≤—Ö–æ–¥–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã. –≠—Ç–æ –≤–∫–ª—é—á–∞–µ—Ç:
- Arithmetic (`+`, `-`, `/`, `*`, `@divFloor`, `@sqrt`, `@ceil`, `@log`, etc.)
- Bitwise operators (`>>`, `<<`, `&`, `|`, `~`, etc.)
- Comparison operators (`<`, `>`, `==`, etc.)

–ó–∞–ø—Ä–µ—â–µ–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–ª—è —Å–æ—á–µ—Ç–∞–Ω–∏—è —Å–∫–∞–ª—è—Ä–æ–≤ (–æ—Ç–¥–µ–ª—å–Ω—ã—Ö —á–∏—Å–µ–ª) –∏ –≤–µ–∫—Ç–æ—Ä–æ–≤. Zig –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç
–≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é `@splat` –¥–ª—è –ø—Ä–æ—Å—Ç–æ–≥–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å–∫–∞–ª—è—Ä–æ–≤ –≤ –≤–µ–∫—Ç–æ—Ä—ã, –∞ —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å `@reduce` –∏
–∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏ –º–∞—Å—Å–∏–≤–∞ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–æ–≤ –≤ —Å–∫–∞–ª—è—Ä—ã. –í–µ–∫—Ç–æ—Ä—ã —Ç–∞–∫–∂–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ –º–∞—Å—Å–∏–≤–∞–º —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π
–¥–ª–∏–Ω—ã –∏ –∏–∑ –Ω–∏—Ö —Å –∏–∑–≤–µ—Å—Ç–Ω–æ–π –≤–æ –≤—Ä–µ–º—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –¥–ª–∏–Ω–æ–π.

–î–ª—è –ø–µ—Ä–µ—Å—Ç–∞–Ω–æ–≤–∫–∏ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –≤–Ω—É—Ç—Ä–∏ –≤–µ–∫—Ç–æ—Ä–æ–≤ –∏ –º–µ–∂–¥—É –Ω–∏–º–∏ **Zig** –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ `@shuffle` –∏ `@select`.

–û–ø–µ—Ä–∞—Ü–∏–∏ —Å –≤–µ–∫—Ç–æ—Ä–∞–º–∏ –¥–ª–∏–Ω–∞ –∫–æ—Ç–æ—Ä—ã—Ö –º–µ–Ω—å—à–µ —á–µ–º –∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä SIMD —Ü–µ–ª–µ–≤–æ–π –º–∞—à–∏–Ω—ã –æ–±—ã—á–Ω–æ –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤ –æ–¥–Ω—É
SIMD-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ –≤–µ–∫—Ç–æ—Ä—ã –¥–ª–∏–Ω–∞ –∫–æ—Ç–æ—Ä—ã—Ö –ø—Ä–µ–≤—ã—à–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π —Ä–∞–∑–º–µ—Ä SIMD —Ü–µ–ª–µ–≤–æ–π –º–∞—à–∏–Ω—ã –∫–æ–º–ø–∏–ª–∏—Ä—É—é—Ç—Å—è –≤
–Ω–µ—Å–∫–æ–ª—å–∫–æ SIMD-–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π. –ï—Å–ª–∏ –¥–∞–Ω–Ω–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç SIMD –≤ —Ü–µ–ª–µ–≤–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
–±—É–¥–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –∫–∞–∂–¥—ã–º –≤–µ–∫—Ç–æ—Ä–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º –ø–æ –æ—á–µ—Ä–µ–¥–∏. **Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –ª—é–±—É—é –∏–∑–≤–µ—Å—Ç–Ω—É—é –≤–æ –≤—Ä–µ–º—è –≤—ã—á–∏—Å–ª–µ–Ω–∏–π –¥–ª–∏–Ω—É
–≤–µ–∫—Ç–æ—Ä–∞ –≤–ø–ª–æ—Ç—å –¥–æ 2^32-1, —Ö–æ—Ç—è –Ω–∞–∏–±–æ–ª–µ–µ —Ç–∏–ø–∏—á–Ω—ã–º–∏ —è–≤–ª—è—é—Ç—Å—è –º–∞–ª—ã–µ —Å—Ç–µ–ø–µ–Ω–∏ –¥–≤–æ–π–∫–∏ (2-64). –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ
—á—Ä–µ–∑–º–µ—Ä–Ω–æ –±–æ–ª—å—à–∏–µ –¥–ª–∏–Ω—ã –≤–µ–∫—Ç–æ—Ä–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä, 2^20) –º–æ–≥—É—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ —Å–±–æ—è–º –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ –≤ —Ç–µ–∫—É—â–∏—Ö –≤–µ—Ä—Å–∏—è—Ö **Zig**.

```zig
const std = @import("std");
const expectEqual = std.testing.expectEqual;

test "Basic vector usage" {
    // –í–µ–∫—Ç–æ—Ä—ã –∏–º–µ—é—Ç –∏–∑–≤–µ—Å—Ç–Ω—É—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª–∏–Ω—É –∏ –±–∞–∑–æ–≤—ã–π —Ç–∏–ø.
    const a = @Vector(4, i32){ 1, 2, 3, 4 };
    const b = @Vector(4, i32){ 5, 6, 7, 8 };

    // –ú–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –ø–æ—ç—Ç–∞–ø–Ω–æ.
    const c = a + b;

    // –î–æ—Å—Ç—É–ø –∫ –æ—Ç–¥–µ–ª—å–Ω—ã–º –≤–µ–∫—Ç–æ—Ä–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–∞–º –º–æ–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏ –º–∞—Å—Å–∏–≤–∞.
    try expectEqual(6, c[0]);
    try expectEqual(8, c[1]);
    try expectEqual(10, c[2]);
    try expectEqual(12, c[3]);
}

test "Conversion between vectors, arrays, and slices" {
    // –í–µ–∫—Ç–æ—Ä—ã –∏ –º–∞—Å—Å–∏–≤—ã —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–π –¥–ª–∏–Ω—ã –º–æ–≥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–∑–Ω–∞—á–∞—Ç—å—Å—è —Ç—É–¥–∞ –∏ –æ–±—Ä–∞—Ç–Ω–æ
    const arr1: [4]f32 = [_]f32{ 1.1, 3.2, 4.5, 5.6 };
    const vec: @Vector(4, f32) = arr1;
    const arr2: [4]f32 = vec;
    try expectEqual(arr1, arr2);

    // –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –ø—Ä–∏—Å–≤–æ–∏—Ç—å –≤–µ–∫—Ç–æ—Ä—É —Å—Ä–µ–∑ —Å –∏–∑–≤–µ—Å—Ç–Ω–æ–π –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª–∏–Ω–æ–π –∏—Å–ø–æ–ª—å–∑—É—è .*
    const vec2: @Vector(2, f32) = arr1[1..3].*;

    const slice: []const f32 = &arr1;
    var offset: u32 = 1; // var, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å –µ–≥–æ –∏–∑–≤–µ—Å—Ç–Ω—ã–º –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    _ = &offset; // –ø–æ–¥–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É "var –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –º—É—Ç–∏—Ä—É–µ—Ç"
    // –ß—Ç–æ–±—ã –∏–∑–≤–ª–µ—á—å –∏–∑–≤–µ—Å—Ç–Ω—É—é –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –¥–ª–∏–Ω—É –∏–∑ –∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å–º–µ—â–µ–Ω–∏—è,
    // —Å–Ω–∞—á–∞–ª–∞ –∏–∑–≤–ª–µ–∫–∏—Ç–µ –Ω–æ–≤—ã–π —Ñ—Ä–∞–≥–º–µ–Ω—Ç –∏–∑ –Ω–∞—á–∞–ª—å–Ω–æ–≥–æ —Å–º–µ—â–µ–Ω–∏—è, –∞ –∑–∞—Ç–µ–º –º–∞—Å—Å–∏–≤
    // –∏–∑–≤–µ—Å—Ç–Ω–æ–π –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª–∏–Ω—ã
    const vec3: @Vector(2, f32) = slice[offset..][0..2].*;
    try expectEqual(slice[offset], vec2[0]);
    try expectEqual(slice[offset + 1], vec2[1]);
    try expectEqual(vec2, vec3);
}
```
```bash
$ zig test test_vector.zig
1/2 test_vector.test.Basic vector usage...OK
2/2 test_vector.test.Conversion between vectors, arrays, and slices...OK
All 2 tests passed.
```

TODO talk about C ABI interop<br>
TODO consider suggesting std.MultiArrayList

------------
### –£–∫–∞–∑–∞—Ç–µ–ª–∏

–í **Zig** –µ—Å—Ç—å –¥–≤–∞ –≤–∏–¥–∞ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π: –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ –∏ –º–Ω–æ–≥–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ:

- `*T` - –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å —Ä–æ–≤–Ω–æ –Ω–∞ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç.
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è: `ptr.*`
- `[*]T` - –º–Ω–æ–≥–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏–Ω–¥–µ–∫—Å–∞—Ü–∏–∏—è: `ptr[i]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ä–µ–∑–æ–≤: `ptr[start..end]` and `ptr[start..]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É —É–∫–∞–∑–∞—Ç–µ–ª–µ–π: `ptr + x`, `ptr - x`
    - `T` –¥–æ–ª–∂–µ–Ω –∏–º–µ—Ç—å –∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä, —á—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–Ω –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω—ã–º –∏–ª–∏ –∫–∞–∫–∏–º-–ª–∏–±–æ –¥—Ä—É–≥–∏–º
    –Ω–µ–ø—Ä–æ–∑—Ä–∞—á–Ω—ã–º —Ç–∏–ø–æ–º.

–≠—Ç–∏ —Ç–∏–ø—ã —Ç–µ—Å–Ω–æ —Å–≤—è–∑–∞–Ω—ã —Å –º–∞—Å—Å–∏–≤–∞–º–∏ –∏ —Å—Ä–µ–∑–∞–º–∏:
- `*[N]T` - —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ N —ç–ª–µ–º–µ–Ω—Ç–æ–≤, —Ç–∞–∫–æ–π –∂–µ –∫–∞–∫ –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Å—Å–∏–≤.
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏–Ω–¥–µ–∫—Å–∞: `array_ptr[i]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ä–µ–∑–æ–≤: `array_ptr[start..end]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ –¥–ª–∏–Ω—ã: `array_ptr.len`

- `[]T` - —ç—Ç–æ —Å—Ä–µ–∑ (—Ç–æ–ª—Å—Ç—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å —Ç–∏–ø–∞ `[*]T` –∏ –¥–ª–∏–Ω—É).
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∏–Ω–¥–µ–∫—Å–∞: `slice[i]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ä–µ–∑–æ–≤: `slice[start..end]`
    - –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Å–≤–æ–π—Å—Ç–≤–æ –¥–ª–∏–Ω—ã: `slice.len`

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `&x` –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–∞ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç:

```zig
const expect = @import("std").testing.expect;

test "address of syntax" {
    // –ü–æ–ª—É—á–∏—Ç—å –∞–¥—Ä–µ—Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:
    const x: i32 = 1234;
    const x_ptr = &x;

    // –†–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è:
    try expect(x_ptr.* == 1234);

    // –ö–æ–≥–¥–∞ –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –∞–¥—Ä–µ—Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π const, –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç const.
    try expect(@TypeOf(x_ptr) == *const i32);

    // –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –∏–∑–º–µ–Ω–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ, –≤–∞–º –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è –∞–¥—Ä–µ—Å –∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:
    var y: i32 = 5678;
    const y_ptr = &y;
    try expect(@TypeOf(y_ptr) == *i32);
    y_ptr.* += 1;
    try expect(y_ptr.* == 5679);
}

test "pointer array access" {
    // –ï—Å–ª–∏ –≤–∑—è—Ç—å –∞–¥—Ä–µ—Å –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, —Ç–æ –ø–æ–ª—É—á–∏—Ç—Å—è
    // —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç. –≠—Ç–æ—Ç —Ç–∏–ø —É–∫–∞–∑–∞—Ç–µ–ª—è
    // –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É —É–∫–∞–∑–∞—Ç–µ–ª–µ–π.
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    const ptr = &array[2];
    try expect(@TypeOf(ptr) == *u8);

    try expect(array[2] == 3);
    ptr.* += 1;
    try expect(array[2] == 4);
}
```
```bash
$ zig test test_single_item_pointer.zig
1/2 test_single_item_pointer.test.address of syntax...OK
2/2 test_single_item_pointer.test.pointer array access...OK
All 2 tests passed.
```

**Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫—É —Å —É–∫–∞–∑–∞—Ç–µ–ª—è–º–∏. –õ—É—á—à–µ –ø—Ä–∏—Å–≤–æ–∏—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—é –∑–Ω–∞—á–µ–Ω–∏–µ `[*]T` –∏ —É–≤–µ–ª–∏—á–∏—Ç—å —ç—Ç—É –ø–µ—Ä–µ–º–µ–Ω–Ω—É—é.
–ù–∞–ø—Ä–∏–º–µ—Ä, –ø—Ä—è–º–æ–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è –∏–∑ —Å—Ä–µ–∑–∞ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –µ–≥–æ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω–∏—é.

```zig
const expect = @import("std").testing.expect;

test "pointer arithmetic with many-item pointer" {
    const array = [_]i32{ 1, 2, 3, 4 };
    var ptr: [*]const i32 = &array;

    try expect(ptr[0] == 1);
    ptr += 1;
    try expect(ptr[0] == 2);

    // —Ä–∞–∑–±–∏–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –∫–æ–Ω—Ü–∞ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ
    // –∞—Ä–∏—Ñ–º–µ—Ç–∏–∫–µ —É–∫–∞–∑–∞—Ç–µ–ª—è: `ptr[start..] == ptr + start`
    try expect(ptr[1..] == ptr + 1);
}

test "pointer arithmetic with slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    var length: usize = 0; // var, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª –∏–∑–≤–µ—Å—Ç–µ–Ω –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    _ = &length; // –ø–æ–¥–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É "var –Ω–µ –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω"
    var slice = array[length..array.len];

    try expect(slice[0] == 1);
    try expect(slice.len == 4);

    slice.ptr += 1;
    // —Ç–µ–ø–µ—Ä—å —Å—Ä–µ–∑ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –Ω–µ–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏, —Ç–∞–∫ –∫–∞–∫ len –Ω–µ –æ–±–Ω–æ–≤–ª—è–ª—Å—è

    try expect(slice[0] == 2);
    try expect(slice.len == 4);
}
```
```bash
$ zig test test_pointer_arithmetic.zig
1/2 test_pointer_arithmetic.test.pointer arithmetic with many-item pointer...OK
2/2 test_pointer_arithmetic.test.pointer arithmetic with slices...OK
All 2 tests passed.
```

 –í **Zig** –º—ã –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Å—Ä–µ–∑—ã, –∞ –Ω–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –∫–∞—Ä–¥–∏–Ω–∞–ª–æ–º. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å
 –º–∞—Å—Å–∏–≤ –∏–ª–∏ —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ —Å—Ä–µ–∑ –∏—Å–ø–æ–ª—å–∑—É—è —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ä–µ–∑–æ–≤.

–°—Ä–µ–∑—ã –∏–º–µ—é—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –≥—Ä–∞–Ω–∏—Ü –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –∑–∞—â–∏—â–µ–Ω—ã –æ—Ç —Ç–∞–∫–æ–≥–æ —Ä–æ–¥–∞ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –ø–æ–≤–µ–¥–µ–Ω–∏—è. –≠—Ç–æ –æ–¥–Ω–∞ –∏–∑ –ø—Ä–∏—á–∏–Ω –ø–æ
–∫–æ—Ç–æ—Ä–æ–π –º—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Å—Ä–µ–∑—ã —É–∫–∞–∑–∞—Ç–µ–ª—è–º.

```zig
const expect = @import("std").testing.expect;

test "pointer slicing" {
    var array = [_]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
    var start: usize = 2; // var, —á—Ç–æ–±—ã –æ–Ω –±—ã–ª –∏–∑–≤–µ—Å—Ç–µ–Ω –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    _ = &start; // –ø–æ–¥–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É "var –Ω–µ –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω"
    const slice = array[start..4];
    try expect(slice.len == 2);

    try expect(array[3] == 4);
    slice[1] += 1;
    try expect(array[3] == 5);
}
```
```bash
$ zig test test_slice_bounds.zig
1/1 test_slice_bounds.test.pointer slicing...OK
All 1 tests passed.
```

–£–∫–∞–∑–∞—Ç–µ–ª–∏ —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –µ—Å–ª–∏ —Ç–æ–ª—å–∫–æ –∫–æ–¥ –Ω–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –ø–∞–º—è—Ç–∏:
```zig
const expect = @import("std").testing.expect;

test "comptime pointers" {
    comptime {
        var x: i32 = 1;
        const ptr = &x;
        ptr.* += 1;
        x += 1;
        try expect(ptr.* == 3);
    }
}
```
```bash
$ zig test test_comptime_pointers.zig
1/1 test_comptime_pointers.test.comptime pointers...OK
All 1 tests passed.
```

–ß—Ç–æ–±—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π –∞–¥—Ä–µ—Å –≤ —É–∫–∞–∑–∞—Ç–µ–ª—å –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `@ptrFromInt`. –ß—Ç–æ–±—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –≤ —Ü–µ–ª–æ–µ
—á–∏—Å–ª–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `@intFromPtr`:

```zig
const expect = @import("std").testing.expect;

test "@intFromPtr and @ptrFromInt" {
    const ptr: *i32 = @ptrFromInt(0xdeadbee0);
    const addr = @intFromPtr(ptr);
    try expect(@TypeOf(addr) == usize);
    try expect(addr == 0xdeadbee0);
}
```
```bash
$ zig test test_integer_pointer_conversion.zig
1/1 test_integer_pointer_conversion.test.@intFromPtr and @ptrFromInt...OK
All 1 tests passed.
```

**Zig** —Å–ø–æ—Å–æ–±–µ–Ω —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∞–¥—Ä–µ—Å–∞ –ø–∞–º—è—Ç–∏ –≤ comptime –∫–æ–¥–µ –¥–æ —Ç–µ—Ö –ø–æ—Ä –ø–æ–∫–∞ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥–µ—Ç —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω:
```zig
const expect = @import("std").testing.expect;

test "comptime @ptrFromInt" {
    comptime {
        // Zig –º–æ–∂–µ—Ç –¥–µ–ª–∞—Ç—å —ç—Ç–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏, —á—Ç–æ
        // ptr –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Ä–∞–∑—ã–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç—Å—è.
        const ptr: *i32 = @ptrFromInt(0xdeadbee0);
        const addr = @intFromPtr(ptr);
        try expect(@TypeOf(addr) == usize);
        try expect(addr == 0xdeadbee0);
    }
}
```
```bash
$ zig test test_comptime_pointer_conversion.zig
1/1 test_comptime_pointer_conversion.test.comptime @ptrFromInt...OK
All 1 tests passed.
```

#### volatile

–ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ –∑–∞–≥—Ä—É–∑–∫–∞ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –∏–º–µ—é—Ç –ø–æ–±–æ—á–Ω—ã—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤. –ï—Å–ª–∏ –¥–∞–Ω–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö
–¥–æ–ª–∂–Ω—ã –∏–º–µ—Ç—å –ø–æ–±–æ—á–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã —Ç–∞–∫–∏–µ –∫–∞–∫ –≤–≤–æ–¥/–≤—ã–≤–æ–¥ —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –ø–∞–º—è—Ç–∏ (MMIO) –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `volatile`. –í —Å–ª–µ–¥—É—é—â–µ–º –∫–æ–¥–µ
–≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –≤—Å–µ –∑–∞–≥—Ä—É–∑–∫–∏ –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é `mmio_ptr` –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤ —Ç–æ–º –∂–µ –ø–æ—Ä—è–¥–∫–µ, —á—Ç–æ –∏ –≤ –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ:

```zig
const expect = @import("std").testing.expect;

test "volatile" {
    const mmio_ptr: *volatile u8 = @ptrFromInt(0x12345678);
    try expect(@TypeOf(mmio_ptr) == *volatile u8);
}
```
```bash
$ zig test test_volatile.zig
1/1 test_volatile.test.volatile...OK
All 1 tests passed.
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ `volatile` –Ω–µ —Å–≤—è–∑–∞–Ω —Å –ø–∞—Ä–∞–ª–ª–µ–ª–∏–∑–º–æ–º –∏ –∞—Ç–æ–º–∞—Ä–Ω–æ—Å—Ç—å—é. –ï—Å–ª–∏ –≤—ã –≤–∏–¥–∏—Ç–µ –∫–æ–¥ –∫–æ—Ç–æ—Ä—ã–π –∏—Å–ø–æ–ª—å–∑—É–µ—Ç
`volatile` –¥–ª—è —á–µ–≥–æ-—Ç–æ –¥—Ä—É–≥–æ–≥–æ –∫—Ä–æ–º–µ –≤–≤–æ–¥–∞/–≤—ã–≤–æ–¥–∞ —Å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ–º –≤ –ø–∞–º—è—Ç–∏, —Ç–æ —ç—Ç–æ –≤–µ—Ä–æ—è—Ç–Ω–æ –æ—à–∏–±–∫–∞.

`@ptrCast` –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ç–∏–ø —ç–ª–µ–º–µ–Ω—Ç–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è –≤ –¥—Ä—É–≥–æ–π. –≠—Ç–æ —Å–æ–∑–¥–∞–µ—Ç –Ω–æ–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–∏–º–æ–µ
–Ω–µ–∑–∞–∫–æ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∑–∞–≥—Ä—É–∂–∞–µ–º—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ —Ö—Ä–∞–Ω–∏–ª–∏—â, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ—Ö–æ–¥—è—Ç —á–µ—Ä–µ–∑ –Ω–µ–≥–æ. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, –¥—Ä—É–≥–∏–µ
–≤–∏–¥—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –ø—Ä–µ–¥–ø–æ—á—Ç–∏—Ç–µ–ª—å–Ω–µ–µ —á–µ–º `@ptrCast`, –µ—Å–ª–∏ —ç—Ç–æ –≤–æ–∑–º–æ–∂–Ω–æ.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "pointer casting" {
    const bytes align(@alignOf(u32)) = [_]u8{ 0x12, 0x12, 0x12, 0x12 };
    const u32_ptr: *const u32 = @ptrCast(&bytes);
    try expect(u32_ptr.* == 0x12121212);

    // –î–∞–∂–µ —ç—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä —è–≤–ª—è–µ—Ç—Å—è –Ω–∞–¥—É–º–∞–Ω–Ω—ã–º - –µ—Å—Ç—å —Å–ø–æ—Å–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ –ª—É—á—à–µ, —á–µ–º
    // –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏—Å–ø–æ–ª—å–∑—É—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Å —Å—É–∂–µ–Ω–∏–µ–º —Å–ª–∞–π—Å–∞:
    const u32_value = std.mem.bytesAsSlice(u32, bytes[0..])[0];
    try expect(u32_value == 0x12121212);

    // –ò –¥–∞–∂–µ –¥—Ä—É–≥–æ–π —Å–ø–æ—Å–æ–±, —Å–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ:
    try expect(@as(u32, @bitCast(bytes)) == 0x12121212);
}

test "pointer child type" {
    // —Ç–∏–ø—ã —É–∫–∞–∑–∞—Ç–µ–ª–µ–π –∏–º–µ—é—Ç `–¥–æ—á–µ—Ä–Ω–µ–µ` –ø–æ–ª–µ, –≤ –∫–æ—Ç–æ—Ä–æ–º —É–∫–∞–∑—ã–≤–∞–µ—Ç—Å—è —Ç–∏–ø, –Ω–∞ –∫–æ—Ç–æ—Ä—ã–π –æ–Ω–∏ —É–∫–∞–∑—ã–≤–∞—é—Ç.
    try expect(@typeInfo(*u32).Pointer.child == u32);
}
```
```bash
$ zig test test_pointer_casting.zig
1/2 test_pointer_casting.test.pointer casting...OK
2/2 test_pointer_casting.test.pointer child type...OK
All 2 tests passed.
```

#### –í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ

–£ –∫–∞–∂–¥–æ–≥–æ —Ç–∏–ø–∞ –µ—Å—Ç—å **alignment** - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –±–∞–π—Ç, —Ç–∞–∫ —á—Ç–æ, –∫–æ–≥–¥–∞ –∑–Ω–∞—á–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Ç–∏–ø–∞ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è –∏–∑ –ø–∞–º—è—Ç–∏ –∏–ª–∏
—Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –≤ –Ω–µ–π, –∞–¥—Ä–µ—Å –ø–∞–º—è—Ç–∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ –∫—Ä–∞—Ç–µ–Ω —ç—Ç–æ–º—É —á–∏—Å–ª—É. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `@alignOf`, —á—Ç–æ–±—ã
—É–∑–Ω–∞—Ç—å —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ª—é–±–æ–≥–æ —Ç–∏–ø–∞.

–í—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞, –Ω–æ –≤—Å–µ–≥–¥–∞ –∏–º–µ–µ—Ç —Å—Ç–µ–ø–µ–Ω—å –¥–≤–æ–π–∫–∏ –∏ –º–µ–Ω—å—à–µ `1 << 29`.

–í **Zig** —Ç–∏–ø —É–∫–∞–∑–∞—Ç–µ–ª—è –∏–º–µ–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ. –ï—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ —Ä–∞–≤–Ω–æ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏—é –±–∞–∑–æ–≤–æ–≥–æ —Ç–∏–ø–∞, –µ–≥–æ –º–æ–∂–Ω–æ –Ω–µ
—É–∫–∞–∑—ã–≤–∞—Ç—å –≤ —Ç–∏–ø–µ:

```zig
const std = @import("std");
const builtin = @import("builtin");
const expect = std.testing.expect;

test "variable alignment" {
    var x: i32 = 1234;
    const align_of_i32 = @alignOf(@TypeOf(x));
    try expect(@TypeOf(&x) == *i32);
    try expect(*i32 == *align(align_of_i32) i32);
    if (builtin.target.cpu.arch == .x86_64) {
        try expect(@typeInfo(*i32).Pointer.alignment == 4);
    }
}
```
```bash
$ zig test test_variable_alignment.zig
1/1 test_variable_alignment.test.variable alignment...OK
All 1 tests passed.
```

–¢–æ—á–Ω–æ —Ç–∞–∫ –∂–µ –∫–∞–∫ `*i32` –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω –≤ `*const i32`, —É–∫–∞–∑–∞—Ç–µ–ª—å —Å –±–æ–ª—å—à–∏–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ—è–≤–Ω–æ
–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω –≤ —É–∫–∞–∑–∞—Ç–µ–ª—å —Å –º–µ–Ω—å—à–∏–º –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º, –Ω–æ –Ω–µ –Ω–∞–æ–±–æ—Ä–æ—Ç.

–í—ã –º–æ–∂–µ—Ç–µ —É–∫–∞–∑–∞—Ç—å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –¥–ª—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –∏ —Ñ—É–Ω–∫—Ü–∏–π. –ï—Å–ª–∏ –≤—ã —Å–¥–µ–ª–∞–µ—Ç–µ —ç—Ç–æ, —Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –Ω–∏—Ö –ø–æ–ª—É—á–∞—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–µ
–≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ:

```zig
const expect = @import("std").testing.expect;

var foo: u8 align(4) = 100;

test "global variable alignment" {
    try expect(@typeInfo(@TypeOf(&foo)).Pointer.alignment == 4);
    try expect(@TypeOf(&foo) == *align(4) u8);
    const as_pointer_to_array: *align(4) [1]u8 = &foo;
    const as_slice: []align(4) u8 = as_pointer_to_array;
    const as_unaligned_slice: []u8 = as_slice;
    try expect(as_unaligned_slice[0] == 100);
}

fn derp() align(@sizeOf(usize) * 2) i32 {
    return 1234;
}
fn noop1() align(1) void {}
fn noop4() align(4) void {}

test "function alignment" {
    try expect(derp() == 1234);
    try expect(@TypeOf(derp) == fn () i32);
    try expect(@TypeOf(&derp) == *align(@sizeOf(usize) * 2) const fn () i32);

    noop1();
    try expect(@TypeOf(noop1) == fn () void);
    try expect(@TypeOf(&noop1) == *align(1) const fn () void);

    noop4();
    try expect(@TypeOf(noop4) == fn () void);
    try expect(@TypeOf(&noop4) == *align(4) const fn () void);
}
```
```bash
$ zig test test_variable_func_alignment.zig
1/2 test_variable_func_alignment.test.global variable alignment...OK
2/2 test_variable_func_alignment.test.function alignment...OK
All 2 tests passed.
```

–ï—Å–ª–∏ —É –≤–∞—Å –µ—Å—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –∏–ª–∏ —Å—Ä–µ–∑ –∫–æ—Ç–æ—Ä—ã–π –∏–º–µ–µ—Ç –Ω–µ–±–æ–ª—å—à–æ–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ, –Ω–æ –≤—ã –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ –æ–Ω –∏–º–µ–µ—Ç
–±–æ–ª—å—à–µ–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `@alignCast` —á—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –±–æ–ª–µ–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–π. –í–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —ç—Ç–æ –Ω–µ
—Ç—Ä–µ–±—É–µ—Ç—Å—è, –Ω–æ –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:

```zig
const std = @import("std");

test "pointer alignment safety" {
    var array align(4) = [_]u32{ 0x11111111, 0x11111111 };
    const bytes = std.mem.sliceAsBytes(array[0..]);
    try std.testing.expect(foo(bytes) == 0x11111111);
}
fn foo(bytes: []u8) u32 {
    const slice4 = bytes[1..5];
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
    return int_slice[0];
}
```
```bash
$ zig test test_incorrect_pointer_alignment.zig
1/1 test_incorrect_pointer_alignment.test.pointer alignment safety...thread 3568823 panic: incorrect alignment
/home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:10:68: 0x103d13a in foo (test)
    const int_slice = std.mem.bytesAsSlice(u32, @as([]align(4) u8, @alignCast(slice4)));
                                                                   ^
/home/andy/src/zig/doc/langref/test_incorrect_pointer_alignment.zig:6:31: 0x103cfd7 in test.pointer alignment safety (test)
    try std.testing.expect(foo(bytes) == 0x11111111);
                              ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1047f10 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e28b in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103d609 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103d171 in _start (test)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/c771705677c0d2df24e00269a9189f97/test

```

#### allowzero

–≠—Ç–æ—Ç –∞—Ç—Ä–∏–±—É—Ç pointer –ø–æ–∑–≤–æ–ª—è–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—é –∏–º–µ—Ç—å –Ω—É–ª–µ–≤–æ–π –∞–¥—Ä–µ—Å. –≠—Ç–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Ç–æ–ª—å–∫–æ –¥–ª—è –∞–≤—Ç–æ–Ω–æ–º–Ω–æ–π —Ü–µ–ª–µ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã OS,
–≥–¥–µ –Ω—É–ª–µ–≤–æ–π –∞–¥—Ä–µ—Å –º–æ–∂–µ—Ç –±—ã—Ç—å –æ—Ç–æ–±—Ä–∞–∂–µ–Ω. –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å –Ω—É–ª–µ–≤—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ
—É–∫–∞–∑–∞—Ç–µ–ª–∏. –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ —Å –∑–Ω–∞—á–µ–Ω–∏–µ–º `allowzero` –Ω–µ –∏–º–µ—é—Ç —Ç–∞–∫–æ–≥–æ –∂–µ —Ä–∞–∑–º–µ—Ä–∞ –∫–∞–∫ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –æ–±—ä–µ–∫—Ç—ã. –í —ç—Ç–æ–º
–ø—Ä–∏–º–µ—Ä–µ –∫–æ–¥–∞, –µ—Å–ª–∏ –±—ã —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–µ –∏–º–µ–ª –∞—Ç—Ä–∏–±—É—Ç–∞ `allowzero`, —ç—Ç–æ –æ–∑–Ω–∞—á–∞–ª–æ –±—ã –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è –∫
–Ω—É–ª–µ–≤–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é.:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "allowzero" {
    var zero: usize = 0; // –∑–Ω–∞—á–µ–Ω–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    _ = &zero; // –ø–æ–¥–∞–≤–∏—Ç—å –æ—à–∏–±–∫—É "var –Ω–µ –±—ã–ª –∏–∑–º–µ–Ω—ë–Ω"
    const ptr: *allowzero i32 = @ptrFromInt(zero);
    try expect(@intFromPtr(ptr) == 0);
}
```
```bash
$ zig test test_allowzero.zig
1/1 test_allowzero.test.allowzero...OK
All 1 tests passed.
```

#### –£–∫–∞–∑–∞—Ç–µ–ª–∏ —Å –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º

–°–∏–Ω—Ç–∞–∫—Å–∏—Å `[*:x]T` –æ–ø–∏—Å—ã–≤–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –¥–ª–∏–Ω–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º. –≠—Ç–æ –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –∑–∞—â–∏—Ç—É –æ—Ç
–ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –±—É—Ñ–µ—Ä–∞ –∏ –ø–æ–≤—Ç–æ—Ä–Ω—ã–º —á—Ç–µ–Ω–∏–µ–º.

```zig
const std = @import("std");

// –≠—Ç–æ —Ç–∞–∫–∂–µ –¥–æ—Å—Ç—É–ø–Ω–æ –∫–∞–∫ `std.c.printf`.
pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;

pub fn main() anyerror!void {
    _ = printf("Hello, world!\n"); // OK

    const msg = "Hello, world!\n";
    const non_null_terminated_msg: [msg.len]u8 = msg.*;
    _ = printf(&non_null_terminated_msg);
}
```
```bash
$ zig build-exe sentinel-terminated_pointer.zig -lc
/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: error: expected type '[*:0]const u8', found '*const [14]u8'
    _ = printf(&non_null_terminated_msg);
               ^~~~~~~~~~~~~~~~~~~~~~~~
/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:11:16: note: destination pointer requires '0' sentinel
/home/andy/src/zig/doc/langref/sentinel-terminated_pointer.zig:4:35: note: parameter type declared here
pub extern "c" fn printf(format: [*:0]const u8, ...) c_int;
                                 ~^~~~~~~~~~~~
referenced by:
    callMain: /home/andy/src/zig/lib/std/start.zig:524:32
    callMainWithArgs: /home/andy/src/zig/lib/std/start.zig:482:12
    remaining reference traces hidden; use '-freference-trace' to see all reference traces

```

------------
### –°—Ä–µ–∑—ã

–°—Ä–µ–∑ - —ç—Ç–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –∏ –¥–ª–∏–Ω–∞. –†–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É –º–∞—Å—Å–∏–≤–æ–º –∏ —Å—Ä–µ–∑–æ–º –∑–∞–∫–ª—é—á–∞–µ—Ç—Å—è –≤ —Ç–æ–º, —á—Ç–æ –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞ —è–≤–ª—è–µ—Ç—Å—è —á–∞—Å—Ç—å—é —Ç–∏–ø–∞
–∏ –∏–∑–≤–µ—Å—Ç–Ω–∞ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, —Ç–æ–≥–¥–∞ –∫–∞–∫ –¥–ª–∏–Ω–∞ —Å—Ä–µ–∑–∞ –∏–∑–≤–µ—Å—Ç–Ω–∞ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è. –î–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –æ–±–æ–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º
–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø–æ–ª–µ `len`.

```zig
const expect = @import("std").testing.expect;
const expectEqualSlices = @import("std").testing.expectEqualSlices;

test "basic slices" {
    var array = [_]i32{ 1, 2, 3, 4 };
    var known_at_runtime_zero: usize = 0;
    _ = &known_at_runtime_zero;
    const slice = array[known_at_runtime_zero..array.len];

    // –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω–∞—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
    const alt_slice: []const i32 = &.{ 1, 2, 3, 4 };

    try expectEqualSlices(i32, slice, alt_slice);

    try expect(@TypeOf(slice) == []i32);
    try expect(&slice[0] == &array[0]);
    try expect(slice.len == array.len);

    // –ï—Å–ª–∏ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å—Ä–µ–∑ —Å –∏–∑–≤–µ—Å—Ç–Ω—ã–º–∏ –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –∏ –∫–æ–Ω–µ—á–Ω—ã–º–∏ –ø–æ–∑–∏—Ü–∏—è–º–∏, —Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –±—É–¥–µ—Ç
    // —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Å—Å–∏–≤, –∞ –Ω–µ –Ω–∞ —Å—Ä–µ–∑.
    const array_ptr = array[0..array.len];
    try expect(@TypeOf(array_ptr) == *[array.len]i32);

    // –í—ã –º–æ–∂–µ—Ç–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Å—Ä–µ–∑ –ø–æ –¥–ª–∏–Ω–µ –≤—ã–ø–æ–ª–Ω–∏–≤ —Å—Ä–µ–∑ –¥–≤–∞–∂–¥—ã. –≠—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É
    // –≤—ã–ø–æ–ª–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –Ω–∞–ø—Ä–∏–º–µ—Ä, —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –¥–ª–∏–Ω—É –∏–∑–≤–µ—Å—Ç–Ω—É—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∫–æ–≥–¥–∞
    // –Ω–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –∏–∑–≤–µ—Å—Ç–Ω–∞ —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
    var runtime_start: usize = 1;
    _ = &runtime_start;
    const length = 2;
    const array_ptr_len = array[runtime_start..][0..length];
    try expect(@TypeOf(array_ptr_len) == *[length]i32);

    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ address-of –¥–ª—è —Å—Ä–µ–∑–∞ –¥–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç.
    try expect(@TypeOf(&slice[0]) == *i32);
    // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–æ–ª—è `ptr` –¥–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
    try expect(@TypeOf(slice.ptr) == [*]i32);
    try expect(@intFromPtr(slice.ptr) == @intFromPtr(&slice[0]));

    // –°—Ä–µ–∑—ã –ø—Ä–æ–≤–µ—Ä—è—é—Ç –≥—Ä–∞–Ω–∏—Ü—ã –º–∞—Å—Å–∏–≤–∞.
    // –ï—Å–ª–∏ –≤—ã –ø–æ–ø—ã—Ç–∞–µ—Ç–µ—Å—å –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ —á–µ–º—É-–ª–∏–±–æ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤—ã –ø–æ–ª—É—á–∏—Ç–µ —Å–±–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:
    slice[10] += 1;

    // –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ `slice.ptr` –Ω–µ –≤—ã–∑—ã–≤–∞–µ—Ç –ø—Ä–æ–≤–µ—Ä–∫—É –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ `&slice[0]`
    // —É—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç, —á—Ç–æ —Å—Ä–µ–∑ –∏–º–µ–µ—Ç len > 0.
}
```
```bash
$ zig test test_basic_slices.zig
1/1 test_basic_slices.test.basic slices...thread 3571722 panic: index out of bounds: index 10, len 4
/home/andy/src/zig/doc/langref/test_basic_slices.zig:41:10: 0x103f955 in test.basic slices (test)
    slice[10] += 1;
         ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104c800 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104210b in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103fe49 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103f9b1 in _start (test)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/3c391d75c939ce98356b98dd812503b1/test
```

–≠—Ç–æ –æ–¥–Ω–∞ –∏–∑ –ø—Ä–∏—á–∏–Ω –ø–æ –∫–æ—Ç–æ—Ä–æ–π –º—ã –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ–º —Å—Ä–µ–∑—ã —É–∫–∞–∑–∞—Ç–µ–ª—è–º.

```zig
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;
const fmt = std.fmt;

test "using slices for strings" {
    // Zig –Ω–µ –∏–º–µ–µ—Ç –ø–æ–Ω—è—Ç–∏—è –æ —Å—Ç—Ä–æ–∫–∞—Ö. –°—Ç—Ä–æ–∫–æ–≤—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã - —ç—Ç–æ –∫–æ–Ω—Ç–∞–Ω—Ç–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏
    // –Ω–∞ –º–∞—Å—Å–∏–≤—ã u8 –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –Ω—É–ª–µ–º, –∏ –ø–æ —Å–æ–≥–ª–∞—à–µ–Ω–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    // –∫–æ—Ç–æ—Ä—ã–µ —è–≤–ª—è—é—Ç—Å—è "—Å—Ç—Ä–æ–∫–∞–º–∏", –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å—Ä–µ–∑–∞–º–∏ u8 –≤ –∫–æ–¥–∏—Ä–æ–≤–∫–µ UTF-8.
    // –ó–¥–µ—Å—å –º—ã –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º *const [5:0]u8 –∏ *const [6:0]u8 –≤ []const u8
    const hello: []const u8 = "hello";
    const world: []const u8 = "‰∏ñÁïå";

    var all_together: [100]u8 = undefined;
    // –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å —Å—Ä–µ–∑–æ–≤ —Å–æ–¥–µ—Ä–∂–∞—â–∏–π –ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ –æ–¥–∏–Ω –∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å –≤ –º–∞—Å—Å–∏–≤–µ
    // —á—Ç–æ–±—ã –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –º–∞—Å—Å–∏–≤ –≤ —Å—Ä–µ–∑.
    var start: usize = 0;
    _ = &start;
    const all_together_slice = all_together[start..];
    // –ü—Ä–∏–º–µ—Ä –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫.
    const hello_world = try fmt.bufPrint(all_together_slice, "{s} {s}", .{ hello, world });

    // –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å UTF-8 –∏ –Ω–µ –±–µ—Å–ø–æ–∫–æ–∏—Ç—å—Å—è –æ —Ç–æ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —á—Ç–æ-–ª–∏–±–æ —Å—Ç—Ä–æ–∫–æ–π.
    // –ï—Å–ª–∏ –≤–∞–º –Ω–µ –Ω—É–∂–Ω–æ –∏–º–µ—Ç—å –¥–µ–ª–æ —Å –æ—Ç–¥–µ–ª—å–Ω—ã–º–∏ —Å–∏–º–≤–æ–ª–∞–º–∏, –Ω–µ—Ç –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ –¥–µ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏–∏.
    try expect(mem.eql(u8, hello_world, "hello ‰∏ñÁïå"));
}

test "slice pointer" {
    var array: [10]u8 = undefined;
    const ptr = &array;
    try expect(@TypeOf(ptr) == *[10]u8);

    // –£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–∞—Å—Å–∏–≤ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–∑–¥–µ–ª–µ–Ω —Ç–æ—á–Ω–æ —Ç–∞–∫ –∂–µ, –∫–∞–∫ –∏ –º–∞—Å—Å–∏–≤:
    var start: usize = 0;
    var end: usize = 5;
    _ = .{ &start, &end };
    const slice = ptr[start..end];
    // –°—Ä–µ–∑–∞ —è–≤–ª—è–µ—Ç—Å—è –∏–∑–º–µ–Ω—è–µ–º—ã–º –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –≤—ã—Ä–µ–∑–∞–ª–∏ –∏–∑–º–µ–Ω—è–µ–º—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å.
    try expect(@TypeOf(slice) == []u8);
    slice[2] = 3;
    try expect(array[2] == 3);

    // –û–ø—è—Ç—å –∂–µ, —Å—Ä–µ–∑ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≤ comptime –∏–Ω–¥–µ–∫—Å–æ–≤ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ —Å–æ–∑–¥–∞–Ω–∏—é –¥—Ä—É–≥–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è
    // –Ω–∞ –º–∞—Å—Å–∏–≤:
    const ptr2 = slice[2..3];
    try expect(ptr2.len == 1);
    try expect(ptr2[0] == 3);
    try expect(@TypeOf(ptr2) == *[1]u8);
}
```
```bash
$ zig test test_slices.zig
1/2 test_slices.test.using slices for strings...OK
2/2 test_slices.test.slice pointer...OK
All 2 tests passed.
```

#### –°—Ä–µ–∑—ã —Å –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º

–°–∏–Ω—Ç–∞–∫—Å–∏—Å `[:x]T` - —ç—Ç–æ —Å—Ä–µ–∑, –¥–ª–∏–Ω–∞ –∫–æ—Ç–æ—Ä–æ–≥–æ –∏–∑–≤–µ—Å—Ç–Ω–∞ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –∞ —Ç–∞–∫–∂–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç –Ω–∞–ª–∏—á–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–≥–æ
—ç–ª–µ–º–µ–Ω—Ç–∞ –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –ø–æ –¥–ª–∏–Ω–µ. –¢–∏–ø –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç, —á—Ç–æ –¥–æ —ç—Ç–æ–≥–æ –Ω–µ –±—ã–ª–æ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤. –°—Ä–µ–∑—ã –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ
–∫–∞—Ä–¥–∏–Ω–∞–ª–æ–º –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è—é—Ç —ç–ª–µ–º–µ–Ω—Ç—É –¥–æ—Å—Ç—É–ø –∫ –∏–Ω–¥–µ–∫—Å—É `len`.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "0-terminated slice" {
    const slice: [:0]const u8 = "hello";

    try expect(slice.len == 5);
    try expect(slice[5] == 0);
}
```
```bash
$ zig test test_null_terminated_slice.zig
1/1 test_null_terminated_slice.test.0-terminated slice...OK
All 1 tests passed.
```

–°—Ä–µ–∑—ã –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–∏–µ—Å—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –≤–∞—Ä–∏–∞—Ü–∏–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ —Å—Ä–µ–∑–∞
`data[start..end :x]`, –≥–¥–µ –¥–∞–Ω–Ω—ã–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—Ç —Å–æ–±–æ–π —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤, –º–∞—Å—Å–∏–≤ –∏–ª–∏ —Å—Ä–µ–∑, –∞ `x` - –∑–Ω–∞—á–µ–Ω–∏–µ
–∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "0-terminated slicing" {
    var array = [_]u8{ 3, 2, 1, 0, 3, 2, 1, 0 };
    var runtime_length: usize = 3;
    _ = &runtime_length;
    const slice = array[0..runtime_length :0];

    try expect(@TypeOf(slice) == [:0]u8);
    try expect(slice.len == 3);
}
```
```bash
$ zig test test_null_terminated_slicing.zig
1/1 test_null_terminated_slicing.test.0-terminated slicing...OK
All 1 tests passed.
```

–î–ª—è —Å—Ä–µ–∑–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω–æ–≥–æ —Å –ø–æ–º–æ—â—å—é –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞, —É—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç—Å—è, —á—Ç–æ —ç–ª–µ–º–µ–Ω—Ç –≤ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞—Ä–¥–∏–Ω–∞–ª–∞ –≤ –∏—Å—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
–Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —è–≤–ª—è–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ–º —ç–ª–µ–º–µ–Ω—Ç–∞. –ï—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–∞–∫, –≤–æ–∑–Ω–∏–∫–∞–µ—Ç –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –∑–∞—â–∏—â–µ–Ω–Ω–æ–µ —Å –ø–æ–º–æ—â—å—é
safety.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "sentinel mismatch" {
    var array = [_]u8{ 3, 2, 1, 0 };

    // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ä–µ–∑–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—â–µ–≥–æ—Å—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º –∏–∑ –º–∞—Å—Å–∏–≤–∞ –¥–ª–∏–Ω–æ–π 2
    // –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ —Ç–æ–º—É, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ `1` –∑–∞–π–º–µ—Ç –ø–æ–∑–∏—Ü–∏—é —ç—Ç–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.
    // –≠—Ç–æ –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é —ç–ª–µ–º–µ–Ω—Ç–∞ —Ä–∞–≤–Ω–æ–µ `0`, —á—Ç–æ –ø—Ä–∏–≤–µ–¥–µ—Ç
    // –∫ –ø–∞–Ω–∏–∫–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
    var runtime_length: usize = 2;
    _ = &runtime_length;
    const slice = array[0..runtime_length :0];

    _ = slice;
}
```
```bash
$ zig test test_sentinel_mismatch.zig
1/1 test_sentinel_mismatch.test.sentinel mismatch...thread 3579807 panic: sentinel mismatch: expected 0, found 1
/home/andy/src/zig/doc/langref/test_sentinel_mismatch.zig:13:24: 0x103cf16 in test.sentinel mismatch (test)
    const slice = array[0..runtime_length :0];
                       ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048aa0 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103eabb in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103d4f9 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103d061 in _start (test)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/2af8da0d34d396fbb50fa515cef10c72/test
```

------------
### –°—Ç—Ä—É–∫—Ç—É—Ä–∞

```zig
// –û–±—ä—è–≤–ª—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É.
// Zig –Ω–µ –¥–∞–µ—Ç –Ω–∏–∫–∞–∫–∏—Ö –≥–∞—Ä–∞–Ω—Ç–∏–π –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Ä—è–¥–∫–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –ø–æ–ª–µ–π –∏ —Ä–∞–∑–º–µ—Ä–∞
// —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –Ω–æ –ø–æ–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –±—É–¥—É—Ç –≤—ã—Ä–æ–≤–Ω–µ–Ω—ã –ø–æ –≤–µ—Ä—Ç–∏–∫–∞–ª–∏.
const Point = struct {
    x: f32,
    y: f32,
};

// –í–æ–∑–º–æ–∂–Ω–æ –º—ã —Ö–æ—Ç–∏–º –ø–µ—Ä–µ–¥–∞—Ç—å —ç—Ç–æ –≤ OpenGL, –ø–æ—ç—Ç–æ–º—É –º—ã —Ö–æ—Ç–∏–º –±—ã—Ç—å –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–º–∏ –∫ —Ç–æ–º—É, –∫–∞–∫ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –±–∞–π—Ç—ã.
const Point2 = packed struct {
    x: f32,
    y: f32,
};

// –û–±—ä—è–≤–ª—è–µ—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä —Å—Ç—Ä—É–∫—Ç—É—Ä—ã.
const p = Point{
    .x = 0.12,
    .y = 0.34,
};

// –í–æ–∑–º–æ–∂–Ω–æ –º—ã –µ—â–µ –Ω–µ –≥–æ—Ç–æ–≤—ã –∑–∞–ø–æ–ª–Ω–∏—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—è.
var p2 = Point{
    .x = 0.12,
    .y = undefined,
};

// –£ —Å—Ç—Ä—É–∫—Ç—É—Ä –º–æ–≥—É—Ç –±—ã—Ç—å –º–µ—Ç–æ–¥—ã
// –ú–µ—Ç–æ–¥—ã Struct –Ω–µ —è–≤–ª—è—é—Ç—Å—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–º–∏, –æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ —Ä–∞–∑–¥–µ–ª–µ–Ω—ã –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ–º –∏–º–µ–Ω
// —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–∑—ã–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é —Ç–æ—á–µ—á–Ω–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞.
const Vec3 = struct {
    x: f32,
    y: f32,
    z: f32,

    pub fn init(x: f32, y: f32, z: f32) Vec3 {
        return Vec3{
            .x = x,
            .y = y,
            .z = z,
        };
    }

    pub fn dot(self: Vec3, other: Vec3) f32 {
        return self.x * other.x + self.y * other.y + self.z * other.z;
    }
};

const expect = @import("std").testing.expect;
test "dot product" {
    const v1 = Vec3.init(1.0, 0.0, 0.0);
    const v2 = Vec3.init(0.0, 1.0, 0.0);
    try expect(v1.dot(v2) == 0.0);

    // –ü–æ–º–∏–º–æ —Ç–æ–≥–æ, —á—Ç–æ –º–µ—Ç–æ–¥—ã struct –¥–æ—Å—Ç—É–ø–Ω—ã –¥–ª—è –≤—ã–∑–æ–≤–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Ç–æ—á–µ—á–Ω–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞, –æ–Ω–∏ –Ω–µ —è–≤–ª—è—é—Ç—Å—è
    // –æ—Å–æ–±–µ–Ω–Ω—ã–º–∏. –í—ã –º–æ–∂–µ—Ç–µ —Å—Å—ã–ª–∞—Ç—å—Å—è –Ω–∞ –Ω–∏—Ö –∫–∞–∫ –Ω–∞ –ª—é–±–æ–µ –¥—Ä—É–≥–æ–µ –æ–±—ä—è–≤–ª–µ–Ω–∏–µ –≤–Ω—É—Ç—Ä–∏
    // —Å—Ç—Ä—É–∫—Ç—É—Ä–∞:
    try expect(Vec3.dot(v1, v2) == 0.0);
}

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏—è.
// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å 0 –ø–æ–ª–µ–π.
const Empty = struct {
    pub const PI = 3.14;
};
test "struct namespaced variable" {
    try expect(Empty.PI == 3.14);
    try expect(@sizeOf(Empty) == 0);

    // –≤—ã –≤—Å–µ –µ—â–µ –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä –ø—É—Å—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã
    const does_nothing = Empty{};

    _ = does_nothing;
}

// –ø–æ—Ä—è–¥–æ–∫ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è –ø–æ–ª–µ–π struct –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–æ–º –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.
// –æ–¥–Ω–∞–∫–æ –≤—ã –≤—Å–µ —Ä–∞–≤–Ω–æ –º–æ–∂–µ—Ç–µ –≤—ã—á–∏—Å–ª–∏—Ç—å –±–∞–∑–æ–≤—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å struct –ø–æ —É–∫–∞–∑–∞—Ç–µ–ª—é –ø–æ–ª—è:
fn setYBasedOnX(x: *f32, y: f32) void {
    const point: *Point = @fieldParentPtr("x", x);
    point.y = y;
}
test "field parent pointer" {
    var point = Point{
        .x = 0.1234,
        .y = 0.5678,
    };
    setYBasedOnX(&point.x, 0.9);
    try expect(point.y == 0.9);
}

// –í—ã –º–æ–∂–µ—Ç–µ –≤–µ—Ä–Ω—É—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∏–∑ —Ñ—É–Ω–∫—Ü–∏–∏. –í–æ—Ç –∫–∞–∫ –º—ã —Å–æ–∑–¥–∞–µ–º –æ–±–æ–±—â–µ–Ω–∏—è –≤ Zig:
fn LinkedList(comptime T: type) type {
    return struct {
        pub const Node = struct {
            prev: ?*Node,
            next: ?*Node,
            data: T,
        };

        first: ?*Node,
        last: ?*Node,
        len: usize,
    };
}

test "linked list" {
    // –§—É–Ω–∫—Ü–∏–∏, –≤—ã–∑—ã–≤–∞–µ–º—ã–µ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –≤ –ø–∞–º—è—Ç–∏. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ
    // —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ:
    try expect(LinkedList(i32) == LinkedList(i32));

    const list = LinkedList(i32){
        .first = null,
        .last = null,
        .len = 0,
    };
    try expect(list.len == 0);

    // –ü–æ—Å–∫–æ–ª—å–∫—É —Ç–∏–ø—ã —è–≤–ª—è—é—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞, –≤—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä —Ç–∏–ø–∞ –ø—Ä–∏—Å–≤–æ–∏–≤ –µ–≥–æ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π:
    const ListOfInts = LinkedList(i32);
    try expect(ListOfInts == LinkedList(i32));

    var node = ListOfInts.Node{
        .prev = null,
        .next = null,
        .data = 1234,
    };
    const list2 = LinkedList(i32){
        .first = &node,
        .last = &node,
        .len = 1,
    };

    // –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä—É –∫ –ø–æ–ª—è–º –º–æ–∂–Ω–æ –æ–±—Ä–∞—â–∞—Ç—å—Å—è –Ω–∞–ø—Ä—è–º—É—é –±–µ–∑ —è–≤–Ω–æ–≥–æ —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏—è —É–∫–∞–∑–∞—Ç–µ–ª—è.
    // –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å
    try expect(list2.first.?.data == 1234);
    // instead of try expect(list2.first.?.*.data == 1234);
}
```
```bash
$ zig test test_structs.zig
1/4 test_structs.test.dot product...OK
2/4 test_structs.test.struct namespaced variable...OK
3/4 test_structs.test.field parent pointer...OK
4/4 test_structs.test.linked list...OK
All 4 tests passed.
```

#### –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–µ–π –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é

–ö–∞–∂–¥–æ–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ –ø–æ–ª–µ –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —É–∫–∞–∑—ã–≤–∞—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª—è –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é. –¢–∞–∫–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è
–≤–æ –≤—Ä–µ–º—è `comptime` –∏ –ø–æ–∑–≤–æ–ª—è—é—Ç –æ–ø—É—Å—Ç–∏—Ç—å –ø–æ–ª–µ –≤ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–º –ª–∏—Ç–µ—Ä–∞–ª—å–Ω–æ–º –≤—ã—Ä–∞–∂–µ–Ω–∏–∏:

```zig
const Foo = struct {
    a: i32 = 1234,
    b: i32,
};

test "default struct initialization fields" {
    const x: Foo = .{
        .b = 5,
    };
    if (x.a + x.b != 1239) {
        comptime unreachable;
    }
}
```
```bash
$ zig test struct_default_field_values.zig
1/1 struct_default_field_values.test.default struct initialization fields...OK
All 1 tests passed.
```

–ó–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–µ–π –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é –ø–æ–¥—Ö–æ–¥—è—Ç —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ –µ—Å–ª–∏ –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç—ã –¥–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–∞—Ä—É—à–µ–Ω—ã –ø—É—Ç–µ–º
–∏—Å–∫–ª—é—á–µ–Ω–∏—è —ç—Ç–æ–≥–æ –ø–æ–ª—è –∏–∑ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏.

–ù–∞–ø—Ä–∏–º–µ—Ä, –∑–¥–µ—Å—å –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é:

```zig
const Threshold = struct {
    minimum: f32 = 0.25,
    maximum: f32 = 0.75,

    const Category = enum { low, medium, high };

    fn categorize(t: Threshold, value: f32) Category {
        assert(t.maximum >= t.minimum);
        if (value < t.minimum) return .low;
        if (value > t.maximum) return .high;
        return .medium;
    }
};

pub fn main() !void {
    var threshold: Threshold = .{
        .maximum = 0.20,
    };
    const category = threshold.categorize(0.90);
    try std.io.getStdOut().writeAll(@tagName(category));
}

const std = @import("std");
const assert = std.debug.assert;
```
```bash
$ zig build-exe bad_default_value.zig
$ ./bad_default_value
thread 3570319 panic: reached unreachable code
/home/andy/src/zig/lib/std/debug.zig:412:14: 0x1037a6d in assert (bad_default_value)
    if (!ok) unreachable; // assertion failure
             ^
/home/andy/src/zig/doc/langref/bad_default_value.zig:8:15: 0x1034f59 in categorize (bad_default_value)
        assert(t.maximum >= t.minimum);
              ^
/home/andy/src/zig/doc/langref/bad_default_value.zig:19:42: 0x1034e8a in main (bad_default_value)
    const category = threshold.categorize(0.90);
                                         ^
/home/andy/src/zig/lib/std/start.zig:524:37: 0x1034da5 in posixCallMainAndExit (bad_default_value)
            const result = root.main() catch |err| {
                                    ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x10348c1 in _start (bad_default_value)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
(process terminated by signal)

```

–í—ã—à–µ –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å –æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏—è —ç—Ç–æ–≥–æ –ø—Ä–∏–Ω—Ü–∏–ø–∞. –ó–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–µ–π –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é –ø—Ä–∏–≤–µ–ª–∏ –∫ –Ω–∞—Ä—É—à–µ–Ω–∏—é
–∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–∞ –¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ –ø—Ä–∏–≤–µ–ª–æ –∫ –Ω–µ–∑–∞–∫–æ–Ω–Ω–æ–º—É –ø–æ–≤–µ–¥–µ–Ω–∏—é.

–ß—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å —ç—Ç–æ, —É–¥–∞–ª–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é –∏–∑ –≤—Å–µ—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã—Ö –ø–æ–ª–µ–π –∏ —É–∫–∞–∂–∏—Ç–µ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
–ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é:

```zig
const Threshold = struct {
    minimum: f32,
    maximum: f32,

    const default: Threshold = .{
        .minimum = 0.25,
        .maximum = 0.75,
    };
};
```

–ï—Å–ª–∏ –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è `struct` —Ç—Ä–µ–±—É–µ—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –±–µ–∑ –Ω–∞—Ä—É—à–µ–Ω–∏—è –∏–Ω–≤–∞—Ä–∏–∞–Ω—Ç–æ–≤
–¥–∞–Ω–Ω—ã—Ö, —Ç–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –º–µ—Ç–æ–¥ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–∏–Ω–∏–º–∞–µ—Ç —ç—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏ –∑–∞–ø–æ–ª–Ω—è–µ—Ç –æ—Å—Ç–∞–ª—å–Ω—ã–µ
–ø–æ–ª—è.

#### –í–Ω–µ—à–Ω—è—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

–°—Ç—Ä—É–∫—Ç—É—Ä–∞ `extern` –∏–º–µ–µ—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ C ABI –¥–ª—è —Ü–µ–ª–µ–≤–æ–≥–æ –æ–±—ä–µ–∫—Ç–∞.

–ï—Å–ª–∏ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è —á–µ—Ç–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏, `struct` - –ª—É—á—à–∏–π –≤—ã–±–æ—Ä, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –Ω–∞–∫–ª–∞–¥—ã–≤–∞–µ—Ç –º–µ–Ω—å—à–µ
–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –Ω–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä.

–°–º–æ—Ç—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª —É–ø–∞–∫–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∫–æ—Ç–æ—Ä–∞—è –∏–º–µ–µ—Ç ABI —Å–≤–æ–µ–≥–æ –±–∞–∑–æ–≤–æ–≥–æ —Ü–µ–ª–æ–≥–æ —á–∏—Å–ª–∞, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å
–ø–æ–ª–µ–∑–Ω–æ –¥–ª—è –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è —Ñ–ª–∞–≥–æ–≤.

#### –£–ø–∞–∫–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –æ–±—ã—á–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä, —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–º–µ—é—Ç –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏:

- –ü–æ–ª—è –æ—Å—Ç–∞—é—Ç—Å—è –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ, –æ—Ç –Ω–∞–∏–º–µ–Ω–µ–µ –∑–Ω–∞—á–∏–º–æ–≥–æ –∫ –Ω–∞–∏–±–æ–ª–µ–µ –∑–Ω–∞—á–∏–º–æ–º—É.
- –ú–µ–∂–¥—É –ø–æ–ª—è–º–∏ –Ω–µ—Ç –ø–∞–¥–¥–∏–Ω–≥–∞.
- **Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω–æ–π —à–∏—Ä–∏–Ω—ã, –∏ —Ö–æ—Ç—è –æ–±—ã—á–Ω–æ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ —Å–æ–¥–µ—Ä–∂–∞—â–∏–µ –º–µ–Ω–µ–µ 8 –±–∏—Ç, –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É
–∑–∞–Ω–∏–º–∞—é—Ç 1 –±–∞–π—Ç –ø–∞–º—è—Ç–∏, –≤ —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–∞—Ö –æ–Ω–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –∏–º–µ–Ω–Ω–æ —Å–≤–æ—é —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –ø–æ–ª—è –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Ä–æ–≤–Ω–æ
1 –±–∏—Ç.
- –ü–æ–ª–µ `enum` –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–æ–≤–Ω–æ —Å—Ç–æ–ª—å–∫–æ –∂–µ –±–∏—Ç–æ–≤–æ–π —à–∏—Ä–∏–Ω—ã, —Å–∫–æ–ª—å–∫–æ –∏ –µ–≥–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø —Ç–µ–≥–∞.
- –ü–æ–ª–µ —É–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Ä–æ–≤–Ω–æ —Å—Ç–æ–ª—å–∫–æ –∂–µ –±–∏—Ç–æ–≤–æ–π —à–∏—Ä–∏–Ω—ã, —Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å –Ω–∞–∏–±–æ–ª—å—à–µ–π
–±–∏—Ç–æ–≤–æ–π —à–∏—Ä–∏–Ω–æ–π.

–≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —É–ø–∞–∫–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–∂–µ—Ç —É—á–∞—Å—Ç–≤–æ–≤–∞—Ç—å –≤ `@bitCast` –∏–ª–∏ `@ptrCast` –¥–ª—è –ø–µ—Ä–µ–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –ø–∞–º—è—Ç–∏. –≠—Ç–æ
—Ä–∞–±–æ—Ç–∞–µ—Ç –¥–∞–∂–µ –≤ `comptime`:

```zig
const std = @import("std");
const native_endian = @import("builtin").target.cpu.arch.endian();
const expect = std.testing.expect;

const Full = packed struct {
    number: u16,
};
const Divided = packed struct {
    half1: u8,
    quarter3: u4,
    quarter4: u4,
};

test "@bitCast between packed structs" {
    try doTheTest();
    try comptime doTheTest();
}

fn doTheTest() !void {
    try expect(@sizeOf(Full) == 2);
    try expect(@sizeOf(Divided) == 2);
    const full = Full{ .number = 0x1234 };
    const divided: Divided = @bitCast(full);
    try expect(divided.half1 == 0x34);
    try expect(divided.quarter3 == 0x2);
    try expect(divided.quarter4 == 0x1);

    const ordered: [2]u8 = @bitCast(full);
    switch (native_endian) {
        .big => {
            try expect(ordered[0] == 0x12);
            try expect(ordered[1] == 0x34);
        },
        .little => {
            try expect(ordered[0] == 0x34);
            try expect(ordered[1] == 0x12);
        },
    }
}
```
```bash
$ zig test test_packed_structs.zig
1/1 test_packed_structs.test.@bitCast between packed structs...OK
All 1 tests passed.
```

–ò—Å—Ö–æ–¥–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∏–∑ –æ–±—â–µ–π —Ä–∞–∑—Ä—è–¥–Ω–æ—Å—Ç–∏ –ø–æ–ª–µ–π. –ü—Ä–∏ –∂–µ–ª–∞–Ω–∏–∏ –æ–Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å —è–≤–Ω–æ —É–∫–∞–∑–∞–Ω–æ –∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–æ –≤–æ
–≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:

```zig
test "missized packed struct" {
    const S = packed struct(u32) { a: u16, b: u8 };
    _ = S{ .a = 4, .b = 2 };
}
```
```bash
$ zig test test_missized_packed_struct.zig
doc/langref/test_missized_packed_struct.zig:2:29: error: backing integer type 'u32' has bit size 32 but the struct fields have a total bit size of 24
    const S = packed struct(u32) { a: u16, b: u8 };
                            ^~~

```

**Zig** –ø–æ–∑–≤–æ–ª—è–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∞–¥—Ä–µ—Å –ø–æ–ª—è –Ω–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω–æ–≥–æ –ø–æ –±–∞–π—Ç–∞–º:

```zig
const std = @import("std");
const expect = std.testing.expect;

const BitField = packed struct {
    a: u3,
    b: u3,
    c: u2,
};

var foo = BitField{
    .a = 1,
    .b = 2,
    .c = 3,
};

test "pointer to non-byte-aligned field" {
    const ptr = &foo.b;
    try expect(ptr.* == 2);
```
```bash
$ zig test test_pointer_to_non-byte_aligned_field.zig
1/1 test_pointer_to_non-byte_aligned_field.test.pointer to non-byte-aligned field...OK
All 1 tests passed.
```

–û–¥–Ω–∞–∫–æ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–æ–ª–µ –Ω–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω–æ–µ –ø–æ –±–∞–π—Ç–∞–º, –æ–±–ª–∞–¥–∞–µ—Ç –æ—Å–æ–±—ã–º–∏ —Å–≤–æ–π—Å—Ç–≤–∞–º–∏ –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–µ—Ä–µ–¥–∞–Ω, –∫–æ–≥–¥–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è
–æ–±—ã—á–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å:

```zig
const std = @import("std");
const expect = std.testing.expect;

const BitField = packed struct {
    a: u3,
    b: u3,
    c: u2,
};

var bit_field = BitField{
    .a = 1,
    .b = 2,
    .c = 3,
};

test "pointer to non-byte-aligned field" {
    try expect(bar(&bit_field.b) == 2);
}

fn bar(x: *const u3) u3 {
    return x.*;
}
```
```bash
$ zig test test_misaligned_pointer.zig
doc/langref/test_misaligned_pointer.zig:17:20: error: expected type '*const u3', found '*align(1:3:1) u3'
    try expect(bar(&bit_field.b) == 2);
                   ^~~~~~~~~~~~
doc/langref/test_misaligned_pointer.zig:17:20: note: pointer host size '1' cannot cast into pointer host size '0'
doc/langref/test_misaligned_pointer.zig:17:20: note: pointer bit offset '3' cannot cast into pointer bit offset '0'
doc/langref/test_misaligned_pointer.zig:20:11: note: parameter type declared here
fn bar(x: *const u3) u3 {
          ^~~~~~~~~
```

–í —ç—Ç–æ–º —Å–ª—É—á–∞–µ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—ã–∑–≤–∞–Ω–∞, –ø–æ—Å–∫–æ–ª—å–∫—É —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –ø–æ–ª–µ –Ω–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω–æ–µ –ø–æ ABI, —É–∫–∞–∑—ã–≤–∞–µ—Ç
–Ω–∞ —Å–º–µ—â–µ–Ω–∏–µ –≤ –±–∏—Ç–∞—Ö, –Ω–æ —Ñ—É–Ω–∫—Ü–∏—è –æ–∂–∏–¥–∞–µ—Ç —É–∫–∞–∑–∞—Ç–µ–ª—å, –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–π –ø–æ ABI.

–£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –ø–æ–ª—è –Ω–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–µ –ø–æ ABI, –∏–º–µ—é—Ç —Ç–æ—Ç –∂–µ –∞–¥—Ä–µ—Å, —á—Ç–æ –∏ –¥—Ä—É–≥–∏–µ –ø–æ–ª—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –∏—Ö –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ü–µ–ª–æ–≥–æ:

```zig
const std = @import("std");
const expect = std.testing.expect;

const BitField = packed struct {
    a: u3,
    b: u3,
    c: u2,
};

var bit_field = BitField{
    .a = 1,
    .b = 2,
    .c = 3,
};

test "pointers of sub-byte-aligned fields share addresses" {
    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.b));
    try expect(@intFromPtr(&bit_field.a) == @intFromPtr(&bit_field.c));
}
```
```bash
$ zig test test_packed_struct_field_address.zig
1/1 test_packed_struct_field_address.test.pointers of sub-byte-aligned fields share addresses...OK
All 1 tests passed.
```

–≠—Ç–æ –º–æ–∂–Ω–æ –Ω–∞–±–ª—é–¥–∞—Ç—å —Å –ø–æ–º–æ—â—å—é `@bitOffsetOf` –∏ `offsetOf`:

```zig
const std = @import("std");
const expect = std.testing.expect;

const BitField = packed struct {
    a: u3,
    b: u3,
    c: u2,
};

test "offsets of non-byte-aligned fields" {
    comptime {
        try expect(@bitOffsetOf(BitField, "a") == 0);
        try expect(@bitOffsetOf(BitField, "b") == 3);
        try expect(@bitOffsetOf(BitField, "c") == 6);

        try expect(@offsetOf(BitField, "a") == 0);
        try expect(@offsetOf(BitField, "b") == 0);
        try expect(@offsetOf(BitField, "c") == 0);
    }
}
```
```bash
$ zig test test_bitOffsetOf_offsetOf.zig
1/1 test_bitOffsetOf_offsetOf.test.offsets of non-byte-aligned fields...OK
All 1 tests passed.
```

–£–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–º–µ—é—Ç —Ç–æ –∂–µ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ, —á—Ç–æ –∏ –∏—Ö –∏—Å—Ö–æ–¥–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ, –æ–¥–Ω–∞–∫–æ –ø–µ—Ä–µ–Ω–∞—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞
—É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—Ç—å —ç—Ç–æ:

```zig
const std = @import("std");
const expect = std.testing.expect;

const S = packed struct {
    a: u32,
    b: u32,
};
test "overaligned pointer to packed struct" {
    var foo: S align(4) = .{ .a = 1, .b = 2 };
    const ptr: *align(4) S = &foo;
    const ptr_to_b: *u32 = &ptr.b;
    try expect(ptr_to_b.* == 2);
}
```
```bash
$ zig test test_overaligned_packed_struct.zig
1/1 test_overaligned_packed_struct.test.overaligned pointer to packed struct...OK
All 1 tests passed.
```

–¢–∞–∫–∂–µ –º–æ–∂–Ω–æ –Ω–∞—Å—Ç—Ä–æ–∏—Ç—å –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ –ø–æ–ª–µ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã:

```zig
const std = @import("std");
const expectEqual = std.testing.expectEqual;

test "aligned struct fields" {
    const S = struct {
        a: u32 align(2),
        b: u32 align(64),
    };
    var foo = S{ .a = 1, .b = 2 };

    try expectEqual(64, @alignOf(S));
    try expectEqual(*align(2) u32, @TypeOf(&foo.a));
    try expectEqual(*align(64) u32, @TypeOf(&foo.b));
}
```
```bash
$ zig test test_aligned_struct_fields.zig
1/1 test_aligned_struct_fields.test.aligned struct fields...OK
All 1 tests passed.
```

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä —Å `volatile` –ø—Ä–æ–±–ª–µ–º–∞—Ç–∏—á–Ω–æ –∏ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –æ—à–∏–±–∫–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –≤ –±—É–¥—É—â–µ–º. –î–ª—è
–ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–¥—Ä–æ–±–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ–± —ç—Ç–æ–º –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å –Ω–∞ —ç—Ç–æ—Ç –≤—ã–ø—É—Å–∫. –ü–æ—Å–ª–µ —É—Å—Ç—Ä–∞–Ω–µ–Ω–∏—è —ç—Ç–æ–π –ø—Ä–æ–±–ª–µ–º—ã –æ–±–Ω–æ–≤–∏—Ç–µ —ç—Ç–∏
–¥–æ–∫—É–º–µ–Ω—Ç—ã, –¥–æ–±–∞–≤–∏–≤ –≤ –Ω–∏—Ö —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä —Å –ø–æ–º–æ—â—å—é MMIO (–ø—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –¥–ª—è
–∏–∑–º–µ–Ω—á–∏–≤—ã—Ö —É–ø–∞–∫–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä). –ù–µ –≤–æ–ª–Ω—É–π—Ç–µ—Å—å, –≤ zig –±—É–¥–µ—Ç —Ö–æ—Ä–æ—à–µ–µ —Ä–µ—à–µ–Ω–∏–µ –¥–ª—è —ç—Ç–æ–≥–æ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è.


#### –ò–º–µ–Ω–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞

–ü–æ—Å–∫–æ–ª—å–∫—É –≤—Å–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∞–Ω–æ–Ω–∏–º–Ω—ã, **Zig** –≤—ã–≤–æ–¥–∏—Ç –∏–º—è —Ç–∏–ø–∞ –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –ø—Ä–∞–≤–∏–ª.

- –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –µ–π –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –∏–º—è –≤ —á–µ—Å—Ç—å —ç—Ç–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π.
- –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ `return`, –µ–π –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –∏–º—è –≤ —á–µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Å
—Å–µ—Ä–∏–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
- –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø–æ–ª—É—á–∞–µ—Ç —Ç–∞–∫–æ–µ –∏–º—è, –∫–∞–∫ (`filename.funcname.__struct_ID`).
- –ï—Å–ª–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –æ–±—ä—è–≤–ª–µ–Ω–∞ –≤–Ω—É—Ç—Ä–∏ –¥—Ä—É–≥–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –æ–Ω–∞ –ø–æ–ª—É—á–∞–µ—Ç –∏–º—è –≤ —á–µ—Å—Ç—å —Ä–æ–¥–∏—Ç–µ–ª—å—Å–∫–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, —Ç–∞–∫ –∏ –≤ —á–µ—Å—Ç—å
–∏–º–µ–Ω–∏ –ø–æ–ª—É—á–µ–Ω–Ω–æ–≥–æ –≤ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–∏ —Å –ø—Ä–µ–¥—ã–¥—É—â–∏–º–∏ –ø—Ä–∞–≤–∏–ª–∞–º–∏, —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–º–∏ —Ç–æ—á–∫–æ–π.

```zig
const std = @import("std");

pub fn main() void {
    const Foo = struct {};
    std.debug.print("variable: {s}\n", .{@typeName(Foo)});
    std.debug.print("anonymous: {s}\n", .{@typeName(struct {})});
    std.debug.print("function: {s}\n", .{@typeName(List(i32))});
}

fn List(comptime T: type) type {
    return struct {
        x: T,
    };
}
```
```bash
$ zig build-exe struct_name.zig
$ ./struct_name
variable: struct_name.main.Foo
anonymous: struct_name.main__struct_3331
function: struct_name.List(i32)
```

#### –ê–Ω–æ–Ω–∏–º–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–µ –ª–∏—Ç–µ—Ä–∞–ª—ã

**Zig** –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–µ —É–∫–∞–∑—ã–≤–∞—Ç—å —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π —Ç–∏–ø –ª–∏—Ç–µ—Ä–∞–ª–∞. –ü—Ä–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã–π
–ª–∏—Ç–µ—Ä–∞–ª –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ —Å–æ–∑–¥–∞—Å—Ç —ç–∫–∑–µ–º–ø–ª—è—Ä –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –±–µ–∑ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Point = struct { x: i32, y: i32 };

test "anonymous struct literal" {
    const pt: Point = .{
        .x = 13,
        .y = 67,
    };
    try expect(pt.x == 13);
    try expect(pt.y == 67);
}
```
```bash
$ zig test test_struct_result.zig
1/1 test_struct_result.test.anonymous struct literal...OK
All 1 tests passed.
```

–ú–æ–∂–Ω–æ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–∏–ø —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –ó–¥–µ—Å—å —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Ç–∏–ø, –∏ –ø–æ—ç—Ç–æ–º—É **Zig** –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç —Ç–∏–ø:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "fully anonymous struct" {
    try check(.{
        .int = @as(u32, 1234),
        .float = @as(f64, 12.34),
        .b = true,
        .s = "hi",
    });
}

fn check(args: anytype) !void {
    try expect(args.int == 1234);
    try expect(args.float == 12.34);
    try expect(args.b);
    try expect(args.s[0] == 'h');
    try expect(args.s[1] == 'i');
}
```
```bash
$ zig test test_anonymous_struct.zig
1/1 test_anonymous_struct.test.fully anonymous struct...OK
All 1 tests passed.
```

#### –ö–æ—Ä—Ç–µ–∂–∏

–ê–Ω–æ–Ω–∏–º–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å—Å—è –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è –∏–º–µ–Ω –ø–æ–ª–µ–π –∏ –Ω–∞–∑—ã–≤–∞—é—Ç—Å—è "–∫–æ—Ä—Ç–µ–∂–∞–º–∏".

–ü–æ–ª—è –Ω–µ—è–≤–Ω–æ –∏–º–µ–Ω—É—é—Ç—Å—è —á–∏—Å–ª–∞–º–∏, –Ω–∞—á–∏–Ω–∞—é—â–∏–º–∏—Å—è —Å 0. –ü–æ—Å–∫–æ–ª—å–∫—É –∏—Ö –∏–º–µ–Ω–∞ —è–≤–ª—è—é—Ç—Å—è —Ü–µ–ª—ã–º–∏ —á–∏—Å–ª–∞–º–∏, –∫ –Ω–∏–º –Ω–µ–ª—å–∑—è –ø–æ–ª—É—á–∏—Ç—å
–¥–æ—Å—Ç—É–ø —Å –ø–æ–º–æ—â—å—é `.` —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –≤–∫–ª—é—á–∞–µ—Ç –≤ —Å–µ–±—è `@""`. –ò–º–µ–Ω–∞ –≤–Ω—É—Ç—Ä–∏ `@""` –≤—Å–µ–≥–¥–∞ —Ä–∞—Å–ø–æ–∑–Ω–∞—é—Ç—Å—è –∫–∞–∫
–∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã.

–ö–∞–∫ –∏ –º–∞—Å—Å–∏–≤—ã, –∫–æ—Ä—Ç–µ–∂–∏ –∏–º–µ—é—Ç –ø–æ–ª–µ `.len` –∏ –º–æ–≥—É—Ç –∏–Ω–¥–µ–∫—Å–∏—Ä–æ–≤–∞—Ç—å—Å—è (–ø—Ä–∏ —É—Å–ª–æ–≤–∏–∏, —á—Ç–æ –∏–Ω–¥–µ–∫—Å –∏–∑–≤–µ—Å—Ç–µ–Ω –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏)
–∏ –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º–∏ `++` –∏ `**`. –ò —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–æ–∏—Ç–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã —Å –ø–æ–º–æ—â—å—é `inline for`.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "tuple" {
    const values = .{
        @as(u32, 1234),
        @as(f64, 12.34),
        true,
        "hi",
    } ++ .{false} ** 2;
    try expect(values[0] == 1234);
    try expect(values[4] == false);
    inline for (values, 0..) |v, i| {
        if (i != 2) continue;
        try expect(v);
    }
    try expect(values.len == 6);
    try expect(values.@"3"[0] == 'h');
}
```
```bash
$ zig test test_tuples.zig
1/1 test_tuples.test.tuple...OK
All 1 tests passed.
```

------------
### –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ

```zig
const expect = @import("std").testing.expect;
const mem = @import("std").mem;

// –û–±—ä—è–≤–ª–µ–Ω–∏–µ  –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.
const Type = enum {
    ok,
    not_ok,
};

// –û–±—ä—è–≤–ª–µ–Ω–∏–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.
const c = Type.ok;

// –ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –ø–æ—Ä—è–¥–∫–æ–≤–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –≤—ã –º–æ–∂–µ—Ç–µ —É–∫–∞–∑–∞—Ç—å —Ç–∏–ø —Ç–µ–≥–∞.
const Value = enum(u2) {
    zero,
    one,
    two,
};
// –¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–±–∏—Ä–∞—Ç—å –º–µ–∂–¥—É u2 –∏ –∑–Ω–∞—á–µ–Ω–∏–µ–º.
// –ü–æ—Ä—è–¥–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è —Å 0, —É–≤–µ–ª–∏—á–∏–≤–∞—è—Å—å –Ω–∞ 1 –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞.
test "enum ordinal value" {
    try expect(@intFromEnum(Value.zero) == 0);
    try expect(@intFromEnum(Value.one) == 1);
    try expect(@intFromEnum(Value.two) == 2);
}

// –í—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ—Ä—è–¥–∫–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.
const Value2 = enum(u32) {
    hundred = 100,
    thousand = 1000,
    million = 1000000,
};
test "set enum ordinal value" {
    try expect(@intFromEnum(Value2.hundred) == 100);
    try expect(@intFromEnum(Value2.thousand) == 1000);
    try expect(@intFromEnum(Value2.million) == 1000000);
}

// –í—ã —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å —Ç–æ–ª—å–∫–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è.
const Value3 = enum(u4) {
    a,
    b = 8,
    c,
    d = 4,
    e,
};
test "enum implicit ordinal values and overridden values" {
    try expect(@intFromEnum(Value3.a) == 0);
    try expect(@intFromEnum(Value3.b) == 8);
    try expect(@intFromEnum(Value3.c) == 9);
    try expect(@intFromEnum(Value3.d) == 4);
    try expect(@intFromEnum(Value3.e) == 5);
}

// –£ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –º–æ–≥—É—Ç –±—ã—Ç—å –º–µ—Ç–æ–¥—ã, —Ç–∞–∫–∏–µ –∂–µ –∫–∞–∫ —É —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π.
// –ü–µ—Ä–µ—á–∏—Å–ª–∏–º—ã–µ –º–µ—Ç–æ–¥—ã –Ω–µ —è–≤–ª—è—é—Ç—Å—è –æ—Å–æ–±—ã–º–∏, –æ–Ω–∏ –ø—Ä–æ—Å—Ç–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω—ã –≤ –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–µ –∏–º–µ–Ω
// —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—ã –º–æ–∂–µ—Ç–µ –≤—ã–∑—ã–≤–∞—Ç—å —Å –ø–æ–º–æ—â—å—é —Ç–æ—á–µ—á–Ω–æ–≥–æ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞.
const Suit = enum {
    clubs,
    spades,
    diamonds,
    hearts,

    pub fn isClubs(self: Suit) bool {
        return self == Suit.clubs;
    }
};
test "enum method" {
    const p = Suit.spades;
    try expect(!p.isClubs());
}

// An enum can be switched upon.
const Foo = enum {
    string,
    number,
    none,
};
test "enum switch" {
    const p = Foo.number;
    const what_is_it = switch (p) {
        Foo.string => "this is a string",
        Foo.number => "this is a number",
        Foo.none => "this is a none",
    };
    try expect(mem.eql(u8, what_is_it, "this is a number"));
}

// @typeInfo –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–º—É —Ç–∏–ø—É —Ç–µ–≥–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.
const Small = enum {
    one,
    two,
    three,
    four,
};
test "std.meta.Tag" {
    try expect(@typeInfo(Small).Enum.tag_type == u2);
}

// @typeInfo —Å–æ–æ–±—â–∞–µ—Ç –Ω–∞–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ–ª–µ–π –∏ –∏—Ö –Ω–∞–∑–≤–∞–Ω–∏—è:
test "@typeInfo" {
    try expect(@typeInfo(Small).Enum.fields.len == 4);
    try expect(mem.eql(u8, @typeInfo(Small).Enum.fields[1].name, "two"));
}

// @tagName –¥–∞–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ [:0]const u8 –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è:
test "@tagName" {
    try expect(mem.eql(u8, @tagName(Small.three), "three"));
}
```
```bash
$ zig test test_enums.zig
1/8 test_enums.test.enum ordinal value...OK
2/8 test_enums.test.set enum ordinal value...OK
3/8 test_enums.test.enum implicit ordinal values and overridden values...OK
4/8 test_enums.test.enum method...OK
5/8 test_enums.test.enum switch...OK
6/8 test_enums.test.std.meta.Tag...OK
7/8 test_enums.test.@typeInfo...OK
8/8 test_enums.test.@tagName...OK
All 8 tests passed.
```

#### –í–Ω–µ—à–Ω–µ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ

–ü–æ-—É–º–æ–ª—á–∞–Ω–∏—é —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π —Å C ABI –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è:

```zig
const Foo = enum { a, b, c };
export fn entry(foo: Foo) void {
    _ = foo;
}
```
```bash
$ zig build-obj enum_export_error.zig
doc/langref/enum_export_error.zig:2:17: error: parameter of type 'enum_export_error.Foo' not allowed in function with calling convention 'C'
export fn entry(foo: Foo) void {
                ^~~~~~~~
doc/langref/enum_export_error.zig:2:17: note: enum tag type 'u2' is not extern compatible
doc/langref/enum_export_error.zig:2:17: note: only integers with 0, 8, 16, 32, 64 and 128 bits are extern compatible
doc/langref/enum_export_error.zig:1:13: note: enum declared here
const Foo = enum { a, b, c };
            ^~~~~~~~~~~~~~~~
```

–î–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è, —Å–æ–≤–º–µ—Å—Ç–∏–º–æ–≥–æ —Å C-ABI, —É–∫–∞–∂–∏—Ç–µ —è–≤–Ω—ã–π —Ç–∏–ø —Ç–µ–≥–∞ –¥–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è:

```zig
const Foo = enum(c_int) { a, b, c };
export fn entry(foo: Foo) void {
    _ = foo;
}
```
```bash
$ zig build-obj enum_export.zig
```

#### –õ–∏—Ç–µ—Ä–∞–ª—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è

–õ–∏—Ç–µ—Ä–∞–ª—ã –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –ø–æ–∑–≤–æ–ª—è—é—Ç —É–∫–∞–∑—ã–≤–∞—Ç—å –∏–º—è –ø–æ–ª—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è —Ç–∏–ø–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Color = enum {
    auto,
    off,
    on,
};

test "enum literals" {
    const color1: Color = .auto;
    const color2 = Color.auto;
    try expect(color1 == color2);
}

test "switch using enum literals" {
    const color = Color.on;
    const result = switch (color) {
        .auto => false,
        .on => true,
        .off => false,
    };
    try expect(result);
}
```
```bash
$ zig test test_enum_literals.zig
1/2 test_enum_literals.test.enum literals...OK
2/2 test_enum_literals.test.switch using enum literals...OK
All 2 tests passed.
```

#### –ù–µ–∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–µ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ

–ù–µ–∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–µ–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –º–æ–∂–Ω–æ —Å–æ–∑–¥–∞—Ç—å –¥–æ–±–∞–≤–∏–≤ –∑–∞–≤–µ—Ä—à–∞—é—â–µ–µ –ø–æ–ª–µ `_`. –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ —É–∫–∞–∑—ã–≤–∞—Ç—å —Ç–∏–ø —Ç–µ–≥–∞ –∏ –Ω–µ –º–æ–∂–µ—Ç
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.

`@enumFromInt` –≤ –Ω–µ–∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–µ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç —Å–µ–º–∞–Ω—Ç–∏–∫—É –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ `@intCast` –¥–ª—è —Ç–∏–ø–∞ —Ç–µ–≥–∞ integer, –Ω–æ –ø–æ–º–∏–º–æ
—ç—Ç–æ–≥–æ –≤—Å–µ–≥–¥–∞ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —á–µ—Ç–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–º—É –∑–Ω–∞—á–µ–Ω–∏—é –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.

–ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –≤ –Ω–µ–ø–æ–ª–Ω–æ–º –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–∏ –º–æ–∂–µ—Ç –≤–∫–ª—é—á–∞—Ç—å –∑–Ω–∞–∫ `_`–≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã —ç–ª–µ–º–µ–Ω—Ç—É `else`. –° –ø–æ–º–æ—â—å—é –∑–Ω–∞–∫–∞ `_`
–∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –≤—ã–¥–∞–µ—Ç –æ—à–∏–±–∫—É –µ—Å–ª–∏ –≤—Å–µ –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –∏–º–µ–Ω–∞ —Ç–µ–≥–æ–≤ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–µ–º.

```zig
const std = @import("std");
const expect = std.testing.expect;

const Number = enum(u8) {
    one,
    two,
    three,
    _,
};

test "switch on non-exhaustive enum" {
    const number = Number.one;
    const result = switch (number) {
        .one => true,
        .two, .three => false,
        _ => false,
    };
    try expect(result);
    const is_one = switch (number) {
        .one => true,
        else => false,
    };
    try expect(is_one);
}
```
```bash
$ zig test test_switch_non-exhaustive.zig
1/1 test_switch_non-exhaustive.test.switch on non-exhaustive enum...OK
All 1 tests passed.
```

------------
### –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ

–ü—Ä–æ—Å—Ç–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –Ω–∞–±–æ—Ä –≤–æ–∑–º–æ–∂–Ω—ã—Ö —Ç–∏–ø–æ–≤ –∑–Ω–∞—á–µ–Ω–∏–π –≤ –≤–∏–¥–µ —Å–ø–∏—Å–∫–∞ –ø–æ–ª–µ–π. –û–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∞–∫—Ç–∏–≤–Ω—ã–º
—Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –ø–æ–ª–µ. –ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å—Ç—ã—Ö –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç–∏ –Ω–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è. –ü—Ä–æ—Å—Ç—ã–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ–ª—å–∑—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
–¥–ª—è –ø–µ—Ä–µ–∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –ø–∞–º—è—Ç–∏. –î–ª—è —ç—Ç–æ–≥–æ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `@ptrCast` –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –≤–Ω–µ—à–Ω–µ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–ª–∏ —É–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–µ
–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä—ã–µ –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É—é—Ç —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏. –î–æ—Å—Ç—É–ø –∫ –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–º—É –ø–æ–ª—é - —ç—Ç–æ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ,
–ø—Ä–æ–≤–µ—Ä—è–µ–º–æ–µ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:

```zig
const Payload = union {
    int: i64,
    float: f64,
    boolean: bool,
};
test "simple union" {
    var payload = Payload{ .int = 1234 };
    payload.float = 12.34;
}
```
```bash
$ zig test test_wrong_union_access.zig
1/1 test_wrong_union_access.test.simple union...thread 3579408 panic: access of union field 'float' while field 'int' is active
/home/andy/src/zig/doc/langref/test_wrong_union_access.zig:8:12: 0x103ce87 in test.simple union (test)
    payload.float = 12.34;
           ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x1048070 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103e08b in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103d419 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103cf81 in _start (test)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/bb9968225995fac0bbc9f2116e8583c2/test
```

–í—ã –º–æ–∂–µ—Ç–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–µ –ø–æ–ª–µ, –Ω–∞–∑–Ω–∞—á–∏–≤ –≤—Å–µ–º—É –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—é:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Payload = union {
    int: i64,
    float: f64,
    boolean: bool,
};
test "simple union" {
    var payload = Payload{ .int = 1234 };
    try expect(payload.int == 1234);
    payload = Payload{ .float = 12.34 };
    try expect(payload.float == 12.34);
}
```
```bash
$ zig test test_simple_union.zig
1/1 test_simple_union.test.simple union...OK
All 1 tests passed.
```

–ß—Ç–æ–±—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å switch —Å –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ–º, —ç—Ç–æ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Ç–µ–≥–æ–º.

–ß—Ç–æ–±—ã –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –µ—Å–ª–∏ —Ç–µ–≥ —è–≤–ª—è–µ—Ç—Å—è –∏–º–µ–Ω–µ–º –∏–∑–≤–µ—Å—Ç–Ω—ã–º –≤ comptime, —Å–º–æ—Ç—Ä–∏—Ç–µ `@unionInit`.

#### –¢—ç–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ

–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω—ã —Å —Ç–∏–ø–æ–º —Ç–µ–≥–∞ enum. –≠—Ç–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –≤ –ø–æ–º–µ—á–µ–Ω–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –µ–≥–æ —Å –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏ switch.

```zig
const std = @import("std");
const expect = std.testing.expect;

const ComplexTypeTag = enum {
    ok,
    not_ok,
};
const ComplexType = union(ComplexTypeTag) {
    ok: u8,
    not_ok: void,
};

test "switch on tagged union" {
    const c = ComplexType{ .ok = 42 };
    try expect(@as(ComplexTypeTag, c) == ComplexTypeTag.ok);

    switch (c) {
        ComplexTypeTag.ok => |value| try expect(value == 42),
        ComplexTypeTag.not_ok => unreachable,
    }
}

test "get tag type" {
    try expect(std.meta.Tag(ComplexType) == ComplexTypeTag);
}
```
```bash
$ zig test test_tagged_union.zig
1/2 test_tagged_union.test.switch on tagged union...OK
2/2 test_tagged_union.test.get tag type...OK
All 2 tests passed.
```

–ß—Ç–æ–±—ã –∏–∑–º–µ–Ω–∏—Ç—å –ø–æ–ª–µ–∑–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É —Ç–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ switch, –ø–æ–º–µ—Å—Ç–∏—Ç–µ —Å–∏–º–≤–æ–ª `*` –ø–µ—Ä–µ–¥ –∏–º–µ–Ω–µ–º
–ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π —á—Ç–æ–±—ã –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –µ–≥–æ –≤ —É–∫–∞–∑–∞—Ç–µ–ª—å:

```zig
const std = @import("std");
const expect = std.testing.expect;

const ComplexTypeTag = enum {
    ok,
    not_ok,
};
const ComplexType = union(ComplexTypeTag) {
    ok: u8,
    not_ok: void,
};

test "modify tagged union in switch" {
    var c = ComplexType{ .ok = 42 };

    switch (c) {
        ComplexTypeTag.ok => |*value| value.* += 1,
        ComplexTypeTag.not_ok => unreachable,
    }

    try expect(c.ok == 43);
}
```
```bash
$ zig test test_switch_modify_tagged_union.zig
1/1 test_switch_modify_tagged_union.test.modify tagged union in switch...OK
All 1 tests passed.
```

–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω—ã –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ —Ç–µ–≥–∞ enum. –ö—Ä–æ–º–µ —Ç–æ–≥–æ —É –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π –º–æ–≥—É—Ç –±—ã—Ç—å —Ç–∞–∫–∏–µ –∂–µ –º–µ—Ç–æ–¥—ã –∫–∞–∫
—É —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π.

```zig
const std = @import("std");
const expect = std.testing.expect;

const Variant = union(enum) {
    int: i32,
    boolean: bool,

    // void can be omitted when inferring enum tag type.
    none,

    fn truthy(self: Variant) bool {
        return switch (self) {
            Variant.int => |x_int| x_int != 0,
            Variant.boolean => |x_bool| x_bool,
            Variant.none => false,
        };
    }
};

test "union method" {
    var v1 = Variant{ .int = 1 };
    var v2 = Variant{ .boolean = false };

    try expect(v1.truthy());
    try expect(!v2.truthy());
}
```
```bash
$ zig test test_union_method.zig
1/1 test_union_method.test.union method...OK
All 1 tests passed.
```

`@tagName` –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∑–Ω–∞—á–µ–Ω–∏—è comptime `[:0]const u8`, –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—é—â–µ–≥–æ –∏–º—è –ø–æ–ª—è:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Small2 = union(enum) {
    a: i32,
    b: bool,
    c: u8,
};
test "@tagName" {
    try expect(std.mem.eql(u8, @tagName(Small2.a), "a"));
}
```
```bash
$ zig test test_tagName.zig
1/1 test_tagName.test.@tagName...OK
All 1 tests passed.
```

#### –í–Ω–µ—à–µ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ

–í–Ω–µ—à–Ω–µ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–º–µ–µ—Ç —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø–∞–º—è—Ç–∏ –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ —Å–æ–≤–º–µ—Å—Ç–∏–º—É—é —Å —Ü–µ–ª–µ–≤—ã–º C ABI.

#### –£–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ

–£–ø–∞–∫–æ–≤–∞–Ω–Ω–æ–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ –∏–º–µ–µ—Ç —á–µ—Ç–∫–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≤ –ø–∞–º—è—Ç–∏ –∏ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–∫–ª—é—á–µ–Ω–æ –≤ —É–ø–∞–∫–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É.

#### Anonymous Union Literals

–°–∏–Ω—Ç–∞–∫—Å–∏—Å –∞–Ω–æ–Ω–∏–º–Ω—ã—Ö —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤ –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π –±–µ–∑ —É–∫–∞–∑–∞–Ω–∏—è —Ç–∏–ø–∞:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Number = union {
    int: i32,
    float: f64,
};

test "anonymous union literal syntax" {
    const i: Number = .{ .int = 42 };
    const f = makeNumber();
    try expect(i.int == 42);
    try expect(f.float == 12.34);
}

fn makeNumber() Number {
    return .{ .float = 12.34 };
}
```
```bash
 zig test test_anonymous_union.zig
1/1 test_anonymous_union.test.anonymous union literal syntax...OK
All 1 tests passed.
```

------------
### Opaque

`opaque {}` –æ–±—ä—è–≤–ª—è–µ—Ç –Ω–æ–≤—ã–π —Ç–∏–ø —Å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–º (–Ω–æ –Ω–µ–Ω—É–ª–µ–≤—ã–º) —Ä–∞–∑–º–µ—Ä–æ–º –∏ –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–Ω–∏–µ–º. –û–Ω –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–∞–∫–∏–µ –∂–µ
–æ–±—ä—è–≤–ª–µ–Ω–∏—è, –∫–∞–∫ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã, –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è.

–û–±—ã—á–Ω–æ —ç—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–±–µ—Å–ø–µ—á–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Ç–∏–ø–æ–≤ –ø—Ä–∏ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–∏ —Å –∫–æ–¥–æ–º –Ω–∞ C, –∫–æ—Ç–æ—Ä—ã–π –Ω–µ —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –¥–µ—Ç–∞–ª–∏
—Å—Ç—Ä—É–∫—Ç—É—Ä—ã.

–ü—Ä–∏–º–µ—Ä:
```zig
const Derp = opaque {};
const Wat = opaque {};

extern fn bar(d: *Derp) void;
fn foo(w: *Wat) callconv(.C) void {
    bar(w);
}

test "call foo" {
    foo(undefined);
}
```
```bash
$ zig test test_opaque.zig
doc/langref/test_opaque.zig:6:9: error: expected type '*test_opaque.Derp', found '*test_opaque.Wat'
    bar(w);
        ^
doc/langref/test_opaque.zig:6:9: note: pointer type child 'test_opaque.Wat' cannot cast into pointer type child 'test_opaque.Derp'
doc/langref/test_opaque.zig:2:13: note: opaque declared here
const Wat = opaque {};
            ^~~~~~~~~
doc/langref/test_opaque.zig:1:14: note: opaque declared here
const Derp = opaque {};
             ^~~~~~~~~
doc/langref/test_opaque.zig:4:18: note: parameter type declared here
extern fn bar(d: *Derp) void;
                 ^~~~~
referenced by:
    test.call foo: doc/langref/test_opaque.zig:10:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces

```

------------
### –ë–ª–æ–∫–∏

–ë–ª–æ–∫–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –¥–ª—è –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –æ–±–ª–∞—Å—Ç–∏ –¥–µ–π—Å—Ç–≤–∏—è –æ–±—ä—è–≤–ª–µ–Ω–∏–π –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö:

```zig
test "access variable after block scope" {
    {
        var x: i32 = 1;
        _ = &x;
    }
    x += 1;
}
```
```bash
$ zig test test_blocks.zig
doc/langref/test_blocks.zig:6:5: error: use of undeclared identifier 'x'
    x += 1;
    ^
```

–ë–ª–æ–∫–∏ - —ç—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –ü—Ä–∏ –Ω–∞–ª–∏—á–∏–∏ –º–µ—Ç–∫–∏ `break` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ –±–ª–æ–∫–∞:
```zig
const std = @import("std");
const expect = std.testing.expect;

test "labeled break from labeled block expression" {
    var y: i32 = 123;

    const x = blk: {
        y += 1;
        break :blk y;
    };
    try expect(x == 124);
    try expect(y == 124);
}
```
```bash
$ zig test test_labeled_break.zig
1/1 test_labeled_break.test.labeled break from labeled block expression...OK
All 1 tests passed.
```

–ó–¥–µ—Å—å `blk` –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±—ã–º –∏–º–µ–Ω–µ–º.

#### –ó–∞—Ç–µ–Ω–µ–Ω–∏–µ

–ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞–º –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ —Ä–∞–∑—Ä–µ—à–∞–µ—Ç—Å—è "—Å–∫—Ä—ã–≤–∞—Ç—å" –¥—Ä—É–≥–∏–µ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä—ã –∏—Å–ø–æ–ª—å–∑—É—è –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –∏–º—è:
```zig
const pi = 3.14;

test "inside test block" {
    // –î–∞–≤–∞–π—Ç–µ –¥–∞–∂–µ –∑–∞–π–¥–µ–º –≤ –¥—Ä—É–≥–æ–π –±–ª–æ–∫
    {
        var pi: i32 = 1234;
    }
}
```
```bash
$ zig test test_shadowing.zig
doc/langref/test_shadowing.zig:6:13: error: local variable shadows declaration of 'pi'
        var pi: i32 = 1234;
            ^~
doc/langref/test_shadowing.zig:1:1: note: declared here
const pi = 3.14;
^~~~~~~~~~~~~~~
```

–ò–∑-–∑–∞ —ç—Ç–æ–≥–æ, –∫–æ–≥–¥–∞ –≤—ã —á–∏—Ç–∞–µ—Ç–µ **Zig**-–∫–æ–¥ –≤—ã –≤—Å–µ–≥–¥–∞ –º–æ–∂–µ—Ç–µ –ø–æ–ª–æ–∂–∏—Ç—å—Å—è –Ω–∞ —Ç–æ, —á—Ç–æ –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –±—É–¥–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ
–æ–∑–Ω–∞—á–∞—Ç—å –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–π –æ–±–ª–∞—Å—Ç–∏. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –∏–º—è,
–µ—Å–ª–∏ –æ–±–ª–∞—Å—Ç–∏ —Ä–∞–∑–ª–∏—á–Ω—ã:

```zig
test "separate scopes" {
    {
        const pi = 3.14;
        _ = pi;
    }
    {
        var pi: bool = true;
        _ = &pi;
    }
}
```
```bash
$ zig test test_scopes.zig
1/1 test_scopes.test.separate scopes...OK
All 1 tests passed.
```

#### –ü—É—Å—Ç—ã–µ –±–ª–æ–∫–∏

–ü—É—Å—Ç–æ–π –±–ª–æ–∫ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–µ–Ω `void{}`:

```zig
const std = @import("std");
const expect = std.testing.expect;

test {
    const a = {};
    const b = void{};
    try expect(@TypeOf(a) == void);
    try expect(@TypeOf(b) == void);
    try expect(a == b);
}
```
```bash
$ zig test test_empty_block.zig
1/1 test_empty_block.test_0...OK
All 1 tests passed.
```

------------
### Switch

```zig
const std = @import("std");
const builtin = @import("builtin");
const expect = std.testing.expect;

test "switch simple" {
    const a: u64 = 10;
    const zz: u64 = 103;

    // –í—Å–µ –≤–µ—Ç–≤–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è switch –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –∫ –æ–±—â–µ–º—É —Ç–∏–ø—É.
    // –ü–µ—Ä–µ—Ö–æ–¥—ã –º–µ–∂–¥—É –≤–µ—Ç–≤—è–º–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω—ã —Å –æ—à–∏–±–∫–∞–º–∏. –ï—Å–ª–∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Å –æ—à–∏–±–∫–∞–º–∏, –æ–±—ä–µ–¥–∏–Ω–∏—Ç–µ
    // –≤–∞—Ä–∏–∞–Ω—Ç—ã –∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ if.
    const b = switch (a) {
        // –ù–µ—Å–∫–æ–ª—å–∫–æ –æ–±—Ä–∞—â–µ–Ω–∏–π –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é ','
        1, 2, 3 => 0,

        // –î–∏–∞–ø–∞–∑–æ–Ω—ã –º–æ–≥—É—Ç –±—ã—Ç—å –∑–∞–¥–∞–Ω—ã —Å –ø–æ–º–æ—â—å—é ... —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞. –û–Ω–∏ —è–≤–ª—è—é—Ç—Å—è –≤—Å–µ–æ–±—ä–µ–º–ª—é—â–∏–º–∏ —Å –æ–±–æ–∏—Ö –∫–æ–Ω—Ü–æ–≤.
        5...100 => 1,

        // –í–µ—Ç–≤–∏ –º–æ–≥—É—Ç –±—ã—Ç—å —Å–∫–æ–ª—å —É–≥–æ–¥–Ω–æ —Å–ª–æ–∂–Ω—ã–º–∏.
        101 => blk: {
            const c: u64 = 5;
            break :blk c * 2 + 1;
        },

        // –í–∫–ª—é—á–µ–Ω–∏–µ –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã—Ö –≤—ã—Ä–∞–∂–µ–Ω–∏–π –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –¥–æ —Ç–µ—Ö –ø–æ—Ä, –ø–æ–∫–∞
        // –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
        zz => zz,
        blk: {
            const d: u32 = 5;
            const e: u32 = 100;
            break :blk d + e;
        } => 107,

        // –í–µ—Ç–≤—å else –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ, —á—Ç–æ –µ—â–µ –Ω–µ –∑–∞—Ö–≤–∞—á–µ–Ω–æ.
        // –í–µ—Ç–≤–∏ else —è–≤–ª—è—é—Ç—Å—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º–∏, –µ—Å–ª–∏ –Ω–µ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –≤–µ—Å—å –¥–∏–∞–ø–∞–∑–æ–Ω –∑–Ω–∞—á–µ–Ω–∏–π.
        else => 9,
    };

    try expect(b == 1);
}

// –í—ã—Ä–∞–∂–µ–Ω–∏—è switch –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤–Ω–µ —Ñ—É–Ω–∫—Ü–∏–∏:
const os_msg = switch (builtin.target.os.tag) {
    .linux => "we found a linux user",
    else => "not a linux user",
};

// –í–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã switch –Ω–µ—è–≤–Ω–æ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
// –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –µ—Å–ª–∏ —Ü–µ–ª–µ–≤–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏–∑–≤–µ—Å—Ç–Ω–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
test "switch inside function" {
    switch (builtin.target.os.tag) {
        .fuchsia => {
            // –í –æ–ø–µ—Ä–∞—Ü–∏–æ–Ω–Ω–æ–π —Å–∏—Å—Ç–µ–º–µ, –æ—Ç–ª–∏—á–Ω–æ–π –æ—Ç fuchsia –±–ª–æ–∫ –¥–∞–∂–µ –Ω–µ –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è,
            // –ø–æ—ç—Ç–æ–º—É —ç—Ç–∞ –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –Ω–µ –∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è.
            // –í fuchsia —ç—Ç–∞ –æ—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –±—ã–ª–∞ –±—ã –∑–∞–ø—É—â–µ–Ω–∞.
            @compileError("fuchsia not supported");
        },
        else => {},
    }
}
```
```bash
$ zig test test_switch.zig
1/2 test_switch.test.switch simple...OK
2/2 test_switch.test.switch inside function...OK
All 2 tests passed.
```

`switch` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–ª—è –∑–∞–ø–∏—Å–∏ –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ–ª–µ–π –≤ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–∏ —Å —Ç–µ–≥–∞–º–∏. –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –ø–æ–ª–µ–π –ø–µ—Ä–µ–¥
–∏–º–µ–Ω–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∑–∞–ø–∏—Å–∏ –º–æ–∂–Ω–æ –ø–æ–º–µ—Å—Ç–∏—Ç—å —Å–∏–º–≤–æ–ª `*`, –ø—Ä–µ–≤—Ä–∞—Ç–∏–≤ –µ–≥–æ –≤ —É–∫–∞–∑–∞—Ç–µ–ª—å.

```zig
const expect = @import("std").testing.expect;

test "switch on tagged union" {
    const Point = struct {
        x: u8,
        y: u8,
    };
    const Item = union(enum) {
        a: u32,
        c: Point,
        d,
        e: u32,
    };

    var a = Item{ .c = Point{ .x = 1, .y = 2 } };

    // –î–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –≤–∫–ª—é—á–µ–Ω–∏–µ –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã—Ö –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π.
    const b = switch (a) {
        // –ì—Ä—É–ø–ø–∞ –∑–∞—Ö–≤–∞—Ç–∞ —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –¥–ª—è —Å–æ–≤–ø–∞–¥–µ–Ω–∏—è –∏ –≤–µ—Ä–Ω–µ—Ç –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ
        // –∑–Ω–∞—á–µ–Ω–∏–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç. –ï—Å–ª–∏ —Ç–∏–ø—ã –ø–æ–ª–µ–∑–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ –≤ –æ–±–æ–∏—Ö —Å–ª—É—á–∞—è—Ö –æ–¥–∏–Ω–∞–∫–æ–≤—ã
        // –∏—Ö –º–æ–∂–Ω–æ –ø–æ–º–µ—Å—Ç–∏—Ç—å –≤ –æ–¥–∏–Ω –∏ —Ç–æ—Ç –∂–µ –∫–æ–Ω—Ç–∞–∫—Ç –∫–æ–º–º—É—Ç–∞—Ç–æ—Ä–∞.
        Item.a, Item.e => |item| item,

        // –°—Å—ã–ª–∫–∞ –Ω–∞ —Å–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª—É—á–µ–Ω–∞ —Å –ø–æ–º–æ—â—å—é —Å–∏–Ω—Ç–∞–∫—Å–∏—Å–∞ `*`.
        Item.c => |*item| blk: {
            item.*.x += 1;
            break :blk 6;
        },

        // –ë–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è, –µ—Å–ª–∏ –≤—Å–µ —Ç–∏–ø—ã –æ–±—Ä–∞—â–µ–Ω–∏–π –±—ã–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–º –æ–±—Ä–∞–∑–æ–º
        Item.d => 8,
    };

    try expect(b == 6);
    try expect(a.c.x == 2);
}
```
```bash
$ zig test test_switch_tagged_union.zig
1/1 test_switch_tagged_union.test.switch on tagged union...OK
All 1 tests passed.
```

#### Exhaustive Switching

–ï—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ `switch` –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è `else`, –æ–Ω–æ –¥–æ–ª–∂–Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç—å –∏—Å—á–µ—Ä–ø—ã–≤–∞—é—â–∏–π —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –≤–æ–∑–º–æ–∂–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π.
–ù–µ–≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —ç—Ç–æ–≥–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:

```zig
const Color = enum {
    auto,
    off,
    on,
};

test "exhaustive switching" {
    const color = Color.off;
    switch (color) {
        Color.auto => {},
        Color.on => {},
    }
}
```
```bash
$ zig test test_unhandled_enumeration_value.zig
doc/langref/test_unhandled_enumeration_value.zig:9:5: error: switch must handle all possibilities
    switch (color) {
    ^~~~~~
doc/langref/test_unhandled_enumeration_value.zig:3:5: note: unhandled enumeration value: 'off'
    off,
    ^~~
doc/langref/test_unhandled_enumeration_value.zig:1:15: note: enum 'test_unhandled_enumeration_value.Color' declared here
const Color = enum {
              ^~~~
```

#### Switching with Enum Literals

Enum Literals –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å `switch`, —á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–π –∏–ª–∏
–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π:

```zig
const std = @import("std");
const expect = std.testing.expect;

const Color = enum {
    auto,
    off,
    on,
};

test "enum literals with switch" {
    const color = Color.off;
    const result = switch (color) {
        .auto => false,
        .on => false,
        .off => true,
    };
    try expect(result);
}
```
```bash
$ zig test test_exhaustive_switch.zig
1/1 test_exhaustive_switch.test.enum literals with switch...OK
All 1 tests passed.
```

#### Inline Switch Prongs

–ü–µ—Ä–µ–∫–ª—é—á–∞—é—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ–º–µ—á–µ–Ω—ã –∫–∞–∫ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —á—Ç–æ–±—ã –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–ª–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≤–æ–∑–º–æ–∂–Ω–æ–≥–æ
–∑–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä–æ–µ –æ–Ω –º–æ–∂–µ—Ç –∏–º–µ—Ç—å, —á—Ç–æ –¥–µ–ª–∞–µ—Ç –∑–∞—Ö–≤–∞—á–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ `comptime`.

```zig
const std = @import("std");
const expect = std.testing.expect;
const expectError = std.testing.expectError;

fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T).Struct.fields;
    return switch (field_index) {
        // –≠—Ç–æ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä –∞–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç—Å—è –¥–≤–∞–∂–¥—ã, –∏ –∫–∞–∂–¥—ã–π —Ä–∞–∑ `idx` —è–≤–ª—è–µ—Ç—Å—è
        // –∑–Ω–∞—á–µ–Ω–∏–µ–º, –∏–∑–≤–µ—Å—Ç–Ω—ã–º –ø–æ –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
        inline 0, 1 => |idx| @typeInfo(fields[idx].type) == .Optional,
        else => return error.IndexOutOfBounds,
    };
}

const Struct1 = struct { a: u32, b: ?u32 };

test "using @typeInfo with runtime values" {
    var index: usize = 0;
    try expect(!try isFieldOptional(Struct1, index));
    index += 1;
    try expect(try isFieldOptional(Struct1, index));
    index += 1;
    try expectError(error.IndexOutOfBounds, isFieldOptional(Struct1, index));
}

// –í—ã–∑–æ–≤—ã `isFieldOptional` –≤ `Struct1` –ø—Ä–µ–æ–±—Ä–∞–∑—É—é—Ç—Å—è –≤ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç
// —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:
fn isFieldOptionalUnrolled(field_index: usize) !bool {
    return switch (field_index) {
        0 => false,
        1 => true,
        else => return error.IndexOutOfBounds,
    };
}
```
```bash
$ zig test test_inline_switch.zig
1/1 test_inline_switch.test.using @typeInfo with runtime values...OK
All 1 tests passed.
```

–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `inline` —Ç–∞–∫–∂–µ –º–æ–∂–µ—Ç —Å–æ—á–µ—Ç–∞—Ç—å—Å—è —Å –¥–∏–∞–ø–∞–∑–æ–Ω–∞–º–∏:

```zig
fn isFieldOptional(comptime T: type, field_index: usize) !bool {
    const fields = @typeInfo(T).Struct.fields;
    return switch (field_index) {
        inline 0...fields.len - 1 => |idx| @typeInfo(fields[idx].type) == .Optional,
        else => return error.IndexOutOfBounds,
    };
}
```

–≠–ª–µ–º–µ–Ω—Ç—ã `inline else` –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç–∏–ø–æ–±–µ–∑–æ–ø–∞—Å–Ω–æ–π –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤—ã —Ü–∏–∫–ª–∞–º `inline for`:

```zig
const std = @import("std");
const expect = std.testing.expect;

const SliceTypeA = extern struct {
    len: usize,
    ptr: [*]u32,
};
const SliceTypeB = extern struct {
    ptr: [*]SliceTypeA,
    len: usize,
};
const AnySlice = union(enum) {
    a: SliceTypeA,
    b: SliceTypeB,
    c: []const u8,
    d: []AnySlice,
};

fn withFor(any: AnySlice) usize {
    const Tag = @typeInfo(AnySlice).Union.tag_type.?;
    inline for (@typeInfo(Tag).Enum.fields) |field| {
        // –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ `inline for` —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∫–∞–∫
        // —Å–µ—Ä–∏—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π `if`, –∑–∞–≤–∏—Å—è—â–∏—Ö –æ—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä–∞
        // –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –µ–µ –≤ switch.
        if (field.value == @intFromEnum(any)) {
            return @field(any, field.name).len;
        }
    }
    // –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ `inline for` –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –Ω–µ –∑–Ω–∞–µ—Ç, —á—Ç–æ –±—ã–ª –æ–±—Ä–∞–±–æ—Ç–∞–Ω –∫–∞–∂–¥—ã–π
    // –≤–æ–∑–º–æ–∂–Ω—ã–π —Å–ª—É—á–∞–π, —Ç—Ä–µ–±—É—é—â–∏–π —è–≤–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è `unreachable`.
    unreachable;
}

fn withSwitch(any: AnySlice) usize {
    return switch (any) {
        // –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ `inline else` —Ñ—É–Ω–∫—Ü–∏—è –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —è–≤–Ω–æ
        // –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∂–µ–ª–∞–µ–º–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞, –∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ
        // –æ–±—Ä–∞–±–æ—Ç–∞–Ω—ã –≤—Å–µ –≤–æ–∑–º–æ–∂–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã.
        inline else => |slice| slice.len,
    };
}

test "inline for and inline else similarity" {
    const any = AnySlice{ .c = "hello" };
    try expect(withFor(any) == 5);
    try expect(withSwitch(any) == 5);
}
```
```bash
$ zig test test_inline_else.zig
1/1 test_inline_else.test.inline for and inline else similarity...OK
All 1 tests passed.
```

–ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–≥–æ –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è –∫–æ–Ω—Ç–∞–∫—Ç–æ–≤ –¥–ª—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞—Ö–≤–∞—Ç –¥–ª—è
–ø–æ–ª—É—á–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ–≥–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è.

```zig
const std = @import("std");
const expect = std.testing.expect;

const U = union(enum) {
    a: u32,
    b: f32,
};

fn getNum(u: U) u32 {
    switch (u) {
        // –ó–¥–µ—Å—å "num" - —ç—Ç–æ –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ª–∏–±–æ
        // `u.a", –ª–∏–±–æ "u.b", –∞ "tag" - —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ —Ç–µ–≥–∞, –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.
        inline else => |num, tag| {
            if (tag == .b) {
                return @intFromFloat(num);
            }
            return num;
        },
    }
}

test "test" {
    const u = U{ .b = 42 };
    try expect(getNum(u) == 42);
}
```
```bash
$ zig test test_inline_switch_union_tag.zig
1/1 test_inline_switch_union_tag.test.test...OK
All 1 tests passed.
```

------------
### While

–¶–∏–∫–ª while –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –º–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω–æ–≥–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è –¥–æ —Ç–µ—Ö –ø–æ—Ä –ø–æ–∫–∞ –∫–∞–∫–æ–µ-–ª–∏–±–æ —É—Å–ª–æ–≤–∏–µ –Ω–µ –ø–µ—Ä–µ—Å—Ç–∞–Ω–µ—Ç
–≤—ã–ø–æ–ª–Ω—è—Ç—å—Å—è.

```zig
const expect = @import("std").testing.expect;

test "while basic" {
    var i: usize = 0;
    while (i < 10) {
        i += 1;
    }
    try expect(i == 10);
}
```
```bash
$ zig test test_while.zig
1/1 test_while.test.while basic...OK
All 1 tests passed.
```

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `break` –¥–ª—è —Ä–∞–Ω–Ω–µ–≥–æ –≤—ã—Ö–æ–¥–∞ –∏–∑ —Ü–∏–∫–ª–∞ while.

```zig
test_while_break.zig

const expect = @import("std").testing.expect;

test "while break" {
    var i: usize = 0;
    while (true) {
        if (i == 10)
            break;
        i += 1;
    }
    try expect(i == 10);
}
```
```bash
$ zig test test_while_break.zig
1/1 test_while_break.test.while break...OK
All 1 tests passed.
```

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ `continue` —á—Ç–æ–±—ã –≤–µ—Ä–Ω—É—Ç—å—Å—è –∫ –Ω–∞—á–∞–ª—É —Ü–∏–∫–ª–∞.

```zig
const expect = @import("std").testing.expect;

test "while continue" {
    var i: usize = 0;
    while (true) {
        i += 1;
        if (i < 10)
            continue;
        break;
    }
    try expect(i == 10);
}
```
```bash
$ zig test test_while_continue.zig
1/1 test_while_continue.test.while continue...OK
All 1 tests passed.
```

–¶–∏–∫–ª—ã while –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—é—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ continue –∫–æ—Ç–æ—Ä–æ–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –ø—Ä–∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–∏ —Ü–∏–∫–ª–∞. –ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `continue`
—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —ç—Ç–æ–º—É –≤—ã—Ä–∞–∂–µ–Ω–∏—é.

```zig
const expect = @import("std").testing.expect;

test "while loop continue expression" {
    var i: usize = 0;
    while (i < 10) : (i += 1) {}
    try expect(i == 10);
}

test "while loop continue expression, more complicated" {
    var i: usize = 1;
    var j: usize = 1;
    while (i * j < 2000) : ({
        i *= 2;
        j *= 3;
    }) {
        const my_ij = i * j;
        try expect(my_ij < 2000);
    }
}
```
```bash
$ zig test test_while_continue_expression.zig
1/2 test_while_continue_expression.test.while loop continue expression...OK
2/2 test_while_continue_expression.test.while loop continue expression, more complicated...OK
All 2 tests passed.
```

–¶–∏–∫–ª—ã while —è–≤–ª—è—é—Ç—Å—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏. –†–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è `else` —Ü–∏–∫–ª–∞ while –∫–æ—Ç–æ—Ä—ã–π
–≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è –∫–æ–≥–¥–∞ —É—Å–ª–æ–≤–∏–µ —Ü–∏–∫–ª–∞ while –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –∫–∞–∫ –ª–æ–∂–Ω–æ–µ.

`break` –∫–∞–∫ –∏ `return` –ø—Ä–∏–Ω–∏–º–∞–µ—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä value. –≠—Ç–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏—è `while`. –ö–æ–≥–¥–∞ –≤—ã –≤—ã—Ö–æ–¥–∏—Ç–µ –∏–∑ —Ü–∏–∫–ª–∞ while, –≤–µ—Ç–≤—å
`else` –Ω–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è.

```zig
const expect = @import("std").testing.expect;

test "while else" {
    try expect(rangeHasNumber(0, 10, 5));
    try expect(!rangeHasNumber(0, 10, 15));
}

fn rangeHasNumber(begin: usize, end: usize, number: usize) bool {
    var i = begin;
    return while (i < end) : (i += 1) {
        if (i == number) {
            break true;
        }
    } else false;
}
```
```bash
$ zig test test_while_else.zig
1/1 test_while_else.test.while else...OK
All 1 tests passed.
```

#### Labeled while

–ö–æ–≥–¥–∞ —Ü–∏–∫–ª `while` –∏–º–µ–µ—Ç –æ—Ç–º–µ—Ç–∫—É, —Ç–æ –Ω–∞ –Ω–µ–≥–æ –º–æ–∂–Ω–æ —Å—Å—ã–ª–∞—Ç—å—Å—è –∏–∑ `break` –∏–ª–∏ `continue` –∏–∑ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞:

```zig
test "nested break" {
    outer: while (true) {
        while (true) {
            break :outer;
        }
    }
}

test "nested continue" {
    var i: usize = 0;
    outer: while (i < 10) : (i += 1) {
        while (true) {
            continue :outer;
        }
    }
}
```
```bash
$ zig test test_while_nested_break.zig
1/2 test_while_nested_break.test.nested break...OK
2/2 test_while_nested_break.test.nested continue...OK
All 2 tests passed.
```

#### while with Optionals

–¢–∞–∫ –∂–µ, –∫–∞–∫ –∏ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏—è—Ö if, —Ü–∏–∫–ª—ã while –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –∫–∞—á–µ—Å—Ç–≤–µ —É—Å–ª–æ–≤–∏—è –∏ –ø–æ–ª—É—á–∞—Ç—å
–ø–æ–ª–µ–∑–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É. –ü—Ä–∏ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–∏ –∑–Ω–∞—á–µ–Ω–∏—è null —Ü–∏–∫–ª –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è.

–ö–æ–≥–¥–∞ –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ while –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç —Å–∏–Ω—Ç–∞–∫—Å–∏—Å `|x|`, —É—Å–ª–æ–≤–∏–µ `while` –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø.

–í–µ—Ç–≤—å `else` —Ä–∞–∑—Ä–µ—à–µ–Ω–∞ –¥–ª—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–π –∏—Ç–µ—Ä–∞—Ü–∏–∏. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –æ–Ω –±—É–¥–µ—Ç –≤—ã–ø–æ–ª–Ω–µ–Ω –ø—Ä–∏ –ø–µ—Ä–≤–æ–º –æ–±–Ω–∞—Ä—É–∂–µ–Ω–Ω–æ–º –Ω—É–ª–µ–≤–æ–º
–∑–Ω–∞—á–µ–Ω–∏–∏.

```zig
const expect = @import("std").testing.expect;

test "while null capture" {
    var sum1: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum1 += value;
    }
    try expect(sum1 == 3);

    // –∑–∞—Ö–≤–∞—Ç –Ω—É–ª–µ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é –±–ª–æ–∫–∞ else
    var sum2: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| {
        sum2 += value;
    } else {
        try expect(sum2 == 3);
    }

    // –∑–∞—Ö–≤–∞—Ç –Ω—É–ª–µ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–æ–º–æ—â—å—é –≤—ã—Ä–∞–∂–µ–Ω–∏—è continue
    var i: u32 = 0;
    var sum3: u32 = 0;
    numbers_left = 3;
    while (eventuallyNullSequence()) |value| : (i += 1) {
        sum3 += value;
    }
    try expect(i == 3);
}

var numbers_left: u32 = undefined;
fn eventuallyNullSequence() ?u32 {
    return if (numbers_left == 0) null else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}
```
```bash
$ zig test test_while_null_capture.zig
1/1 test_while_null_capture.test.while null capture...OK
All 1 tests passed.
```

#### while with Error Unions

–ö–∞–∫ –∏ –≤ —Å–ª—É—á–∞–µ —Å –≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏ if, —Ü–∏–∫–ª—ã while –º–æ–≥—É—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å union —Å –æ—à–∏–±–∫–æ–π –≤ –∫–∞—á–µ—Å—Ç–≤–µ —É—Å–ª–æ–≤–∏—è –∏ –ø–æ–ª—É—á–∞—Ç—å
–ø–æ–ª–µ–∑–Ω—É—é –Ω–∞–≥—Ä—É–∑–∫—É –∏–ª–∏ –∫–æ–¥ –æ—à–∏–±–∫–∏. –ö–æ–≥–¥–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —É—Å–ª–æ–≤–∏—è —è–≤–ª—è–µ—Ç—Å—è –∫–æ–¥ –æ—à–∏–±–∫–∏, –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –≤–µ—Ç–≤—å else –∏
—Ü–∏–∫–ª –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è.

–ö–æ–≥–¥–∞ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å `else |x|` –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –≤—ã—Ä–∞–∂–µ–Ω–∏–∏ while, —É—Å–ª–æ–≤–∏–µ while –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å —Ç–∏–ø Error Union Type.

```zig
const expect = @import("std").testing.expect;

test "while error union capture" {
    var sum1: u32 = 0;
    numbers_left = 3;
    while (eventuallyErrorSequence()) |value| {
        sum1 += value;
    } else |err| {
        try expect(err == error.ReachedZero);
    }
}

var numbers_left: u32 = undefined;

fn eventuallyErrorSequence() anyerror!u32 {
    return if (numbers_left == 0) error.ReachedZero else blk: {
        numbers_left -= 1;
        break :blk numbers_left;
    };
}
```
```bash
$ zig test test_while_error_capture.zig
1/1 test_while_error_capture.test.while error union capture...OK
All 1 tests passed.
```

#### inline while

–¶–∏–∫–ª—ã while –º–æ–≥—É—Ç –±—ã—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω—ã. –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—é —Ü–∏–∫–ª–∞, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–¥—É –≤—ã–ø–æ–ª–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ
–¥–µ–π—Å—Ç–≤–∏—è –∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞.

```zig
const expect = @import("std").testing.expect;

test "inline while loop" {
    comptime var i = 0;
    var sum: usize = 0;
    inline while (i < 3) : (i += 1) {
        const T = switch (i) {
            0 => f32,
            1 => i8,
            2 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    try expect(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}
```
```bash
$ zig test test_inline_while.zig
1/1 test_inline_while.test.inline while loop...OK
All 1 tests passed.
```

–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `inline` —Ü–∏–∫–ª—ã —Ç–æ–ª—å–∫–æ –ø–æ –æ–¥–Ω–æ–π –∏–∑ —ç—Ç–∏—Ö –ø—Ä–∏—á–∏–Ω:
- –î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã —Å–µ–º–∞–Ω—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —á—Ç–æ–±—ã —Ü–∏–∫–ª –≤—ã–ø–æ–ª–Ω—è–ª—Å—è –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
- –£ –≤–∞—Å –µ—Å—Ç—å —Ç–µ—Å—Ç –∫–æ—Ç–æ—Ä—ã–π –¥–æ–∫–∞–∂–µ—Ç, —á—Ç–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–∞ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ.

------------

### for

```zig
const expect = @import("std").testing.expect;

test "for basics" {
    const items = [_]i32{ 4, 5, 3, 4, 0 };
    var sum: i32 = 0;

    // –¶–∏–∫–ª—ã for –≤—ã–ø–æ–ª–Ω—è—é—Ç –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ —Å—Ä–µ–∑–∞–º –∏ –º–∞—Å—Å–∏–≤–∞–º.
    for (items) |value| {
        // –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç break –∏ continue.
        if (value == 0) {
            continue;
        }
        sum += value;
    }
    try expect(sum == 16);

    // –ß—Ç–æ–±—ã –≤—ã–ø–æ–ª–Ω–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ —á–∞—Å—Ç–∏ —Å—Ä–µ–∑–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é.
    for (items[0..1]) |value| {
        sum += value;
    }
    try expect(sum == 20);

    // –ß—Ç–æ–±—ã –ø–æ–ª—É—á–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –∏–Ω–¥–µ–∫—Å—É –∏—Ç–µ—Ä–∞—Ü–∏–∏, —É–∫–∞–∂–∏—Ç–µ —Ç–∞–∫–∂–µ –≤—Ç–æ—Ä–æ–µ —É—Å–ª–æ–≤–∏–µ
    // –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—Ç–æ—Ä–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∑–∞–ø–∏—Å–∏.
    var sum2: i32 = 0;
    for (items, 0..) |_, i| {
        try expect(@TypeOf(i) == usize);
        sum2 += @as(i32, @intCast(i));
    }
    try expect(sum2 == 10);

    // –î–ª—è –ø–µ—Ä–µ–±–æ—Ä–∞ –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω—ã—Ö —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å range.
    // –ù–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–π –¥–∏–∞–ø–∞–∑–æ–Ω –≤—Å–µ–≥–¥–∞ —è–≤–ª—è–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
    var sum3: usize = 0;
    for (0..5) |i| {
        sum3 += i;
    }
    try expect(sum3 == 10);
}

test "multi object for" {
    const items = [_]usize{ 1, 2, 3 };
    const items2 = [_]usize{ 4, 5, 6 };
    var count: usize = 0;

    // –í—ã–ø–æ–ª–Ω–∏—Ç—å –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º –æ–±—ä–µ–∫—Ç–∞–º.
    // –í –Ω–∞—á–∞–ª–µ —Ü–∏–∫–ª–∞ –≤—Å–µ –¥–ª–∏–Ω—ã –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Ä–∞–≤–Ω—ã, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –±—É–¥–µ—Ç –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ –Ω–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ.
    for (items, items2) |i, j| {
        count += i + j;
    }

    try expect(count == 21);
}

test "for reference" {
    var items = [_]i32{ 3, 4, 2 };

    // –í—ã–ø–æ–ª–Ω–∏—Ç–µ –∏—Ç–µ—Ä–∞—Ü–∏—é –ø–æ —Å—Ä–µ–∑—É –ø–æ —Å—Å—ã–ª–∫–µ, —É–∫–∞–∑–∞–≤, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –∑–∞—Ö–≤–∞—Ç–∞ —è–≤–ª—è–µ—Ç—Å—è —É–∫–∞–∑–∞—Ç–µ–ª–µ–º.
    for (&items) |*value| {
        value.* += 1;
    }

    try expect(items[0] == 4);
    try expect(items[1] == 5);
    try expect(items[2] == 3);
}

test "for else" {
    // for –¥–æ–ø—É—Å–∫–∞–µ—Ç –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∫ –Ω–µ–º—É else, –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ü–∏–∫–ª—É while.
    const items = [_]?i32{ 3, 4, null, 5 };

    // –¶–∏–∫–ª—ã for —Ç–∞–∫–∂–µ –º–æ–≥—É—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–π.
    // –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ —Ü–∏–∫–ª–∞–º while, –∫–æ–≥–¥–∞ –≤—ã –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç–µ —Ü–∏–∫–ª for –≤–µ—Ç–≤—å else –Ω–µ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è.
    var sum: i32 = 0;
    const result = for (items) |value| {
        if (value != null) {
            sum += value.?;
        }
    } else blk: {
        try expect(sum == 12);
        break :blk sum;
    };
    try expect(result == 12);
}
```
```bash
$ zig test test_for.zig
1/4 test_for.test.for basics...OK
2/4 test_for.test.multi object for...OK
3/4 test_for.test.for reference...OK
4/4 test_for.test.for else...OK
All 4 tests passed.
```

#### Labeled for

–ö–æ–≥–¥–∞ —Ü–∏–∫–ª for –æ—Ç–º–µ—á–µ–Ω –∫–∞–∫ –±–ª–æ–∫ –Ω–∞ –Ω–µ–≥–æ –º–æ–∂–Ω–æ —Å—Å—ã–ª–∞—Ç—å—Å—è –∏–∑ `break` –∏–ª–∏ `continue` –∏–∑ –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Ü–∏–∫–ª–∞:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "nested break" {
    var count: usize = 0;
    outer: for (1..6) |_| {
        for (1..6) |_| {
            count += 1;
            break :outer;
        }
    }
    try expect(count == 1);
}

test "nested continue" {
    var count: usize = 0;
    outer: for (1..9) |_| {
        for (1..6) |_| {
            count += 1;
            continue :outer;
        }
    }

    try expect(count == 8);
}
```
```bash
$ zig test test_for_nested_break.zig
1/2 test_for_nested_break.test.nested break...OK
2/2 test_for_nested_break.test.nested continue...OK
All 2 tests passed.
```

#### inline for

–¶–∏–∫–ª—ã for –º–æ–≥—É—Ç –±—ã—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω—ã. –≠—Ç–æ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—é —Ü–∏–∫–ª–∞, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–¥—É –≤—ã–ø–æ–ª–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –¥–µ–π—Å—Ç–≤–∏—è,
–∫–æ—Ç–æ—Ä—ã–µ —Ä–∞–±–æ—Ç–∞—é—Ç —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∑–Ω–∞—á–µ–Ω–∏–π –ø–µ—Ä–≤–æ–≥–æ –∫–ª–∞—Å—Å–∞. –ó–Ω–∞—á–µ–Ω–∏–µ
–∑–∞—Ö–≤–∞—Ç–∞ –∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ç–æ—Ä–∞ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ü–∏–∫–ª–æ–≤ for –∏–∑–≤–µ—Å—Ç–Ω—ã –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.

```zig
const expect = @import("std").testing.expect;

test "inline for loop" {
    const nums = [_]i32{ 2, 4, 6 };
    var sum: usize = 0;
    inline for (nums) |i| {
        const T = switch (i) {
            2 => f32,
            4 => i8,
            6 => bool,
            else => unreachable,
        };
        sum += typeNameLength(T);
    }
    try expect(sum == 9);
}

fn typeNameLength(comptime T: type) usize {
    return @typeName(T).len;
}
```
```bash
$ zig test test_inline_for.zig
1/1 test_inline_for.test.inline for loop...OK
All 1 tests passed.
```

–†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å `inline` —Ü–∏–∫–ª—ã —Ç–æ–ª—å–∫–æ –ø–æ –æ–¥–Ω–æ–π –∏–∑ —ç—Ç–∏—Ö –ø—Ä–∏—á–∏–Ω:
- –î–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã —Å–µ–º–∞–Ω—Ç–∏–∫–∞ —Ä–∞–±–æ—Ç–∞–ª–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —á—Ç–æ–±—ã —Ü–∏–∫–ª –≤—ã–ø–æ–ª–Ω—è–ª—Å—è –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
- –£ –≤–∞—Å –µ—Å—Ç—å —Ç–µ—Å—Ç –∫–æ—Ç–æ—Ä—ã–π –¥–æ–∫–∞–∂–µ—Ç, —á—Ç–æ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ —Ü–∏–∫–ª–∞ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ –±—ã—Å—Ç—Ä–µ–µ.

------------
### if

```zig
// –£ –≤—ã—Ä–∞–∂–µ–Ω–∏–π if –µ—Å—Ç—å —Ç—Ä–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–µ —Ç—Ä–µ–º —Ç–∏–ø–∞–º:
// * bool
// * ?T
// * anyerror!T

const expect = @import("std").testing.expect;

test "if expression" {
    // –í–º–µ—Å—Ç–æ if –≤—ã—Ä–∞–∂–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–µ—Ä–Ω–∞—Ä–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
    const a: u32 = 5;
    const b: u32 = 4;
    const result = if (a != b) 47 else 3089;
    try expect(result == 47);
}

test "if boolean" {
    // –í—ã—Ä–∞–∂–µ–Ω–∏—è if –ø—Ä–æ–≤–µ—Ä—è—é—Ç –ª–æ–≥–∏—á–µ—Å–∫–∏–µ —É—Å–ª–æ–≤–∏—è.
    const a: u32 = 5;
    const b: u32 = 4;
    if (a != b) {
        try expect(true);
    } else if (a == 9) {
        unreachable;
    } else {
        unreachable;
    }
}

test "if error union" {
    // –ï—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫.
    // –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –∑–∞–ø–∏—Å—å |err| –≤ else.

    const a: anyerror!u32 = 0;
    if (a) |value| {
        try expect(value == 0);
    } else |err| {
        _ = err;
        unreachable;
    }

    const b: anyerror!u32 = error.BadValue;
    if (b) |value| {
        _ = value;
        unreachable;
    } else |err| {
        try expect(err == error.BadValue);
    }

    // else –∏ |err| –∑–∞—Ö–≤–∞—Ç —Å—Ç—Ä–æ–≥–æ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã.
    if (a) |value| {
        try expect(value == 0);
    } else |_| {}

    // –ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—É—Å—Ç–æ–µ –±–ª–æ—á–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ.
    if (b) |_| {} else |err| {
        try expect(err == error.BadValue);
    }

    // –î–æ—Å—Ç—É–ø –∫ –∑–Ω–∞—á–µ–Ω–∏—é –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ —Å –ø–æ–º–æ—â—å—é –∑–∞—Ö–≤–∞—Ç–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è.
    var c: anyerror!u32 = 3;
    if (c) |*value| {
        value.* = 9;
    } else |_| {
        unreachable;
    }

    if (c) |value| {
        try expect(value == 9);
    } else |_| {
        unreachable;
    }
}
```
```bash
$ zig test test_if.zig
1/3 test_if.test.if expression...OK
2/3 test_if.test.if boolean...OK
3/3 test_if.test.if error union...OK
All 3 tests passed.
```

#### if with Optionals

```zig
const expect = @import("std").testing.expect;

test "if optional" {
    // if –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ –Ω–∞–ª–∏—á–∏–µ null.

    const a: ?u32 = 0;
    if (a) |value| {
        try expect(value == 0);
    } else {
        unreachable;
    }

    const b: ?u32 = null;
    if (b) |_| {
        unreachable;
    } else {
        try expect(true);
    }

    // –û—Å—Ç–∞–ª—å–Ω–æ–µ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.
    if (a) |value| {
        try expect(value == 0);
    }

    // –ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å —Ç–æ–ª—å–∫–æ –∑–Ω–∞—á–µ–Ω–∏–µ null –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä –¥–≤–æ–π–Ω–æ–≥–æ —Ä–∞–≤–µ–Ω—Å—Ç–≤–∞.
    if (b == null) {
        try expect(true);
    }

    // –î–æ—Å—Ç—É–ø –∫ –∑–Ω–∞—á–µ–Ω–∏—é –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ —Å –ø–æ–º–æ—â—å—é –∑–∞—Ö–≤–∞—Ç–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è.
    var c: ?u32 = 3;
    if (c) |*value| {
        value.* = 2;
    }

    if (c) |value| {
        try expect(value == 2);
    } else {
        unreachable;
    }
}

test "if error union with optional" {
    // –í—ã—Ä–∞–∂–µ–Ω–∏—è if –ø—Ä–æ–≤–µ—Ä—è—é—Ç—Å—è –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ—à–∏–±–æ–∫ –ø–µ—Ä–µ–¥ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤.
    // –¢–∏–ø |optional_value| capture —Ä–∞–≤–µ–Ω ?u32.

    const a: anyerror!?u32 = 0;
    if (a) |optional_value| {
        try expect(optional_value.? == 0);
    } else |err| {
        _ = err;
        unreachable;
    }

    const b: anyerror!?u32 = null;
    if (b) |optional_value| {
        try expect(optional_value == null);
    } else |_| {
        unreachable;
    }

    const c: anyerror!?u32 = error.BadValue;
    if (c) |optional_value| {
        _ = optional_value;
        unreachable;
    } else |err| {
        try expect(err == error.BadValue);
    }

    // –î–æ—Å—Ç—É–ø –∫ –∑–Ω–∞—á–µ–Ω–∏—é –æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –ø–æ —Å—Å—ã–ª–∫–µ, –∫–∞–∂–¥—ã–π —Ä–∞–∑ –∏—Å–ø–æ–ª—å–∑—É—è –∑–∞—Ö–≤–∞—Ç —É–∫–∞–∑–∞—Ç–µ–ª—è.
    var d: anyerror!?u32 = 3;
    if (d) |*optional_value| {
        if (optional_value.*) |*value| {
            value.* = 9;
        }
    } else |_| {
        unreachable;
    }

    if (d) |optional_value| {
        try expect(optional_value.? == 9);
    } else |_| {
        unreachable;
    }
}
```
```bash
$ zig test test_if_optionals.zig
1/2 test_if_optionals.test.if optional...OK
2/2 test_if_optionals.test.if error union with optional...OK
All 2 tests passed.
```

------------
### defer

–í—ã–ø–æ–ª–Ω—è–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –±–µ–∑–æ–≥–æ–≤–æ—Ä–æ—á–Ω–æ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ –æ–±–ª–∞—Å—Ç–∏ –≤–∏–¥–∏–º–æ—Å—Ç–∏.

```zig
const std = @import("std");
const expect = std.testing.expect;
const print = std.debug.print;

fn deferExample() !usize {
    var a: usize = 1;

    {
        defer a = 2;
        a = 1;
    }
    try expect(a == 2);

    a = 5;
    return a;
}

test "defer basics" {
    try expect((try deferExample()) == 5);
}
```
```bash
$ zig test test_defer.zig
1/1 test_defer.test.defer basics...OK
All 1 tests passed.
```

–û—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –≤—ã—á–∏—Å–ª—è—é—Ç—Å—è –≤ –æ–±—Ä–∞—Ç–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ.

```zig
const std = @import("std");
const expect = std.testing.expect;
const print = std.debug.print;

test "defer unwinding" {
    print("\n", .{});

    defer {
        print("1 ", .{});
    }
    defer {
        print("2 ", .{});
    }
    if (false) {
        // –æ—Ç–ª–æ–∂–µ–Ω–Ω—ã–µ –∑–∞–ø—Ä–æ—Å—ã –Ω–µ –∑–∞–ø—É—Å–∫–∞—é—Ç—Å—è, –µ—Å–ª–∏ –æ–Ω–∏ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è.
        defer {
            print("3 ", .{});
        }
    }
}
```
```bash
$ zig test defer_unwind.zig
1/1 defer_unwind.test.defer unwinding...
2 1 OK
All 1 tests passed.
```

–í–Ω—É—Ç—Ä–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏—è defer –æ–ø–µ—Ä–∞—Ç–æ—Ä return –Ω–µ –¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è.

```zig
fn deferInvalidExample() !void {
    defer {
        return error.DeferError;
    }

    return error.DeferError;
}
```
```bash
$ zig test test_invalid_defer.zig
doc/langref/test_invalid_defer.zig:3:9: error: cannot return from defer expression
        return error.DeferError;
        ^~~~~~~~~~~~~~~~~~~~~~~
doc/langref/test_invalid_defer.zig:2:5: note: defer expression here
    defer {
    ^~~~~
```

------------
### unreachable

–í —Ä–µ–∂–∏–º–∞—Ö Debug –∏ ReleaseSafe —Ñ—É–Ω–∫—Ü–∏—è `unreachable` –≤—ã–∑—ã–≤–∞–µ—Ç `panic` —Å —Å–æ–æ–±—â–µ–Ω–∏–µ–º `reached unreachable code`.

–í —Ä–µ–∂–∏–º–∞—Ö ReleaseFast –∏ ReleaseSmall –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –∏—Å–ø–æ–ª—å–∑—É–µ—Ç –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ –æ —Ç–æ–º, —á—Ç–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω—ã–π –∫–æ–¥ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥–µ—Ç
–∑–∞–ø—É—â–µ–Ω –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–π.

#### Basics

```zig
// unreachable –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è, —á—Ç–æ –ø–æ—Ç–æ–∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –¥–æ—Å—Ç–∏–≥–Ω–µ—Ç
// –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è:
test "basic math" {
    const x = 1;
    const y = 2;
    if (x + y != 3) {
        unreachable;
    }
}
```
```bash

$ zig test test_unreachable.zig
1/1 test_unreachable.test.basic math...OK
All 1 tests passed.
```

–§–∞–∫—Ç–∏—á–µ—Å–∫–∏, –∏–º–µ–Ω–Ω–æ —Ç–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω `std.debug.assert`:

```zig
// –í–æ—Ç –∫–∞–∫ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω std.debug.assert
fn assert(ok: bool) void {
    if (!ok) unreachable; // assertion failure
}

// –≠—Ç–æ—Ç —Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –Ω–µ—É–¥–∞—á–µ–π, –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –ø–æ–ø–∞–ª–∏ –≤ –Ω–µ–¥–æ—Å—Ç–∏–∂–∏–º—É—é –æ–±–ª–∞—Å—Ç—å.
test "this will fail" {
    assert(false);
}
```
```bash
$ zig test test_assertion_failure.zig
1/1 test_assertion_failure.test.this will fail...thread 3571599 panic: reached unreachable code
/home/andy/src/zig/doc/langref/test_assertion_failure.zig:3:14: 0x103cd9d in assert (test)
    if (!ok) unreachable; // assertion failure
             ^
/home/andy/src/zig/doc/langref/test_assertion_failure.zig:8:11: 0x103cd5a in test.this will fail (test)
    assert(false);
          ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x10479a0 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x103dbbb in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103d249 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103cdb1 in _start (test)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
error: the following test command crashed:
/home/andy/src/zig/.zig-cache/o/a6b3ce5875a9e285c15739b2a1b30733/test

```

#### At Compile-Time

```zig
const assert = @import("std").debug.assert;

test "type of unreachable" {
    comptime {
        // –¢–∏–ø unreachable - noreturn.

        // –û–¥–Ω–∞–∫–æ —ç—Ç–æ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –≤—Å–µ —Ä–∞–≤–Ω–æ –Ω–µ —É–¥–∞—Å—Ç—Å—è —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å, –ø–æ—Å–∫–æ–ª—å–∫—É
        // –í—ã—Ä–∞–∂–µ–Ω–∏—è unreachable —è–≤–ª—è—é—Ç—Å—è –æ—à–∏–±–∫–∞–º–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.

        assert(@TypeOf(unreachable) == noreturn);
    }
}
```
```bash
$ zig test test_comptime_unreachable.zig
doc/langref/test_comptime_unreachable.zig:10:16: error: unreachable code
        assert(@TypeOf(unreachable) == noreturn);
               ^~~~~~~~~~~~~~~~~~~~
doc/langref/test_comptime_unreachable.zig:10:24: note: control flow is diverted here
        assert(@TypeOf(unreachable) == noreturn);
                       ^~~~~~~~~~~
```

------------
### noreturn

`noreturn` - —ç—Ç–æ —Ç–∏–ø:
- `break`
- `continue`
- `return`
- `unreachable`
- `while (true) {}`

–ü—Ä–∏ —Å–æ–≤–º–µ—Å—Ç–Ω–æ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏ —Ç–∏–ø–æ–≤ —Ç–∞–∫–∏—Ö –∫–∞–∫ `if` –∏–ª–∏ `switch`, —Ç–∏–ø `noreturn` —Å–æ–≤–º–µ—Å—Ç–∏–º —Å–æ –≤—Å–µ–º–∏ –¥—Ä—É–≥–∏–º–∏
—Ç–∏–ø–∞–º–∏. –°—á–∏—Ç–∞—Ç—å:

```zig
fn foo(condition: bool, b: u32) void {
    const a = if (condition) b else return;
    _ = a;
    @panic("do something with a");
}
test "noreturn" {
    foo(false, 1);
}
```
```bash
$ zig test test_noreturn.zig
1/1 test_noreturn.test.noreturn...OK
All 1 tests passed.
```

–î—Ä—É–≥–∏–º –≤–∞—Ä–∏–∞–Ω—Ç–æ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è `noreturn` —è–≤–ª—è–µ—Ç—Å—è —Ñ—É–Ω–∫—Ü–∏—è `exit`:

```zig
const std = @import("std");
const builtin = @import("builtin");
const native_arch = builtin.cpu.arch;
const expect = std.testing.expect;

const WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;
extern "kernel32" fn ExitProcess(exit_code: c_uint) callconv(WINAPI) noreturn;

test "foo" {
    const value = bar() catch ExitProcess(1);
    try expect(value == 1234);
}

fn bar() anyerror!u32 {
    return 1234;
}
```
```bash
$ zig test test_noreturn_from_exit.zig -target x86_64-windows --test-no-exec
```

------------
### Functions

```zig
const std = @import("std");
const builtin = @import("builtin");
const native_arch = builtin.cpu.arch;
const expect = std.testing.expect;

// –§—É–Ω–∫—Ü–∏–∏ –æ–±—ä—è–≤–ª—è—é—Ç—Å—è —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º
fn add(a: i8, b: i8) i8 {
    if (a == 0) {
        return b;
    }

    return a + b;
}

// –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä —ç–∫—Å–ø–æ—Ä—Ç–∞ –¥–µ–ª–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –≤–Ω–µ—à–Ω–µ –≤–∏–¥–∏–º–æ–π –≤ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω–æ–º
// –æ–±—ä–µ–∫—Ç–Ω–æ–º —Ñ–∞–π–ª–µ –∏ –∑–∞—Å—Ç–∞–≤–ª—è–µ—Ç –µ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å C ABI.
export fn sub(a: i8, b: i8) i8 {
    return a - b;
}

// –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä extern –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ä–∞–∑—Ä–µ—à–µ–Ω–∞
// –≤–æ –≤—Ä–µ–º—è –ª–∏–Ω–∫–æ–≤–∫–∏ –ø—Ä–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–π —Å–≤—è–∑—ã–≤–∞–Ω–∏–∏ –∏–ª–∏ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–º —Å–≤—è–∑—ã–≤–∞–Ω–∏–∏.
// –ò–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–∫–ª—é—á–µ–Ω–Ω—ã–π –≤ –∫–∞–≤—ã—á–∫–∏ –ø–æ—Å–ª–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ extern —É–∫–∞–∑—ã–≤–∞–µ—Ç
// –±–∏–±–ª–∏–æ—Ç–µ–∫—É –≤ –∫–æ—Ç–æ—Ä–æ–π –µ—Å—Ç—å —Ñ—É–Ω–∫—Ü–∏—è. (–Ω–∞–ø—Ä–∏–º–µ—Ä, "c" -> libc.so)
// –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä callconv –∏–∑–º–µ–Ω—è–µ—Ç —Å–æ–≥–ª–∞—à–µ–Ω–∏–µ –æ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏.
const WINAPI: std.builtin.CallingConvention = if (native_arch == .x86) .Stdcall else .C;
extern "kernel32" fn ExitProcess(exit_code: u32) callconv(WINAPI) noreturn;
extern "c" fn atan2(a: f64, b: f64) f64;

// –í—Å—Ç—Ä–æ–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è @setCold —Å–æ–æ–±—â–∞–µ—Ç –æ–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä—É, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è —Ä–µ–¥–∫–æ.
fn abort() noreturn {
    @setCold(true);
    while (true) {}
}

// –ò–∑-–∑–∞ —Å–æ–≥–ª–∞—à–µ–Ω–∏—è –æ –≥–æ–ª–æ–º –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –∏–º–µ–µ—Ç –Ω–∏ –ø—Ä–æ–ª–æ–≥–∞, –Ω–∏ —ç–ø–∏–ª–æ–≥–∞.
// –≠—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–Ω–æ –ø—Ä–∏ –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å assembly.
fn _start() callconv(.Naked) noreturn {
    abort();
}

// –°–æ–≥–ª–∞—à–µ–Ω–∏–µ –æ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–º –≤—ã–∑–æ–≤–µ —Ç—Ä–µ–±—É–µ—Ç, —á—Ç–æ–±—ã —Ñ—É–Ω–∫—Ü–∏—è –±—ã–ª–∞ –≤—Å—Ç—Ä–æ–µ–Ω–∞ –≤–æ –≤—Å–µ –º–µ—Å—Ç–∞ –≤—ã–∑–æ–≤–∞.
// –ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–∞, —ç—Ç–æ –æ—à–∏–±–∫–∞ –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏.
inline fn shiftLeftOne(a: u32) u32 {
    return a << 1;
}

// –°–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ç–æ—Ä pub –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ.
// –í –¥—Ä—É–≥–æ–º —Ñ–∞–π–ª–µ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å @import –∏ –≤—ã–∑–≤–∞—Ç—å sub2
pub fn sub2(a: i8, b: i8) i8 {
    return a - b;
}

// –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–º–µ—é—Ç –ø—Ä–µ—Ñ–∏–∫—Å `*const `.
const Call2Op = *const fn (a: i8, b: i8) i8;
fn doOp(fnCall: Call2Op, op1: i8, op2: i8) i8 {
    return fnCall(op1, op2);
}

test "function" {
    try expect(doOp(add, 5, 6) == 11);
    try expect(doOp(sub2, 5, 6) == -1);
}
```
```bash
$ zig test test_functions.zig
1/1 test_functions.test.function...OK
All 1 tests passed.
```

–°—É—â–µ—Å—Ç–≤—É–µ—Ç —Ä–∞–∑–Ω–∏—Ü–∞ –º–µ–∂–¥—É —Ç–µ–ª–æ–º —Ñ—É–Ω–∫—Ü–∏–∏ –∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–º –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é. –¢–µ–ª–∞ —Ñ—É–Ω–∫—Ü–∏–π - —ç—Ç–æ —Ç–∏–ø—ã, –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–æ–ª—å–∫–æ –≤–æ –≤—Ä–µ–º—è
comptime, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –∏–∑–≤–µ—Å—Ç–Ω—ã –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.

#### Pass-by-value Parameters

–ü—Ä–∏–º–∏—Ç–∏–≤–Ω—ã–µ —Ç–∏–ø—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ —Ü–µ–ª—ã–µ —á–∏—Å–ª–∞ –∏ —á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π –ø–µ—Ä–µ–¥–∞–≤–∞–µ–º—ã–µ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∫–æ–ø–∏—Ä—É—é—Ç—Å—è, –∞
–∑–∞—Ç–µ–º –∫–æ–ø–∏—è –±—É–¥–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–∞ –≤ —Ç–µ–ª–µ —Ñ—É–Ω–∫—Ü–∏–∏. –≠—Ç–æ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è "–ø–µ—Ä–µ–¥–∞—á–µ–π –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é". –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –ø—Ä–∏–º–∏—Ç–∏–≤–Ω–æ–≥–æ —Ç–∏–ø–∞ –ø–æ —Å—É—Ç–∏
—è–≤–ª—è–µ—Ç—Å—è –±–µ—Å–ø–ª–∞—Ç–Ω—ã–º –∏ –æ–±—ã—á–Ω–æ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç –Ω–∏—á–µ–≥–æ, –∫—Ä–æ–º–µ —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ä–µ–≥–∏—Å—Ç—Ä–∞.

–°—Ç—Ä—É–∫—Ç—É—Ä—ã, –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –∏ –º–∞—Å—Å–∏–≤—ã –∏–Ω–æ–≥–¥–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –±–æ–ª–µ–µ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω—ã –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å—Å—ã–ª–∫–∏, –ø–æ—Å–∫–æ–ª—å–∫—É –∫–æ–ø–∏—è –º–æ–∂–µ—Ç
–±—ã—Ç—å —Å–∫–æ–ª—å —É–≥–æ–¥–Ω–æ –¥–æ—Ä–æ–≥–æ–π –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–∞–∑–º–µ—Ä–∞. –ö–æ–≥–¥–∞ —ç—Ç–∏ —Ç–∏–ø—ã –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤, **Zig** –º–æ–∂–µ—Ç –≤—ã–±—Ä–∞—Ç—å
–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –∏ –ø–µ—Ä–µ–¥–∞—á—É –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é –∏–ª–∏ –ø–æ —Å—Å—ã–ª–∫–µ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–æ–≥–æ, –∫–∞–∫–æ–π —Å–ø–æ—Å–æ–±, –ø–æ –º–Ω–µ–Ω–∏—é **Zig** –±—É–¥–µ—Ç –±—ã—Å—Ç—Ä–µ–µ.
–û—Ç—á–∞—Å—Ç–∏ —ç—Ç–æ —Å—Ç–∞–ª–æ –≤–æ–∑–º–æ–∂–Ω—ã–º –±–ª–∞–≥–æ–¥–∞—Ä—è —Ç–æ–º—É, —á—Ç–æ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã.

```zig
const Point = struct {
    x: i32,
    y: i32,
};

fn foo(point: Point) i32 {
    // –ó–¥–µ—Å—å "—Ç–æ—á–∫–∞" –º–æ–∂–µ—Ç –±—ã—Ç—å —Å—Å—ã–ª–∫–æ–π –∏–ª–∏ –∫–æ–ø–∏–µ–π. –¢–µ–ª–æ —Ñ—É–Ω–∫—Ü–∏–∏
    // –º–æ–∂–µ—Ç –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–Ω–∏—Ü—É –∏ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞—Ç—å –µ–µ –∫–∞–∫ –∑–Ω–∞—á–µ–Ω–∏–µ. –ë—É–¥—å—Ç–µ –æ—á–µ–Ω—å –æ—Å—Ç–æ—Ä–æ–∂–Ω—ã
    // –ø—Ä–∏–Ω–∏–º–∞—è –∞–¥—Ä–µ—Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ - –æ–Ω –¥–æ–ª–∂–µ–Ω –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—Ç—å—Å—è —Ç–∞–∫, –∫–∞–∫ –µ—Å–ª–∏ –±—ã
    // –∞–¥—Ä–µ—Å —Å—Ç–∞–Ω–µ—Ç –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–º –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ —Ñ—É–Ω–∫—Ü–∏–∏.
    return point.x + point.y;
}

const expect = @import("std").testing.expect;

test "pass struct to function" {
    try expect(foo(Point{ .x = 1, .y = 2 }) == 3);
}
```
```bash
$ zig test test_pass_by_reference_or_value.zig
1/1 test_pass_by_reference_or_value.test.pass struct to function...OK
All 1 tests passed.
```

–î–ª—è –≤–Ω–µ—à–Ω–∏—Ö —Ñ—É–Ω–∫—Ü–∏–π **Zig** —Å–ª–µ–¥—É–µ—Ç C ABI –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–π –ø–æ –∑–Ω–∞—á–µ–Ω–∏—é.

#### Function Parameter Type Inference

–ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ—É–Ω–∫—Ü–∏–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º `anytype` –≤–º–µ—Å—Ç–æ type. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ —Ç–∏–ø—ã –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –±—É–¥—É—Ç
–æ–ø—Ä–µ–¥–µ–ª–µ–Ω—ã –ø—Ä–∏ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ @TypeOf –∏ @TypeInfo –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º–æ–º —Ç–∏–ø–µ.

```zig
const expect = @import("std").testing.expect;

fn addFortyTwo(x: anytype) @TypeOf(x) {
    return x + 42;
}

test "fn type inference" {
    try expect(addFortyTwo(1) == 43);
    try expect(@TypeOf(addFortyTwo(1)) == comptime_int);
    const y: i64 = 2;
    try expect(addFortyTwo(y) == 44);
    try expect(@TypeOf(addFortyTwo(y)) == i64);
}
```
```bash
$ zig test test_fn_type_inference.zig
1/1 test_fn_type_inference.test.fn type inference...OK
All 1 tests passed.
```

#### inline fn

–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–µ–≤–æ–≥–æ —Å–ª–æ–≤–∞ `inline` –∫ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é —Ñ—É–Ω–∫—Ü–∏–∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ —Ç–æ–º—É, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏
–≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π –≤ –º–µ—Å—Ç–æ –≤—ã–∑–æ–≤–∞. –≠—Ç–æ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –Ω–∞–º–µ–∫–æ–º –Ω–∞ —Ç–æ, —á—Ç–æ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –∑–∞–º–µ—á–µ–Ω–æ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ —ç—Ç–∞–ø–æ–≤ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏,
–Ω–æ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ç–∏–ø—ã –∏ –∑–Ω–∞—á–µ–Ω–∏—è, –∑–∞–¥–µ–π—Å—Ç–≤–æ–≤–∞–Ω–Ω—ã–µ –≤ –≤—ã–∑–æ–≤–µ —Ñ—É–Ω–∫—Ü–∏–∏.

–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –æ–±—ã—á–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π, –∞—Ä–≥—É–º–µ–Ω—Ç—ã –≤ –º–µ—Å—Ç–µ –≤—ã–∑–æ–≤–∞ –≤—Å—Ç—Ä–æ–µ–Ω–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –∏–∑–≤–µ—Å—Ç–Ω—ã–µ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏,
–æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è –∫–∞–∫ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—Ä–µ–º–µ–Ω–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –≠—Ç–æ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –º–æ–∂–µ—Ç —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—Ç—å—Å—è –Ω–∞ –≤—Å–µ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ:

```zig
test "inline function call" {
    if (foo(1200, 34) != 1234) {
        @compileError("bad");
    }
}

inline fn foo(a: i32, b: i32) i32 {
    return a + b;
}
```
```bash
$ zig test inline_call.zig
1/1 inline_call.test.inline function call...OK
All 1 tests passed.
```

–ï—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è `inline` —É–¥–∞–ª–µ–Ω–∞, —Ç–µ—Å—Ç –∑–∞–≤–µ—Ä—à–∞–µ—Ç—Å—è —Å –æ—à–∏–±–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –∞ –Ω–µ —Å –ø–µ—Ä–µ–¥–∞—á–µ–π.

–û–±—ã—á–Ω–æ –ª—É—á—à–µ –ø–æ–∑–≤–æ–ª–∏—Ç—å –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É —Ä–µ—à–∞—Ç—å, –∫–æ–≥–¥–∞ –≤—Å—Ç—Ä–∞–∏–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏—é, –∑–∞ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ–º —ç—Ç–∏—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤:
- –î–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Å—Ç–µ–∫–æ–≤—ã—Ö —Ñ—Ä–µ–π–º–æ–≤ –≤ —Å—Ç–µ–∫–µ –≤—ã–∑–æ–≤–æ–≤ –≤ —Ü–µ–ª—è—Ö –æ—Ç–ª–∞–¥–∫–∏.
- –ß—Ç–æ–±—ã –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –ø–µ—Ä–µ–¥–∞–≤–∞–ª–æ—Å—å –Ω–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–∞–∫ –≤ –ø—Ä–∏–≤–µ–¥–µ–Ω–Ω–æ–º –≤—ã—à–µ –ø—Ä–∏–º–µ—Ä–µ.
- –≠—Ç–æ–≥–æ —Ç—Ä–µ–±—É—é—Ç –∏–∑–º–µ—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –º–∏—Ä–µ.

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ `inline` —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞. –≠—Ç–æ –º–æ–∂–µ—Ç –Ω–µ–≥–∞—Ç–∏–≤–Ω–æ —Å–∫–∞–∑–∞—Ç—å—Å—è –Ω–∞
—Ä–∞–∑–º–µ—Ä–µ –¥–≤–æ–∏—á–Ω–æ–≥–æ —Ñ–∞–π–ª–∞, —Å–∫–æ—Ä–æ—Å—Ç–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∏ –¥–∞–∂–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è.

#### Function Reflection

```zig
const std = @import("std");
const math = std.math;
const testing = std.testing;

test "fn reflection" {
    try testing.expect(@typeInfo(@TypeOf(testing.expect)).Fn.params[0].type.? == bool);
    try testing.expect(@typeInfo(@TypeOf(testing.tmpDir)).Fn.return_type.? == testing.TmpDir);

    try testing.expect(@typeInfo(@TypeOf(math.Log2Int)).Fn.is_generic);
}
```
```bash
$ zig test test_fn_reflection.zig
1/1 test_fn_reflection.test.fn reflection...OK
All 1 tests passed.
```

------------
### Errors

#### Error Set Type

–ù–∞–±–æ—Ä –æ—à–∏–±–æ–∫ –ø–æ—Ö–æ–∂ –Ω–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ. –û–¥–Ω–∞–∫–æ –∫–∞–∂–¥–æ–º—É –∏–º–µ–Ω–∏ –æ—à–∏–±–∫–∏ –≤–æ –≤—Å–µ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –±–µ–∑ –∑–Ω–∞–∫–∞,
–±–æ–ª—å—à–µ–µ 0. –í–∞–º —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –æ–±—ä—è–≤–ª—è—Ç—å –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ –∏–º—è –æ—à–∏–±–∫–∏ –±–æ–ª–µ–µ –æ–¥–Ω–æ–≥–æ —Ä–∞–∑–∞, –∏ –µ—Å–ª–∏ –≤—ã —ç—Ç–æ —Å–¥–µ–ª–∞–µ—Ç–µ –µ–º—É –±—É–¥–µ—Ç
–ø—Ä–∏—Å–≤–æ–µ–Ω–æ –æ–¥–Ω–æ –∏ —Ç–æ –∂–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.

–¢–∏–ø –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–∞–≤–µ–Ω `u16`, —Ö–æ—Ç—è, –µ—Å–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π –æ—à–∏–±–æ–∫ —É–∫–∞–∑–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é
–ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∫–æ–º–∞–Ω–¥–Ω–æ–π —Å—Ç—Ä–æ–∫–∏ --error-limit [num], –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º –±–∏—Ç–æ–≤
–Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–º –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ—Ö –∑–Ω–∞—á–µ–Ω–∏–π –æ—à–∏–±–æ–∫.

–í—ã –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –æ—à–∏–±–∫—É –∏–∑ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤ –Ω–∞–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ:
```zig
const std = @import("std");

const FileOpenError = error{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error{
    OutOfMemory,
};

test "coerce subset to superset" {
    const err = foo(AllocationError.OutOfMemory);
    try std.testing.expect(err == FileOpenError.OutOfMemory);
}

fn foo(err: AllocationError) FileOpenError {
    return err;
}
```
```bash
$ zig test test_coerce_error_subset_to_superset.zig
1/1 test_coerce_error_subset_to_superset.test.coerce subset to superset...OK
All 1 tests passed.
```

–ù–æ –≤—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø–µ—Ä–µ–Ω–µ—Å—Ç–∏ –æ—à–∏–±–∫—É –∏–∑ –Ω–∞–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞ –≤ –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ:

```zig
const FileOpenError = error{
    AccessDenied,
    OutOfMemory,
    FileNotFound,
};

const AllocationError = error{
    OutOfMemory,
};

test "coerce superset to subset" {
    foo(FileOpenError.OutOfMemory) catch {};
}

fn foo(err: FileOpenError) AllocationError {
    return err;
}
```
```bash

$ zig test test_coerce_error_superset_to_subset.zig
doc/langref/test_coerce_error_superset_to_subset.zig:16:12: error: expected type 'error{OutOfMemory}', found 'error{AccessDenied,OutOfMemory,FileNotFound}'
    return err;
           ^~~
doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.AccessDenied' not a member of destination error set
doc/langref/test_coerce_error_superset_to_subset.zig:16:12: note: 'error.FileNotFound' not a member of destination error set
doc/langref/test_coerce_error_superset_to_subset.zig:15:28: note: function return type declared here
fn foo(err: FileOpenError) AllocationError {
                           ^~~~~~~~~~~~~~~
referenced by:
    test.coerce superset to subset: doc/langref/test_coerce_error_superset_to_subset.zig:12:5
    remaining reference traces hidden; use '-freference-trace' to see all reference traces

```

–°—É—â–µ—Å—Ç–≤—É–µ—Ç —è—Ä–ª—ã–∫ –¥–ª—è –æ–±—ä—è–≤–ª–µ–Ω–∏—è –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ —Å–æ–¥–µ—Ä–∂–∞—â–µ–≥–æ —Ç–æ–ª—å–∫–æ 1 –∑–Ω–∞—á–µ–Ω–∏–µ –∏ –ø–æ—Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–æ–ª—É—á–µ–Ω–∏—è —ç—Ç–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è:
```zig
const err = error.FileNotFound;
```
–≠—Ç–æ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–æ:
```zig
const err = (error{FileNotFound}).FileNotFound;
```

–≠—Ç–æ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –ø–æ–ª–µ–∑–Ω—ã–º –ø—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º—ã—Ö –Ω–∞–±–æ—Ä–æ–≤ –æ—à–∏–±–æ–∫.

#### The Global Error Set

`anyerror` –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –≥–ª–æ–±–∞–ª—å–Ω–æ–º—É –Ω–∞–±–æ—Ä—É –æ—à–∏–±–æ–∫. –≠—Ç–æ –Ω–∞–±–æ—Ä –æ—à–∏–±–æ–∫, –∫–æ—Ç–æ—Ä—ã–π —Å–æ–¥–µ—Ä–∂–∏—Ç –≤—Å–µ –æ—à–∏–±–∫–∏ –≤–æ –≤—Å–µ–º –º–æ–¥—É–ª–µ
–∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –≠—Ç–æ –Ω–∞–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—Å–µ—Ö –¥—Ä—É–≥–∏—Ö –Ω–∞–±–æ—Ä–æ–≤ –æ—à–∏–±–æ–∫ –∏ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –ø–æ–¥–º–Ω–æ–∂–µ—Å—Ç–≤–æ–º –Ω–∏ –æ–¥–Ω–æ–≥–æ –∏–∑ –Ω–∏—Ö.

–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–∏—Å–≤–æ–∏—Ç—å –ª—é–±–æ–º—É –Ω–∞–±–æ—Ä—É –æ—à–∏–±–æ–∫ –∑–Ω–∞—á–µ–Ω–∏–µ global, –∏ –≤—ã –º–æ–∂–µ—Ç–µ —è–≤–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –æ—à–∏–±–∫—É –∏–∑ –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞
–æ—à–∏–±–æ–∫ –≤ –Ω–µ –≥–ª–æ–±–∞–ª—å–Ω—É—é. –ü—Ä–∏ —ç—Ç–æ–º –≤—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –Ω–∞ —É—Ä–æ–≤–Ω–µ —è–∑—ã–∫–∞ —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏
–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —Ü–µ–ª–µ–≤–æ–º –Ω–∞–±–æ—Ä–µ –æ—à–∏–±–æ–∫.

–ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, —Å–ª–µ–¥—É–µ—Ç –∏–∑–±–µ–≥–∞—Ç—å –≥–ª–æ–±–∞–ª—å–Ω–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫, –ø–æ—Å–∫–æ–ª—å–∫—É –æ–Ω –Ω–µ –ø–æ–∑–≤–æ–ª—è–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É —É–∑–Ω–∞—Ç—å –∫–∞–∫–∏–µ –æ—à–∏–±–∫–∏
–≤–æ–∑–º–æ–∂–Ω—ã –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ó–Ω–∞–Ω–∏–µ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ª—É—á—à–µ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ –∏ –ø–æ–ª–µ–∑–Ω—ã—Ö
—Å–æ–æ–±—â–µ–Ω–∏–π –æ–± –æ—à–∏–±–∫–∞—Ö —Ç–∞–∫–∏—Ö –∫–∞–∫ –∑–∞–±—ã–≤–∞–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω–æ–π –æ—à–∏–±–∫–∏ –≤ `switch`.

#### Error Union Type

–¢–∏–ø –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –∏ –æ–±—ã—á–Ω—ã–π —Ç–∏–ø –º–æ–≥—É—Ç –±—ã—Ç—å –æ–±—ä–µ–¥–∏–Ω–µ–Ω—ã —Å –ø–æ–º–æ—â—å—é –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ `!` –î–ª—è —Ñ–æ—Ä–º–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–∏–ø–∞
–æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫. –°–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –≤—ã –±—É–¥–µ—Ç–µ —á–∞—â–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç–∏–ø –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫ —á–µ–º —Ç–∏–ø –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ —Å–∞–º –ø–æ —Å–µ–±–µ.

–í–æ—Ç —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Å—Ç—Ä–æ–∫–∏ –≤ 64-—Ä–∞–∑—Ä—è–¥–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ:

```zig
const std = @import("std");
const maxInt = std.math.maxInt;

pub fn parseU64(buf: []const u8, radix: u8) !u64 {
    var x: u64 = 0;

    for (buf) |c| {
        const digit = charToDigit(c);

        if (digit >= radix) {
            return error.InvalidChar;
        }

        // x *= radix
        var ov = @mulWithOverflow(x, radix);
        if (ov[1] != 0) return error.OverFlow;

        // x += digit
        ov = @addWithOverflow(ov[0], digit);
        if (ov[1] != 0) return error.OverFlow;
        x = ov[0];
    }

    return x;
}

fn charToDigit(c: u8) u8 {
    return switch (c) {
        '0'...'9' => c - '0',
        'A'...'Z' => c - 'A' + 10,
        'a'...'z' => c - 'a' + 10,
        else => maxInt(u8),
    };
}

test "parse u64" {
    const result = try parseU64("1234", 10);
    try std.testing.expect(result == 1234);
}
```
```bash
$ zig test error_union_parsing_u64.zig
1/1 error_union_parsing_u64.test.parse u64...OK
All 1 tests passed.
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —Ç–∏–ø –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è - `!u64`. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ª–∏–±–æ 64-—Ä–∞–∑—Ä—è–¥–Ω–æ–µ —Ü–µ–ª–æ–µ
—á–∏—Å–ª–æ –±–µ–∑ –∑–Ω–∞–∫–∞ –ª–∏–±–æ –æ—à–∏–±–∫—É. –ú—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å–ª–µ–≤–∞ –æ—Ç `!` –ø–æ—ç—Ç–æ–º—É –≤—ã–≤–æ–¥–∏—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏–µ –æ—à–∏–±–∫–∏.

–í –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–∏ —Ñ—É–Ω–∫—Ü–∏–∏ –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–π `return`, –∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –æ—à–∏–±–∫—É, –∞ –≤–Ω–∏–∑—É - –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏—é
`return`, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç `u64`. –û–±–∞ —Ç–∏–ø–∞ –ø—Ä–∏–≤–æ–¥—è—Ç –∫ –ª—é–±–æ–π `error!u64`.

–ö–∞–∫ –≤—ã–≥–ª—è–¥–∏—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –≤—ã –ø—ã—Ç–∞–µ—Ç–µ—Å—å —Å–¥–µ–ª–∞—Ç—å.
–û–¥–Ω–æ –∏–∑ —Å–ª–µ–¥—É—é—â–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π:
- –í—ã —Ö–æ—Ç–∏—Ç–µ —É–∫–∞–∑–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –µ—Å–ª–∏ –æ–Ω–æ –≤–µ—Ä–Ω—É–ª–æ –æ—à–∏–±–∫—É.
- –ï—Å–ª–∏ –æ–Ω–æ –≤–µ—Ä–Ω—É–ª–æ –æ—à–∏–±–∫—É –≤—ã —Ö–æ—Ç–∏—Ç–µ –≤–µ—Ä–Ω—É—Ç—å —Ç—É –∂–µ –æ—à–∏–±–∫—É.
- –í—ã –∑–Ω–∞–µ—Ç–µ —Å –ø–æ–ª–Ω–æ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é, —á—Ç–æ –æ–Ω–æ –Ω–µ –≤–µ—Ä–Ω–µ—Ç –æ—à–∏–±–∫—É, –ø–æ—ç—Ç–æ–º—É —Ö–æ—Ç–∏—Ç–µ –±–µ–∑–æ–≥–æ–≤–æ—Ä–æ—á–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å –µ–µ.
- –í—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ–¥–ø—Ä–∏–Ω—è—Ç—å —Ä–∞–∑–ª–∏—á–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –¥–ª—è –∫–∞–∂–¥–æ–π –≤–æ–∑–º–æ–∂–Ω–æ–π –æ—à–∏–±–∫–∏.

##### catch

–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ —É–∫–∞–∑–∞—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥–≤–æ–∏—á–Ω—ã–π –æ–ø–µ—Ä–∞—Ç–æ—Ä `catch`:

```zig
const parseU64 = @import("error_union_parsing_u64.zig").parseU64;

fn doAThing(str: []u8) void {
    const number = parseU64(str, 10) catch 13;
    _ = number; // ...
}
```

–í —ç—Ç–æ–º –∫–æ–¥–µ `number` –±—É–¥–µ—Ç —Ä–∞–≤–Ω–æ —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω–æ–π —Å—Ç—Ä–æ–∫–µ –∏–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä–∞–≤–Ω–æ 13. –¢–∏–ø –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏
–±–∏–Ω–∞—Ä–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ `catch` –¥–æ–ª–∂–µ–Ω —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–æ–≤–∞—Ç—å —Ç–∏–ø—É unwrapped error union –∏–ª–∏ –±—ã—Ç—å —Ç–∏–ø–∞ `noreturn`.

–ï—Å–ª–∏ –≤—ã —Ö–æ—Ç–∏—Ç–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å –ø–æ–º–æ—â—å—é `catch` –ø–æ—Å–ª–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –Ω–µ–∫–æ—Ç–æ—Ä–æ–π –ª–æ–≥–∏–∫–∏, –≤—ã –º–æ–∂–µ—Ç–µ
–æ–±—ä–µ–¥–∏–Ω–∏—Ç—å `catch` —Å –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–º–∏ –±–ª–æ–∫–∞–º–∏:

```zig
const parseU64 = @import("error_union_parsing_u64.zig").parseU64;

fn doAThing(str: []u8) void {
    const number = parseU64(str, 10) catch blk: {
        // –¥–µ–ª–∞—Ç—å —á—Ç–æ-—Ç–æ
        break :blk 13;
    };
    _ = number; // —Ç–µ–ø–µ—Ä—å number –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω
}
```


##### try

–î–æ–ø—É—Å—Ç–∏–º, –≤—ã —Ö–æ—Ç–µ–ª–∏ –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É –µ—Å–ª–∏ –æ–Ω–∞ —É –≤–∞—Å –ø–æ—è–≤–∏–ª–∞—Å—å, –≤ –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –ø—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –ª–æ–≥–∏–∫—É
—Ñ—É–Ω–∫—Ü–∏–∏:

```zig
const parseU64 = @import("error_union_parsing_u64.zig").parseU64;

fn doAThing(str: []u8) !void {
    const number = parseU64(str, 10) catch |err| return err;
    _ = number; // ...
}
```

–î–ª—è —ç—Ç–æ–≥–æ –µ—Å—Ç—å –∫–æ—Ä–æ—Ç–∫–∏–π –ø—É—Ç—å. –í—ã—Ä–∞–∂–µ–Ω–∏–µ `try`:

```zig
const parseU64 = @import("error_union_parsing_u64.zig").parseU64;

fn doAThing(str: []u8) !void {
    const number = try parseU64(str, 10);
    _ = number; // ...
}
```
`try` –≤—ã—á–∏—Å–ª—è–µ—Ç –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å –æ—à–∏–±–∫–æ–π. –ï—Å–ª–∏ —ç—Ç–æ –æ—à–∏–±–∫–∞ —Ç–æ —Ç–µ–∫—É—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç–æ–π –∂–µ
–æ—à–∏–±–∫–æ–π. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è –±—É–¥–µ—Ç —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ.

–í–æ–∑–º–æ–∂–Ω–æ, –≤—ã —Å –ø–æ–ª–Ω–æ–π —É–≤–µ—Ä–µ–Ω–Ω–æ—Å—Ç—å—é –∑–Ω–∞–µ—Ç–µ, —á—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –±—É–¥–µ—Ç –æ—à–∏–±–∫–æ–π. –í —ç—Ç–æ–º —Å–ª—É—á–∞–µ –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å —ç—Ç–æ:

```zig
const number = parseU64("1234", 10) catch unreachable;
```

–ó–¥–µ—Å—å –º—ã —Ç–æ—á–Ω–æ –∑–Ω–∞–µ–º, —á—Ç–æ "1234" –±—É–¥–µ—Ç —É—Å–ø–µ—à–Ω–æ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ. –ü–æ—ç—Ç–æ–º—É –º—ã –ø–æ–º–µ—â–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ `unreachable` –≤ –ø—Ä–∞–≤—É—é —á–∞—Å—Ç—å.
`unreachable` –≤—ã–∑—ã–≤–∞–µ—Ç –ø–∞–Ω–∏–∫—É –≤ —Ä–µ–∂–∏–º–∞—Ö Debug –∏ ReleaseSafe –∏ –Ω–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ –≤ —Ä–µ–∂–∏–º–∞—Ö ReleaseFast –∏
ReleaseSmall. –ò—Ç–∞–∫, –≤–æ –≤—Ä–µ–º—è –æ—Ç–ª–∞–¥–∫–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –µ—Å–ª–∏ –±—ã –ø—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞, –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≤–µ—Ä—à–∏–ª–æ –±—ã —Ä–∞–±–æ—Ç—É
—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º.

–í–æ–∑–º–æ–∂–Ω–æ, –≤—ã –∑–∞—Ö–æ—Ç–∏—Ç–µ –≤—ã–ø–æ–ª–Ω–∏—Ç—å —Ä–∞–∑–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è –≤ –∫–∞–∂–¥–æ–π —Å–∏—Ç—É–∞—Ü–∏–∏. –î–ª—è —ç—Ç–æ–≥–æ –º—ã –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤—ã—Ä–∞–∂–µ–Ω–∏—è `if` –∏ `switch`:

```zig
fn doAThing(str: []u8) void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |err| switch (err) {
        error.Overflow => {
            // –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ...
        },
        // –º—ã –æ–±–µ—â–∞–µ–º, —á—Ç–æ InvalidChar –Ω–µ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç (–∏–ª–∏ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç —Å–±–æ–π –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏, –µ—Å–ª–∏ —ç—Ç–æ –ø—Ä–æ–∏–∑–æ–π–¥–µ—Ç)
        error.InvalidChar => unreachable,
    }
}
```

–ù–∞–∫–æ–Ω–µ—Ü, –≤–æ–∑–º–æ–∂–Ω–æ –≤–∞–º –∑–∞—Ö–æ—á–µ—Ç—Å—è –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å —Ç–æ–ª—å–∫–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ—à–∏–±–∫–∏. –î–ª—è —ç—Ç–æ–≥–æ –≤—ã –º–æ–∂–µ—Ç–µ –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –Ω–µ–æ–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ
–æ—à–∏–±–∫–∏ –≤ —Å–ª—É—á–∞–µ `else`, –∫–æ—Ç–æ—Ä—ã–π —Ç–µ–ø–µ—Ä—å —Å–æ–¥–µ—Ä–∂–∏—Ç –±–æ–ª–µ–µ —É–∑–∫–∏–π –Ω–∞–±–æ—Ä –æ—à–∏–±–æ–∫:

```zig
fn doAnotherThing(str: []u8) error{InvalidChar}!void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |err| switch (err) {
        error.Overflow => {
            // –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏–µ...
        },
        else => |leftover_err| return leftover_err,
    }
}
```

–í—ã –¥–æ–ª–∂–Ω—ã –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å–∏–Ω—Ç–∞–∫—Å–∏—Å –∑–∞—Ö–≤–∞—Ç–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π. –ï—Å–ª–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è –≤–∞–º –Ω–µ –Ω—É–∂–Ω–∞, –≤—ã –º–æ–∂–µ—Ç–µ –∑–∞—Ö–≤–∞—Ç–∏—Ç—å –µ–µ —Å –ø–æ–º–æ—â—å—é `_`
–∏ –∏–∑–±–µ–∂–∞—Ç—å `switch`.

```zig
fn doADifferentThing(str: []u8) void {
    if (parseU64(str, 10)) |number| {
        doSomethingWithNumber(number);
    } else |_| {
        // –¥–µ–ª–∞–π, –∫–∞–∫ —Ç–µ–±–µ —Ö–æ—á–µ—Ç—Å—è
    }
}
```

##### errdefer

–î—Ä—É–≥–∏–º –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–º –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —è–≤–ª—è—é—Ç—Å—è –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ `defer`. –í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –±–µ–∑—É—Å–ª–æ–≤–Ω–æ–º—É `defer`, –≤ **Zig** –µ—Å—Ç—å
`errdefer`, –∫–æ—Ç–æ—Ä—ã–π –≤—ã—á–∏—Å–ª—è–µ—Ç –æ—Ç–ª–æ–∂–µ–Ω–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –Ω–∞ –ø—É—Ç–∏ –≤—ã—Ö–æ–¥–∞ –∏–∑ –±–ª–æ–∫–∞ —Ç–æ–≥–¥–∞ –∏ —Ç–æ–ª—å–∫–æ —Ç–æ–≥–¥–∞, –∫–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è
–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∏–∑ –±–ª–æ–∫–∞.

–ü—Ä–∏–º–µ—Ä:
```zig
fn createFoo(param: i32) !Foo {
    const foo = try tryToAllocateFoo();
    // —Ç–µ–ø–µ—Ä—å –º—ã –≤—ã–¥–µ–ª–∏–ª–∏ foo, –Ω–∞–º –Ω—É–∂–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –µ–≥–æ –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è –æ—à–∏–±–∫–æ–π.
    // –Ω–æ –º—ã —Ö–æ—Ç–∏–º –≤–µ—Ä–Ω—É—Ç—å –µ–≥–æ, –µ—Å–ª–∏ —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏—Ç—Å—è —É—Å–ø–µ—à–Ω–æ.
    errdefer deallocateFoo(foo);

    const tmp_buf = allocateTmpBuffer() orelse return error.OutOfMemory;
    // tmp_buf - —ç—Ç–æ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–π —Ä–µ—Å—É—Ä—Å, –∏ –º—ã, –±–µ–∑—É—Å–ª–æ–≤–Ω–æ, —Ö–æ—Ç–∏–º –µ–≥–æ –æ—á–∏—Å—Ç–∏—Ç—å
    // –¥–æ —Ç–æ–≥–æ, –∫–∞–∫ —ç—Ç–æ—Ç –±–ª–æ–∫ –ø–æ–∫–∏–Ω–µ—Ç –æ–±–ª–∞—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏
    defer deallocateTmpBuffer(tmp_buf);

    if (param > 1337) return error.InvalidParam;

    // –∑–¥–µ—Å—å —Ñ—É–Ω–∫—Ü–∏—è errdefer –Ω–µ –±—É–¥–µ—Ç –∑–∞–ø—É—â–µ–Ω–∞, —Ç–∞–∫ –∫–∞–∫ –º—ã –≤–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —É—Å–ø–µ—à–Ω–æ–π —Ä–∞–±–æ—Ç—ã —Ñ—É–Ω–∫—Ü–∏–∏.
    // –Ω–æ —Ñ—É–Ω–∫—Ü–∏—è defer –±—É–¥–µ—Ç –∑–∞–ø—É—â–µ–Ω–∞!
    return foo;
}
```

–°–∞–º–æ–µ –ø—Ä–∏—è—Ç–Ω–æ–µ –≤ —ç—Ç–æ–º —Ç–æ, —á—Ç–æ –≤—ã –ø–æ–ª—É—á–∞–µ—Ç–µ –Ω–∞–¥–µ–∂–Ω—É—é –æ–±—Ä–∞–±–æ—Ç–∫—É –æ—à–∏–±–æ–∫ –±–µ–∑ –º–Ω–æ–≥–æ—Å–ª–æ–≤–∏—è –∏ –∫–æ–≥–Ω–∏—Ç–∏–≤–Ω—ã—Ö –∑–∞—Ç—Ä–∞—Ç, —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —Å
–ø–æ–ø—ã—Ç–∫–∞–º–∏ —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –ø—Ä–æ–π–¥–µ–Ω –∫–∞–∂–¥—ã–π –ø—É—Ç—å –∫ –≤—ã—Ö–æ–¥—É. –ö–æ–¥ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –≤—Å–µ–≥–¥–∞ —Å–ª–µ–¥—É–µ—Ç –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∑–∞ –∫–æ–¥–æ–º
–≤—ã–¥–µ–ª–µ–Ω–∏—è.

##### Common errdefer Slip-Ups

–°–ª–µ–¥—É–µ—Ç –æ—Ç–º–µ—Ç–∏—Ç—å, —á—Ç–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä—ã `errdefer` –¥–µ–π—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –¥–æ –∫–æ–Ω—Ü–∞ –±–ª–æ–∫–∞ –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–Ω–∏ –∑–∞–ø–∏—Å–∞–Ω—ã –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –Ω–µ
–≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ —ç—Ç–æ–≥–æ –±–ª–æ–∫–∞:

```zig
onst std = @import("std");
const Allocator = std.mem.Allocator;

const Foo = struct {
    data: u32,
};

fn tryToAllocateFoo(allocator: Allocator) !*Foo {
    return allocator.create(Foo);
}

fn deallocateFoo(allocator: Allocator, foo: *Foo) void {
    allocator.destroy(foo);
}

fn getFooData() !u32 {
    return 666;
}

fn createFoo(allocator: Allocator, param: i32) !*Foo {
    const foo = getFoo: {
        var foo = try tryToAllocateFoo(allocator);
        errdefer deallocateFoo(allocator, foo); // –î–µ–π—Å—Ç–≤—É–µ—Ç —Ç–æ–ª—å–∫–æ –¥–æ –∫–æ–Ω—Ü–∞ getFoo

        // –í—ã–∑—ã–≤–∞–µ—Ç deallocateFoo –ø—Ä–∏ –æ—à–∏–±–∫–µ
        foo.data = try getFooData();

        break :getFoo foo;
    };

    // –í—ã—Ö–æ–¥–∏—Ç –∑–∞ —Ä–∞–º–∫–∏ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ—à–∏–±–∫–∏, –ø–æ—ç—Ç–æ–º—É
    // deallocateFoo –∑–¥–µ—Å—å –≤—ã–∑—ã–≤–∞—Ç—å—Å—è –Ω–µ –±—É–¥–µ—Ç
    if (param > 1337) return error.InvalidParam;

    return foo;
}

test "createFoo" {
    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));
}
```
```bash
$ zig test test_errdefer_slip_ups.zig
1/1 test_errdefer_slip_ups.test.createFoo...OK
[gpa] (err): memory address 0x7f11f521a000 leaked:
/home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:9:28: 0x103d3cf in tryToAllocateFoo (test)
    return allocator.create(Foo);
                           ^
/home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:22:39: 0x103d5e5 in createFoo (test)
        var foo = try tryToAllocateFoo(allocator);
                                      ^
/home/andy/src/zig/doc/langref/test_errdefer_slip_ups.zig:39:62: 0x103d82d in test.createFoo (test)
    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));
                                                             ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104d2a0 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x104340b in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x103f9f9 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103f561 in _start (test)
    asm volatile (switch (native_arch) {
    ^

All 1 tests passed.
1 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/58c079cb550addefaa354f72d736afd7/test
```

–ß—Ç–æ–±—ã –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å, —á—Ç–æ `deallocateFoo` –ø—Ä–∞–≤–∏–ª—å–Ω–æ –≤—ã–∑—ã–≤–∞–µ—Ç—Å—è –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –æ—à–∏–±–∫–∏, –≤—ã –¥–æ–ª–∂–Ω—ã –¥–æ–±–∞–≤–∏—Ç—å `errdefer` –≤–Ω–µ
–±–ª–æ–∫–∞:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const Foo = struct {
    data: u32,
};

fn tryToAllocateFoo(allocator: Allocator) !*Foo {
    return allocator.create(Foo);
}

fn deallocateFoo(allocator: Allocator, foo: *Foo) void {
    allocator.destroy(foo);
}

fn getFooData() !u32 {
    return 666;
}

fn createFoo(allocator: Allocator, param: i32) !*Foo {
    const foo = getFoo: {
        var foo = try tryToAllocateFoo(allocator);
        errdefer deallocateFoo(allocator, foo);

        foo.data = try getFooData();

        break :getFoo foo;
    };
    // –≠—Ç–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –¥–æ –∫–æ–Ω—Ü–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏
    errdefer deallocateFoo(allocator, foo);

    // –û—à–∏–±–∫–∞ —Ç–µ–ø–µ—Ä—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è errdefer
    if (param > 1337) return error.InvalidParam;

    return foo;
}

test "createFoo" {
    try std.testing.expectError(error.InvalidParam, createFoo(std.testing.allocator, 2468));
}
```
```bash
$ zig test test_errdefer_block.zig
1/1 test_errdefer_block.test.createFoo...OK
All 1 tests passed.
```

–¢–æ—Ç —Ñ–∞–∫—Ç, —á—Ç–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –æ—à–∏–±–æ–∫ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–æ–≥–æ –±–ª–æ–∫–∞, –≤ –∫–æ—Ç–æ—Ä–æ–º –æ–Ω–∏ –æ–±—ä—è–≤–ª–µ–Ω—ã, –æ—Å–æ–±–µ–Ω–Ω–æ –≤–∞–∂–µ–Ω –ø—Ä–∏
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏ —Ü–∏–∫–ª–æ–≤:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const Foo = struct { data: *u32 };

fn getData() !u32 {
    return 666;
}

fn genFoos(allocator: Allocator, num: usize) ![]Foo {
    const foos = try allocator.alloc(Foo, num);
    errdefer allocator.free(foos);

    for (foos, 0..) |*foo, i| {
        foo.data = try allocator.create(u32);
        // –≠—Ç–∞ –æ—à–∏–±–∫–∞ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è –º–µ–∂–¥—É –∏—Ç–µ—Ä–∞—Ü–∏—è–º–∏
        errdefer allocator.destroy(foo.data);

        // –î–∞–Ω–Ω—ã–µ –∑–∞ –ø–µ—Ä–≤—ã–µ 3 –º–µ—Å—è—Ü–∞ –±—É–¥—É—Ç —É—Ç–µ—á–µ–Ω—ã
        if (i >= 3) return error.TooManyFoos;

        foo.data.* = try getData();
    }

    return foos;
}

test "genFoos" {
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
}
```
```bash
$ zig test test_errdefer_loop_leak.zig
1/1 test_errdefer_loop_leak.test.genFoos...OK
[gpa] (err): memory address 0x7f57c7578000 leaked:
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)
        foo.data = try allocator.create(u32);
                                       ^
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
                                                          ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)
    asm volatile (switch (native_arch) {
    ^

[gpa] (err): memory address 0x7f57c7578004 leaked:
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)
        foo.data = try allocator.create(u32);
                                       ^
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
                                                          ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)
    asm volatile (switch (native_arch) {
    ^

[gpa] (err): memory address 0x7f57c7578008 leaked:
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:15:40: 0x103d7a6 in genFoos (test)
        foo.data = try allocator.create(u32);
                                       ^
/home/andy/src/zig/doc/langref/test_errdefer_loop_leak.zig:29:59: 0x103e0dd in test.genFoos (test)
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
                                                          ^
/home/andy/src/zig/lib/compiler/test_runner.zig:157:25: 0x104e010 in mainTerminal (test)
        if (test_fn.func()) |_| {
                        ^
/home/andy/src/zig/lib/compiler/test_runner.zig:37:28: 0x1043eab in main (test)
        return mainTerminal();
                           ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x10402a9 in posixCallMainAndExit (test)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x103fe11 in _start (test)
    asm volatile (switch (native_arch) {
    ^

All 1 tests passed.
3 errors were logged.
1 tests leaked memory.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/29fcda275b7c426418534b679850fa2e/test
```

–° –∫–æ–¥–æ–º, –∫–æ—Ç–æ—Ä—ã–π –≤—ã–¥–µ–ª—è–µ—Ç –¥–∞–Ω–Ω—ã–µ –≤ —Ü–∏–∫–ª–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–æ–±–ª—é–¥–∞—Ç—å –æ—Å–æ–±—É—é –æ—Å—Ç–æ—Ä–æ–∂–Ω–æ—Å—Ç—å, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è –≤ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —É—Ç–µ—á–∫–∏
–ø–∞–º—è—Ç–∏ –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –æ—à–∏–±–∫–∏:

```zig
const std = @import("std");
const Allocator = std.mem.Allocator;

const Foo = struct { data: *u32 };

fn getData() !u32 {
    return 666;
}

fn genFoos(allocator: Allocator, num: usize) ![]Foo {
    const foos = try allocator.alloc(Foo, num);
    errdefer allocator.free(foos);

    // –ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è —Ç–æ–≥–æ, —Å–∫–æ–ª—å–∫–æ foo –±—ã–ª–æ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ
    // (–≤–∫–ª—é—á–∞—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –∏—Ö –¥–∞–Ω–Ω—ã—Ö)
    var num_allocated: usize = 0;
    errdefer for (foos[0..num_allocated]) |foo| {
        allocator.destroy(foo.data);
    };
    for (foos, 0..) |*foo, i| {
        foo.data = try allocator.create(u32);
        num_allocated += 1;

        if (i >= 3) return error.TooManyFoos;

        foo.data.* = try getData();
    }

    return foos;
}

test "genFoos" {
    try std.testing.expectError(error.TooManyFoos, genFoos(std.testing.allocator, 5));
}
```
```bash
$ zig test test_errdefer_loop.zig
1/1 test_errdefer_loop.test.genFoos...OK
All 1 tests passed.
```

–ï—â–µ –ø–∞—Ä–∞ –ª–∞–∫–æ–º—ã—Ö –∫—É—Å–æ—á–∫–æ–≤ –æ–± –æ–±—Ä–∞–±–æ—Ç–∫–µ –æ—à–∏–±–æ–∫:
- –≠—Ç–∏ –ø—Ä–∏–º–∏—Ç–∏–≤—ã –æ–±–µ—Å–ø–µ—á–∏–≤–∞—é—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—É—é –≤—ã—Ä–∞–∑–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Ç–∞–∫ —á—Ç–æ –≤–ø–æ–ª–Ω–µ –ø—Ä–∞–∫—Ç–∏—á–Ω–æ –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –Ω–∞–ª–∏—á–∏–µ
–æ—à–∏–±–∫–∏ —è–≤–ª—è–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π –∫–æ–º–ø–∏–ª—è—Ü–∏–∏. –ï—Å–ª–∏ –≤—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å –æ—à–∏–±–∫—É, –≤—ã –º–æ–∂–µ—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å `catch`
`unreachable` –∏ –ø–æ–ª—É—á–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –æ—Ç —Å–±–æ—è –≤ —Ä–µ–∂–∏–º–∞—Ö Debug –∏ ReleaseSafe, –µ—Å–ª–∏ –≤–∞—à–µ –ø—Ä–µ–¥–ø–æ–ª–æ–∂–µ–Ω–∏–µ –±—ã–ª–æ
–Ω–µ–≤–µ—Ä–Ω—ã–º.
- –ü–æ—Å–∫–æ–ª—å–∫—É **Zig** –ø–æ–Ω–∏–º–∞–µ—Ç —Ç–∏–ø—ã –æ—à–∏–±–æ–∫, –æ–Ω –º–æ–∂–µ—Ç –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –≤–∑–≤–µ—Å–∏—Ç—å –≤–µ—Ç–≤–∏ –≤ –ø–æ–ª—å–∑—É —Ç–æ–≥–æ, —á—Ç–æ –æ—à–∏–±–∫–∏ –Ω–µ –≤–æ–∑–Ω–∏–∫–∞—é—Ç.
–ü—Ä–æ—Å—Ç–æ –Ω–µ–±–æ–ª—å—à–æ–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–æ –≤ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏, –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ–µ –Ω–∞ –¥—Ä—É–≥–∏—Ö —è–∑—ã–∫–∞—Ö.

–û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –æ—à–∏–±–∫–æ–π —Å–æ–∑–¥–∞–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –±–∏–Ω–∞—Ä–Ω–æ–≥–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞ `!`. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –æ—Ç—Ä–∞–∂–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏
–¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–æ—á–µ—Ä–Ω–µ–º—É —Ç–∏–ø—É –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å –æ—à–∏–±–∫–æ–π:

```zig
const expect = @import("std").testing.expect;

test "error union" {
    var foo: anyerror!i32 = undefined;

    // –ò–∑–≤–ª–µ–∫–∞—Ç—å –∏–∑ –¥–æ—á–µ—Ä–Ω–µ–≥–æ —Ç–∏–ø–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫:
    foo = 1234;

    // –ò–∑–≤–ª–µ–∫–∞—Ç—å –∏–∑ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫:
    foo = error.SomeError;

    // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç–∏–ø—É –ø–æ–ª–µ–∑–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫:
    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.payload == i32);

    // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç–∏–ø—É –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫:
    try comptime expect(@typeInfo(@TypeOf(foo)).ErrorUnion.error_set == anyerror);
}
```
```bash
$ zig test test_error_union.zig
1/1 test_error_union.test.error union...OK
All 1 tests passed.
```

##### Merging Error Sets

–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä `||` —á—Ç–æ–±—ã –æ–±—ä–µ–¥–∏–Ω–∏—Ç—å –¥–≤–∞ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫. –†–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π –Ω–∞–±–æ—Ä –æ—à–∏–±–æ–∫ —Å–æ–¥–µ—Ä–∂–∏—Ç –æ—à–∏–±–∫–∏ –∏–∑ –æ–±–æ–∏—Ö
–Ω–∞–±–æ—Ä–æ–≤ –æ—à–∏–±–æ–∫. –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞–º –≤ –ª–µ–≤–æ–π —á–∞—Å—Ç–∏ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è—é—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞–º –≤ –ø—Ä–∞–≤–æ–π —á–∞—Å—Ç–∏. –í —ç—Ç–æ–º
–ø—Ä–∏–º–µ—Ä–µ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ doc –¥–ª—è `C.PathNotFound` - —ç—Ç–æ –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π `doc`.

–≠—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–æ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç —Ä–∞–∑–Ω—ã–µ –Ω–∞–±–æ—Ä—ã –æ—à–∏–±–æ–∫ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –≤–µ—Ç–≤–µ–π comptime. –ù–∞–ø—Ä–∏–º–µ—Ä,
—Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è –±–∏–±–ª–∏–æ—Ç–µ–∫–∞ **Zig** –∏—Å–ø–æ–ª—å–∑—É–µ—Ç `LinuxFileOpenError || WindowsFileOpenError` –¥–ª—è –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏
—Ñ–∞–π–ª–æ–≤.

```zig
const A = error{
    NotDir,

    /// A –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É
    PathNotFound,
};
const B = error{
    OutOfMemory,

    /// B –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π –∫ –¥–æ–∫—É–º–µ–Ω—Ç—É
    PathNotFound,
};

const C = A || B;

fn foo() C!void {
    return error.NotDir;
}

test "merge error sets" {
    if (foo()) {
        @panic("unexpected");
    } else |err| switch (err) {
        error.OutOfMemory => @panic("unexpected"),
        error.PathNotFound => @panic("unexpected"),
        error.NotDir => {},
    }
}
```
```bash
$ zig test test_merging_error_sets.zig
1/1 test_merging_error_sets.test.merge error sets...OK
All 1 tests passed.
```

##### Inferred Error Sets

–ü–æ—Å–∫–æ–ª—å–∫—É –º–Ω–æ–≥–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ –≤ **Zig** –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç –≤–æ–∑–º–æ–∂–Ω—É—é –æ—à–∏–±–∫—É, **Zig** –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç –≤—ã–≤–æ–¥ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫. –ß—Ç–æ–±—ã –≤—ã–≤–µ—Å—Ç–∏ –Ω–∞–±–æ—Ä
–æ—à–∏–±–æ–∫ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏, –¥–æ–±–∞–≤—å—Ç–µ –æ–ø–µ—Ä–∞—Ç–æ—Ä `!` –∫ —Ç–∏–ø—É –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ñ—É–Ω–∫—Ü–∏–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä `!T`:

```zig
// –° —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º –≤—ã–≤–æ–¥–æ–º –æ–± –æ—à–∏–±–∫–µ
pub fn add_inferred(comptime T: type, a: T, b: T) !T {
    const ov = @addWithOverflow(a, b);
    if (ov[1] != 0) return error.Overflow;
    return ov[0];
}

// –° —è–≤–Ω–æ –∑–∞–¥–∞–Ω–Ω–æ–π –æ—à–∏–±–∫–æ–π
pub fn add_explicit(comptime T: type, a: T, b: T) Error!T {
    const ov = @addWithOverflow(a, b);
    if (ov[1] != 0) return error.Overflow;
    return ov[0];
}

const Error = error{
    Overflow,
};

const std = @import("std");

test "inferred error set" {
    if (add_inferred(u8, 255, 1)) |_| unreachable else |err| switch (err) {
        error.Overflow => {}, // ok
    }
}
```
```bash
$ zig test test_inferred_error_sets.zig
1/1 test_inferred_error_sets.test.inferred error set...OK
All 1 tests passed.
```

–ö–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å–æ–¥–µ—Ä–∂–∏—Ç –Ω–∞–±–æ—Ä –≤—ã–≤–æ–¥–∏–º—ã—Ö –æ—à–∏–±–æ–∫, —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω–æ–π –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ, —Å –Ω–µ–π —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è
—Å–ª–æ–∂–Ω–µ–µ –≤—ã–ø–æ–ª–Ω—è—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–µ –¥–µ–π—Å—Ç–≤–∏—è, —Ç–∞–∫–∏–µ –∫–∞–∫ –ø–æ–ª—É—á–µ–Ω–∏–µ —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–∞ —Ñ—É–Ω–∫—Ü–∏—é –∏–ª–∏ —Å–æ–∑–¥–∞–Ω–∏–µ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –∫–æ—Ç–æ—Ä—ã–π
–±—ã–ª –±—ã —Å–æ–≥–ª–∞—Å–æ–≤–∞–Ω –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ü–µ–ª–µ–π —Å–±–æ—Ä–∫–∏. –ö—Ä–æ–º–µ —Ç–æ–≥–æ, –≤—ã–≤–æ–¥–∏–º—ã–µ –Ω–∞–±–æ—Ä—ã –æ—à–∏–±–æ–∫ –Ω–µ—Å–æ–≤–º–µ—Å—Ç–∏–º—ã —Å —Ä–µ–∫—É—Ä—Å–∏–µ–π.

–í —Ç–∞–∫–∏—Ö —Å–∏—Ç—É–∞—Ü–∏—è—Ö —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —è–≤–Ω—ã–π –Ω–∞–±–æ—Ä –æ—à–∏–±–æ–∫. –ö–∞–∫ –ø—Ä–∞–≤–∏–ª–æ, –≤—ã –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å —Å –ø—É—Å—Ç–æ–≥–æ –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –∏
–ø–æ–∑–≤–æ–ª–∏—Ç—å –æ—à–∏–±–∫–∞–º –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –Ω–∞–ø—Ä–∞–≤–ª—è—Ç—å –≤–∞—Å –∫ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—é –Ω–∞–±–æ—Ä–∞.

–≠—Ç–∏ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å —É—Å—Ç—Ä–∞–Ω–µ–Ω—ã –≤ –±—É–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏ **Zig**.

#### Error Return Traces

–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–æ–∫ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –≤—Å–µ —Ç–æ—á–∫–∏ –≤ –∫–æ–¥–µ, –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã–∑—ã–≤–∞—é—â–∞—è —Ñ—É–Ω–∫—Ü–∏—è –≤–µ—Ä–Ω—É–ª–∞ –æ—à–∏–±–∫—É. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç
–ø—Ä–∞–∫—Ç–∏—á–Ω—ã–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ try everywhere –∏ –ø–æ–∑–≤–æ–ª—è–µ—Ç –ø–æ-–ø—Ä–µ–∂–Ω–µ–º—É –∑–Ω–∞—Ç—å, —á—Ç–æ –ø—Ä–æ–∏–∑–æ—à–ª–æ –µ—Å–ª–∏ –æ—à–∏–±–∫–∞ –≤ –∫–æ–Ω–µ—á–Ω–æ–º –∏—Ç–æ–≥–µ
"–≤—ã—à–ª–∞" –∏–∑ –≤–∞—à–µ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è.

```zig
pub fn main() !void {
    try foo(12);
}

fn foo(x: i32) !void {
    if (x >= 5) {
        try bar();
    } else {
        try bang2();
    }
}

fn bar() !void {
    if (baz()) {
        try quux();
    } else |err| switch (err) {
        error.FileNotFound => try hello(),
    }
}

fn baz() !void {
    try bang1();
}

fn quux() !void {
    try bang2();
}

fn hello() !void {
    try bang2();
}

fn bang1() !void {
    return error.FileNotFound;
}

fn bang2() !void {
    return error.PermissionDenied;
}
```
```bash
$ zig build-exe error_return_trace.zig
$ ./error_return_trace
error: PermissionDenied
/home/andy/src/zig/doc/langref/error_return_trace.zig:34:5: 0x1034e08 in bang1 (error_return_trace)
    return error.FileNotFound;
    ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:22:5: 0x1034f13 in baz (error_return_trace)
    try bang1();
    ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:38:5: 0x1034f38 in bang2 (error_return_trace)
    return error.PermissionDenied;
    ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:30:5: 0x1034fa3 in hello (error_return_trace)
    try bang2();
    ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:17:31: 0x103505a in bar (error_return_trace)
        error.FileNotFound => try hello(),
                              ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:7:9: 0x1035140 in foo (error_return_trace)
        try bar();
        ^
/home/andy/src/zig/doc/langref/error_return_trace.zig:2:5: 0x1035198 in main (error_return_trace)
    try foo(12);
    ^
```

–ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ –Ω–∞ —ç—Ç–æ—Ç –ø—Ä–∏–º–µ—Ä. –≠—Ç–æ –Ω–µ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ —Å—Ç–µ–∫–∞.

–í—ã –º–æ–∂–µ—Ç–µ –≤–∏–¥–µ—Ç—å, —á—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞, –∫–æ—Ç–æ—Ä–∞—è –≤–æ–∑–Ω–∏–∫–ª–∞, –±—ã–ª–∞ `PermissionDenied`, –Ω–æ –∏—Å—Ö–æ–¥–Ω–æ–π –æ—à–∏–±–∫–æ–π, –∏–∑-–∑–∞ –∫–æ—Ç–æ—Ä–æ–π –≤—Å–µ
—ç—Ç–æ –Ω–∞—á–∞–ª–æ—Å—å, –±—ã–ª `FileNotFound`. –í —Ñ—É–Ω–∫—Ü–∏–∏ `bar` –∫–æ–¥ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –∏—Å—Ö–æ–¥–Ω—ã–π –∫–æ–¥ –æ—à–∏–±–∫–∏, –∞ –∑–∞—Ç–µ–º –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –¥—Ä—É–≥–æ–π, –∏–∑
–∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ `switch`. –¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏ –¥–µ–ª–∞–µ—Ç —ç—Ç–æ –ø–æ–Ω—è—Ç–Ω—ã–º, –≤ —Ç–æ –≤—Ä–µ–º—è –∫–∞–∫ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ —Å—Ç–µ–∫–∞ –≤—ã–≥–ª—è–¥–µ–ª–∞ –±—ã
—Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

```zig
pub fn main() void {
    foo(12);
}

fn foo(x: i32) void {
    if (x >= 5) {
        bar();
    } else {
        bang2();
    }
}

fn bar() void {
    if (baz()) {
        quux();
    } else {
        hello();
    }
}

fn baz() bool {
    return bang1();
}

fn quux() void {
    bang2();
}

fn hello() void {
    bang2();
}

fn bang1() bool {
    return false;
}

fn bang2() void {
    @panic("PermissionDenied");
}
```
```bash
$ zig build-exe stack_trace.zig
$ ./stack_trace
thread 3570764 panic: PermissionDenied
/home/andy/src/zig/doc/langref/stack_trace.zig:38:5: 0x1039320 in bang2 (stack_trace)
    @panic("PermissionDenied");
    ^
/home/andy/src/zig/doc/langref/stack_trace.zig:30:10: 0x1068bd8 in hello (stack_trace)
    bang2();
         ^
/home/andy/src/zig/doc/langref/stack_trace.zig:17:14: 0x10392fc in bar (stack_trace)
        hello();
             ^
/home/andy/src/zig/doc/langref/stack_trace.zig:7:12: 0x103721c in foo (stack_trace)
        bar();
           ^
/home/andy/src/zig/doc/langref/stack_trace.zig:2:8: 0x103519d in main (stack_trace)
    foo(12);
       ^
/home/andy/src/zig/lib/std/start.zig:514:22: 0x1034a49 in posixCallMainAndExit (stack_trace)
            root.main();
                     ^
/home/andy/src/zig/lib/std/start.zig:266:5: 0x10345b1 in _start (stack_trace)
    asm volatile (switch (native_arch) {
    ^
???:?:?: 0x0 in ??? (???)
(process terminated by signal)
```

–ó–¥–µ—Å—å —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ —Å—Ç–µ–∫–∞ –Ω–µ –æ–±—ä—è—Å–Ω—è–µ—Ç, –∫–∞–∫ –ø–æ—Ç–æ–∫ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –≤ `bar` –¥–æ—à–µ–ª –¥–æ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏ `hello()`. –ß—Ç–æ–±—ã –≤—ã—è—Å–Ω–∏—Ç—å
—ç—Ç–æ –Ω—É–∂–Ω–æ –±—ã–ª–æ –±—ã –æ—Ç–∫—Ä—ã—Ç—å –æ—Ç–ª–∞–¥—á–∏–∫ –∏–ª–∏ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–æ—Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ. –° –¥—Ä—É–≥–æ–π —Å—Ç–æ—Ä–æ–Ω—ã, —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—Ç–∞
–æ—à–∏–±–∫–∏ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–∞–∫ –∏–º–µ–Ω–Ω–æ –≤–æ–∑–Ω–∏–∫–ª–∞ –æ—à–∏–±–∫–∞.

–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ—Ç–ª–∞–¥–∫–∏ —É–ø—Ä–æ—â–∞–µ—Ç –±—ã—Å—Ç—Ä—É—é –∏—Ç–µ—Ä–∞—Ü–∏—é –∫–æ–¥–∞ –∫–æ—Ç–æ—Ä—ã–π –Ω–∞–¥–µ–∂–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—Å–µ —É—Å–ª–æ–≤–∏—è –æ—à–∏–±–∫–∏. –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ
—Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞–º **Zig**, –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ –ø—Ä–∏–¥–µ—Ç—Å—è –ø–∏—Å–∞—Ç—å –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π, –Ω–∞–¥–µ–∂–Ω—ã–π –∫–æ–¥ —á—Ç–æ–±—ã —É—Å–∫–æ—Ä–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏.

–¢—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º—ã—Ö –æ—à–∏–±–æ–∫ –≤–∫–ª—é—á–µ–Ω–∞ –ø–æ-—É–º–æ–ª—á–∞–Ω–∏—é –≤ —Å–±–æ—Ä–∫–∞—Ö Debug –∏ ReleaseSafe –∏ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ —Å–±–æ—Ä–∫–∞—Ö
ReleaseFast –∏ —Å–±–æ—Ä–∫–∞—Ö ReleaseSmall.

–°—É—â–µ—Å—Ç–≤—É–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–ø–æ—Å–æ–±–æ–≤ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å —ç—Ç—É —Ñ—É–Ω–∫—Ü–∏—é –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–æ–∫:
- –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç –æ—à–∏–±–∫—É –∏–∑ main
- –û—à–∏–±–∫–∞ –ø–æ–ø–∞–¥–∞–µ—Ç –≤ `catch` `unreachable`, –∏ –≤—ã –Ω–µ –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–∏–ª–∏ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∞–≤–∞—Ä–∏–π–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
- –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ errorReturnTrace –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ç–µ–∫—É—â–µ–π –≤–æ–∑–≤—Ä–∞—â–∞–µ–º–æ–π —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–µ. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å
`std.debug.dumpStackTrace`, —á—Ç–æ–±—ã —Ä–∞—Å–ø–µ—á–∞—Ç–∞—Ç—å –µ–≥–æ. –≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ `null`, –∏–∑–≤–µ—Å—Ç–Ω–æ–µ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
–∫–æ–º–ø–∏–ª—è—Ü–∏–∏, –ø—Ä–∏ —Å–±–æ—Ä–∫–µ –±–µ–∑ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–æ–∫.

##### Implementation Details

–ß—Ç–æ–±—ã –ø—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –∑–∞—Ç—Ä–∞—Ç—ã –Ω–∞ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å, —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º –¥–≤–∞ —Å–ª—É—á–∞—è:
- –∫–æ–≥–¥–∞ –æ—à–∏–±–∫–∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è
- –ø—Ä–∏ –≤–æ–∑–≤—Ä–∞—Ç–µ –æ—à–∏–±–æ–∫

–í —Å–ª—É—á–∞–µ –∫–æ–≥–¥–∞ –æ—à–∏–±–∫–∏ –Ω–µ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç –æ–¥–Ω—É –æ–ø–µ—Ä–∞—Ü–∏—é –∑–∞–ø–∏—Å–∏ –≤ –ø–∞–º—è—Ç—å, —Ç–æ–ª—å–∫–æ –≤ –ø–µ—Ä–≤–æ–π —Ñ—É–Ω–∫—Ü–∏–∏ —Å
–æ—Ç–∫–∞–∑–æ—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å—é –≤ –≥—Ä–∞—Ñ–µ –≤—ã–∑–æ–≤–æ–≤, –∫–æ—Ç–æ—Ä–∞—è –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é —Å –æ—Ç–∫–∞–∑–æ—É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å—é, —Ç.–µ, –∫–æ–≥–¥–∞ —Ñ—É–Ω–∫—Ü–∏—è –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∞—è
–∑–Ω–∞—á–µ–Ω–∏–µ `void` –≤—ã–∑—ã–≤–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏—é –≤–æ–∑–≤—Ä–∞—â–∞—é—â—É—é –æ—à–∏–±–∫—É. –≠—Ç–æ –¥–µ–ª–∞–µ—Ç—Å—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —ç—Ç–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤ —Å—Ç–µ–∫–æ–≤–æ–π –ø–∞–º—è—Ç–∏:

```zig
pub const StackTrace = struct {
    index: usize,
    instruction_addresses: [N]usize,
};
```

–ó–¥–µ—Å—å N - –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –≥–ª—É–±–∏–Ω–∞ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏, –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–∞—è —Å –ø–æ–º–æ—â—å—é –∞–Ω–∞–ª–∏–∑–∞ –≥—Ä–∞—Ñ–∞ –≤—ã–∑–æ–≤–æ–≤. –†–µ–∫—É—Ä—Å–∏—è –∏–≥–Ω–æ—Ä–∏—Ä—É–µ—Ç—Å—è –∏
–∑–∞—Å—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è –∑–∞ 2.

–£–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ `StackTrace` –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Å–µ–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ –∫–∞–∂–¥–æ–π —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –≤–æ–∑–≤—Ä–∞—â–∞—Ç—å –æ—à–∏–±–∫—É, –Ω–æ
—ç—Ç–æ –≤—Å–µ–≥–¥–∞ –ø–µ—Ä–≤—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, –ø–æ—ç—Ç–æ–º—É –æ–Ω, —Å–∫–æ—Ä–µ–µ –≤—Å–µ–≥–æ, –º–æ–∂–µ—Ç –Ω–∞—Ö–æ–¥–∏—Ç—å—Å—è –≤ —Ä–µ–≥–∏—Å—Ç—Ä–µ –∏ –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è —Ç–∞–º.

–í–æ—Ç –∏ –≤—Å–µ –¥–ª—è –ø—É—Ç–∏ –∫–æ–≥–¥–∞ –æ—à–∏–±–æ–∫ –Ω–µ –≤–æ–∑–Ω–∏–∫–∞–µ—Ç. –≠—Ç–æ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –±–µ—Å–ø–ª–∞—Ç–Ω–æ —Å —Ç–æ—á–∫–∏ –∑—Ä–µ–Ω–∏—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏.

–ü—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–¥–∞ –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–∏, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–µ–π –æ—à–∏–±–∫—É, –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –ø–µ—Ä–µ–¥ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `return` (—Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤
`return`, –≤–æ–∑–≤—Ä–∞—â–∞—é—â–∏—Ö –æ—à–∏–±–∫–∏) **Zig** –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≤—ã–∑–æ–≤ —ç—Ç–æ–π —Ñ—É–Ω–∫—Ü–∏–∏:

```zig
// –ø–æ–º–µ—á–µ–Ω –∫–∞–∫ "–Ω–µ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–π" –≤ LLVM IR
fn __zig_return_error(stack_trace: *StackTrace) void {
    stack_trace.instruction_addresses[stack_trace.index] = @returnAddress();
    stack_trace.index = (stack_trace.index + 1) % N;
}
```

–°—Ç–æ–∏–º–æ—Å—Ç—å —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç 2 –º–∞—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –ø–ª—é—Å –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —á—Ç–µ–Ω–∏—è –∏ –∑–∞–ø–∏—Å–∏ –≤ –ø–∞–º—è—Ç—å. –û–±—ä–µ–º –ø–∞–º—è—Ç–∏ –∫ –∫–æ—Ç–æ—Ä–æ–π
–æ—Å—É—â–µ—Å—Ç–≤–ª—è–µ—Ç—Å—è –¥–æ—Å—Ç—É–ø –æ–≥—Ä–∞–Ω–∏—á–µ–Ω –∏ –¥–æ–ª–∂–µ–Ω –æ—Å—Ç–∞–≤–∞—Ç—å—Å—è –≤ –∫—ç—à–µ –Ω–∞ –≤—Ä–µ–º—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏.

–ß—Ç–æ –∫–∞—Å–∞–µ—Ç—Å—è —Ä–∞–∑–º–µ—Ä–∞ –∫–æ–¥–∞, —Ç–æ 1 –≤—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –ø–µ—Ä–µ–¥ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `return` –Ω–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç –±–æ–ª—å—à–æ–π –ø—Ä–æ–±–ª–µ–º—ã. –ù–µ—Å–º–æ—Ç—Ä—è –Ω–∞
—ç—Ç–æ, —É –º–µ–Ω—è –µ—Å—Ç—å –ø–ª–∞–Ω —Å–¥–µ–ª–∞—Ç—å –≤—ã–∑–æ–≤ `__zig_return_error` –∫–æ–Ω–µ—á–Ω—ã–º –≤—ã–∑–æ–≤–æ–º, —á—Ç–æ —Ñ–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Å–≤–µ–¥–µ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç—å —Ä–∞–∑–º–µ—Ä–∞ –∫–æ–¥–∞
–∫ –Ω—É–ª—é. –¢–æ, —á—Ç–æ —è–≤–ª—è–µ—Ç—Å—è –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–º `return` –≤ –∫–æ–¥–µ –±–µ–∑ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏ –º–æ–∂–µ—Ç —Å—Ç–∞—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–µ–π –ø–µ—Ä–µ—Ö–æ–¥–∞ –≤
–∫–æ–¥–µ —Å –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ–º –≤–æ–∑–≤—Ä–∞—Ç–∞ –æ—à–∏–±–∫–∏.

------------
### Optionals

–û–¥–Ω–∞ –∏–∑ –æ–±–ª–∞—Å—Ç–µ–π –≤ –∫–æ—Ç–æ—Ä–æ–π **Zig** –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –±–µ–∑ —É—â–µ—Ä–±–∞ –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∏–ª–∏ —É–¥–æ–±–æ—á–∏—Ç–∞–µ–º–æ—Å—Ç–∏ - —ç—Ç–æ
–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø.

–í–æ–ø—Ä–æ—Å–∏—Ç–µ–ª—å–Ω—ã–π –∑–Ω–∞–∫ —Å–∏–º–≤–æ–ª–∏–∑–∏—Ä—É–µ—Ç –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø. –í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —Ç–∏–ø –≤ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π, –ø–æ—Å—Ç–∞–≤–∏–≤ –ø–µ—Ä–µ–¥ –Ω–∏–º
–∑–Ω–∞–∫ –≤–æ–ø—Ä–æ—Å–∞, –≤–æ—Ç —Ç–∞–∫:

```zig
// –Ω–æ—Ä–º–∞–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
const normal_int: i32 = 1234;

// –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–µ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ
const optional_int: ?i32 = 5678;
```


–¢–µ–ø–µ—Ä—å –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è `optional_int` –º–æ–∂–µ—Ç –±—ã—Ç—å `i32` –∏–ª–∏ `null`.

–í–º–µ—Å—Ç–æ —Ü–µ–ª—ã—Ö —á–∏—Å–µ–ª –¥–∞–≤–∞–π—Ç–µ –ø–æ–≥–æ–≤–æ—Ä–∏–º –æ–± —É–∫–∞–∑–∞—Ç–µ–ª—è—Ö. –°—Å—ã–ª–∫–∏ –Ω–∞ Null —è–≤–ª—è—é—Ç—Å—è –∏—Å—Ç–æ—á–Ω–∏–∫–æ–º –º–Ω–æ–≥–∏—Ö –∏—Å–∫–ª—é—á–µ–Ω–∏–π –≤–æ –≤—Ä–µ–º—è
–≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –∏ –∏—Ö –¥–∞–∂–µ –æ–±–≤–∏–Ω—è—é—Ç –≤ —Ç–æ–º, —á—Ç–æ –æ–Ω–∏ —è–≤–ª—è—é—Ç—Å—è —Ö—É–¥—à–µ–π –æ—à–∏–±–∫–æ–π –≤ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–∫–µ.

–í **Zig** –∏—Ö –Ω–µ—Ç.

–í–º–µ—Å—Ç–æ —ç—Ç–æ–≥–æ –≤—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å. –≠—Ç–æ —Ç–∞–π–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ –æ–±—ã—á–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å, –ø–æ—Å–∫–æ–ª—å–∫—É –º—ã
–∑–Ω–∞–µ–º, —á—Ç–æ –º–æ–∂–µ–º –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å 0 –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω—É–ª–µ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ —Ç–∏–ø–∞. –ù–æ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä –º–æ–∂–µ—Ç –ø—Ä–æ–≤–µ—Ä–∏—Ç—å
–≤–∞—à—É —Ä–∞–±–æ—Ç—É –∏ —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –≤—ã –Ω–µ –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç–µ null —Ç–æ–º—É, —á—Ç–æ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å null.

–û–±—ã—á–Ω–æ –Ω–µ–¥–æ—Å—Ç–∞—Ç–∫–æ–º –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è null —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ —ç—Ç–æ –¥–µ–ª–∞–µ—Ç –Ω–∞–ø–∏—Å–∞–Ω–∏–µ –∫–æ–¥–∞ –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω—ã–º. –ù–æ –¥–∞–≤–∞–π—Ç–µ —Å—Ä–∞–≤–Ω–∏–º
—ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω—ã–π –∫–æ–¥ –Ω–∞ C –∏ Zig-–∫–æ–¥.

–ó–∞–¥–∞—á–∞: –≤—ã–∑–æ–≤–∏—Ç–µ malloc, –µ—Å–ª–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ä–∞–≤–µ–Ω null, –≤–µ—Ä–Ω–∏—Ç–µ null.

```c
// –ø—Ä–æ—Ç–æ—Ç–∏–ø malloc –≤–∫–ª—é—á–µ–Ω –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏
void *malloc(size_t size);

struct Foo *do_a_thing(void) {
    char *ptr = malloc(1234);
    if (!ptr) return NULL;
    // ...
}
```
```zig
// –ø—Ä–æ—Ç–æ—Ç–∏–ø malloc –≤–∫–ª—é—á–µ–Ω –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏
extern fn malloc(size: usize) ?[*]u8;

fn doAThing() ?*Foo {
    const ptr = malloc(1234) orelse return null;
    _ = ptr; // ...
}
```

–ó–¥–µ—Å—å **Zig** –ø–æ –∫—Ä–∞–π–Ω–µ–π –º–µ—Ä–µ –Ω–µ –º–µ–Ω–µ–µ —É–¥–æ–±–µ–Ω, –µ—Å–ª–∏ –Ω–µ –±–æ–ª—å—à–µ —á–µ–º C. –ê —Ç–∏–ø "ptr" - —ç—Ç–æ `[*]u8`, –Ω–µ —Ç–∞–∫ –ª–∏ `?[*]u8`.
–ö–ª—é—á–µ–≤–æ–µ —Å–ª–æ–≤–æ `orelse` —Ä–∞—Å–∫—Ä—ã–≤–∞–µ—Ç –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —Ç–∏–ø –∏ –ø–æ—ç—Ç–æ–º—É –∑–Ω–∞—á–µ–Ω–∏–µ ptr –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –±—É–¥–µ—Ç –æ—Ç–ª–∏—á–Ω—ã–º –æ—Ç null
–≤–µ–∑–¥–µ, –≥–¥–µ –æ–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ —Ñ—É–Ω–∫—Ü–∏–∏.

–î—Ä—É–≥–∞—è —Ñ–æ—Ä–º–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–∞ –∑–Ω–∞—á–µ–Ω–∏–µ NULL, –∫–æ—Ç–æ—Ä—É—é –≤—ã –º–æ–∂–µ—Ç–µ —É–≤–∏–¥–µ—Ç—å, –≤—ã–≥–ª—è–¥–∏—Ç —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

```c
void do_a_thing(struct Foo *foo) {
    // —Å–¥–µ–ª–∞—Ç—å –∫–æ–µ-—á—Ç–æ –µ—â–µ

    if (foo) {
        do_something_with_foo(foo);
    }

    // —Å–¥–µ–ª–∞—Ç—å –∫–æ–µ-—á—Ç–æ –µ—â–µ
}
```

–í **Zig** –≤—ã –º–æ–∂–µ—Ç–µ —Å–¥–µ–ª–∞—Ç—å —Ç–æ –∂–µ —Å–∞–º–æ–µ:

```zig
const Foo = struct {};
fn doSomethingWithFoo(foo: *Foo) void {
    _ = foo;
}

fn doAThing(optional_foo: ?*Foo) void {
    // —Å–¥–µ–ª–∞—Ç—å –∫–æ–µ-—á—Ç–æ –µ—â–µ

    if (optional_foo) |foo| {
        doSomethingWithFoo(foo);
    }

    // —Å–¥–µ–ª–∞—Ç—å –∫–æ–µ-—á—Ç–æ –µ—â–µ
}
```

–ï—â–µ —Ä–∞–∑ –æ—Ç–º–µ—Ç–∏–º, —á—Ç–æ –∑–¥–µ—Å—å –ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ —Ç–æ, —á—Ç–æ –≤–Ω—É—Ç—Ä–∏ –±–ª–æ–∫–∞ if `foo` –±–æ–ª—å—à–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º —É–∫–∞–∑–∞—Ç–µ–ª–µ–º, —ç—Ç–æ
—É–∫–∞–∑–∞—Ç–µ–ª—å –∫–æ—Ç–æ—Ä—ã–π –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Ä–∞–≤–µ–Ω null.

–û–¥–Ω–∏–º –∏–∑ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤ —ç—Ç–æ–≥–æ —è–≤–ª—è–µ—Ç—Å—è —Ç–æ, —á—Ç–æ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–∏–Ω–∏–º–∞—é—Ç —É–∫–∞–∑–∞—Ç–µ–ª–∏ –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤, –º–æ–≥—É—Ç –±—ã—Ç—å
–ø–æ–º–µ—á–µ–Ω—ã –∞—Ç—Ä–∏–±—É—Ç–æ–º "nonnull" - `__attribute__((nonnull))` –≤ GCC. –û–ø—Ç–∏–º–∏–∑–∞—Ç–æ—Ä –∏–Ω–æ–≥–¥–∞ –º–æ–∂–µ—Ç –ø—Ä–∏–Ω–∏–º–∞—Ç—å –±–æ–ª–µ–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ
—Ä–µ—à–µ–Ω–∏—è, –∑–Ω–∞—è, —á—Ç–æ –∞—Ä–≥—É–º–µ–Ω—Ç—ã —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω—É–ª–µ–≤—ã–º–∏.

#### Optional Type

–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç—Å—è –ø—É—Ç–µ–º —É–∫–∞–∑–∞–Ω–∏—è ? –ø–µ—Ä–µ–¥ —Ç–∏–ø–æ–º. –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è
–¥–æ—Å—Ç—É–ø–∞ –∫ –¥–æ—á–µ—Ä–Ω–µ–º—É —Ç–∏–ø—É –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞:

```zig
const expect = @import("std").testing.expect;

test "optional type" {
    // –û–±—ä—è–≤–ª—è–π—Ç–µ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä –∏ –ø—Ä–∏–º–µ–Ω—è–π—Ç–µ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –æ—Ç null:
    var foo: ?i32 = null;

    // –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∏–∑ –¥–æ—á–µ—Ä–Ω–µ–≥–æ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ —Ç–∏–ø–∞
    foo = 1234;

    // –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä–µ—Ñ–ª–µ–∫—Å–∏—é –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ –¥–æ—á–µ—Ä–Ω–µ–º—É –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–º—É —Ç–∏–ø—É:
    try comptime expect(@typeInfo(@TypeOf(foo)).Optional.child == i32);
}
```
```bash
$ zig test test_optional_type.zig
1/1 test_optional_type.test.optional type...OK
All 1 tests passed.
```

#### null

–ö–∞–∫ –∏ undefined, `null` –∏–º–µ–µ—Ç —Å–≤–æ–π —Å–æ–±—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç–∏–ø, –∏ –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–ø–æ—Å–æ–± –µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å - –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ –¥—Ä—É–≥–æ–º—É —Ç–∏–ø—É:

```zig
const optional_value: ?i32 = null;
```

#### Optional Pointers

–ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π —É–∫–∞–∑–∞—Ç–µ–ª—å –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Ç–æ—Ç –∂–µ —Ä–∞–∑–º–µ—Ä, —á—Ç–æ –∏ —É–∫–∞–∑–∞—Ç–µ–ª—å –Ω–∞ –æ–±—ä–µ–∫—Ç. –ù—É–ª–µ–≤—ã–º –∑–Ω–∞—á–µ–Ω–∏–µ–º
–Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–≥–æ —É–∫–∞–∑–∞—Ç–µ–ª—è –≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–æ –±—É–¥–µ—Ç –∞–¥—Ä–µ—Å 0.

```zig
const expect = @import("std").testing.expect;

test "optional pointers" {
    // –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –Ω—É–ª–µ–≤—ã–º–∏. –ï—Å–ª–∏ –≤–∞–º –Ω—É–∂–µ–Ω –Ω—É–ª–µ–≤–æ–π —É–∫–∞–∑–∞—Ç–µ–ª—å, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–π
    // –ø—Ä–µ—Ñ–∏–∫—Å `?`, —á—Ç–æ–±—ã —Å–¥–µ–ª–∞—Ç—å —Ç–∏–ø —É–∫–∞–∑–∞—Ç–µ–ª—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º.
    var ptr: ?*i32 = null;

    var x: i32 = 1;
    ptr = &x;

    try expect(ptr.?.* == 1);

    // –ù–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –∏–º–µ—é—Ç —Ç–æ—Ç –∂–µ —Ä–∞–∑–º–µ—Ä, —á—Ç–æ –∏ –æ–±—ã—á–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏, –ø–æ—Å–∫–æ–ª—å–∫—É —É–∫–∞–∑–∞—Ç–µ–ª—å
    // –∑–Ω–∞—á–µ–Ω–∏–µ 0 –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –≤ –∫–∞—á–µ—Å—Ç–≤–µ –Ω—É–ª–µ–≤–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è.
    try expect(@sizeOf(?*i32) == @sizeOf(*i32));
}
```
```bash
$ zig test test_optional_pointer.zig
1/1 test_optional_pointer.test.optional pointers...OK
All 1 tests passed.
```

------------
### Casting

–ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –≤ –¥—Ä—É–≥–æ–π. –í **Zig** –µ—Å—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π –∫–æ—Ç–æ—Ä—ã–µ –∫–∞–∫
–∏–∑–≤–µ—Å—Ç–Ω–æ –∞–±—Å–æ–ª—é—Ç–Ω–æ –±–µ–∑–æ–ø–∞—Å–Ω—ã –∏ –æ–¥–Ω–æ–∑–Ω–∞—á–Ω—ã –∏ —è–≤–Ω–æ–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –¥–ª—è –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–π –∫–æ—Ç–æ—Ä—ã–µ –Ω–µ —Ö–æ—Ç–µ–ª–æ—Å—å –±—ã —á—Ç–æ–±—ã –ø—Ä–æ–∏–∑–æ—à–ª–∏
—Å–ª—É—á–∞–π–Ω–æ. –°—É—â–µ—Å—Ç–≤—É–µ—Ç —Ç–∞–∫–∂–µ —Ç—Ä–µ—Ç–∏–π –≤–∏–¥ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è —Ç–∏–ø–æ–≤ –Ω–∞–∑—ã–≤–∞–µ–º—ã–π —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ–º –æ–¥–Ω–æ—Ä–∞–Ω–≥–æ–≤—ã—Ö —Ç–∏–ø–æ–≤ –¥–ª—è —Å–ª—É—á–∞—è –∫–æ–≥–¥–∞
—Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω —Å —É—á–µ—Ç–æ–º –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö —Ç–∏–ø–æ–≤ –æ–ø–µ—Ä–∞–Ω–¥–æ–≤.

#### Type Coercion

–ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ —Ç–∏–ø–∞ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –∫–æ–≥–¥–∞ –æ–∂–∏–¥–∞–µ—Ç—Å—è –æ–¥–∏–Ω —Ç–∏–ø, –Ω–æ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç—Å—è –¥—Ä—É–≥–æ–π —Ç–∏–ø:
```zig
test "type coercion - variable declaration" {
    const a: u8 = 1;
    const b: u16 = a;
    _ = b;
}

test "type coercion - function call" {
    const a: u8 = 1;
    foo(a);
}

fn foo(b: u16) void {
    _ = b;
}

test "type coercion - @as builtin" {
    const a: u8 = 1;
    const b = @as(u16, a);
    _ = b;
}
```
```bash
$ zig test test_type_coercion.zig
1/3 test_type_coercion.test.type coercion - variable declaration...OK
2/3 test_type_coercion.test.type coercion - function call...OK
3/3 test_type_coercion.test.type coercion - @as builtin...OK
All 3 tests passed.
```

–ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ —Ç–∏–ø—É –¥–æ–ø—É—Å—Ç–∏–º–æ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –∫–æ–≥–¥–∞ —Å–æ–≤–µ—Ä—à–µ–Ω–Ω–æ –æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ –∫–∞–∫ –ø–µ—Ä–µ–π—Ç–∏ –æ—Ç –æ–¥–Ω–æ–≥–æ —Ç–∏–ø–∞ –∫ –¥—Ä—É–≥–æ–º—É –∏
–≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ—Ç—Å—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è. –ï—Å—Ç—å –æ–¥–Ω–æ –∏—Å–∫–ª—é—á–µ–Ω–∏–µ - —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ —è–∑—ã–∫–µ C.

##### Type Coercion: Stricter Qualification

–ó–Ω–∞—á–µ–Ω–∏—è –∫–æ—Ç–æ—Ä—ã–µ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω—ã –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —Å—Ç—Ä–æ–≥–æ—Å—Ç–∏
–∫–≤–∞–ª–∏—Ñ–∏–∫–∞—Ç–æ—Ä–æ–≤, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Ç–æ–≥–æ –Ω–∞—Å–∫–æ–ª—å–∫–æ –æ–Ω–∏ –≤–ª–æ–∂–µ–Ω—ã:
- `const` - —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ—Ç non-const –∫ const
- `volatile` - —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ—Ç —ç–Ω–µ—Ä–≥–æ–Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ –∫ —ç–Ω–µ—Ä–≥–æ–∑–∞–≤–∏—Å–∏–º–æ–º—É
- `align` - —Ä–∞–∑—Ä–µ—à–µ–Ω–æ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –æ—Ç –±–æ–ª—å—à–µ–≥–æ –∫ –º–µ–Ω—å—à–µ–º—É
- `error` –æ—Ç –Ω–∞–±–æ—Ä–æ–≤ –∫ –Ω–∞–¥–º–Ω–æ–∂–µ—Å—Ç–≤–∞–º

–≠—Ç–∏ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –Ω–µ –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –ø–æ—Å–∫–æ–ª—å–∫—É –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏–π –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è.

```zig
test "type coercion - const qualification" {
    var a: i32 = 1;
    const b: *i32 = &a;
    foo(b);
}

fn foo(_: *const i32) void {}
```
```bash
$ zig test test_no_op_casts.zig
1/1 test_no_op_casts.test.type coercion - const qualification...OK
All 1 tests passed.
```

–ö—Ä–æ–º–µ —Ç–æ–≥–æ, —É–∫–∞–∑–∞—Ç–µ–ª–∏ –ø—Ä–∏–Ω—É–∂–¥–∞—é—Ç –∫ —Å–æ–∑–¥–∞–Ω–∏—é –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö —É–∫–∞–∑–∞—Ç–µ–ª–µ–π const:

```zig
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;

test "cast *[1][*]const u8 to [*]const ?[*]const u8" {
    const window_name = [1][*]const u8{"window name"};
    const x: [*]const ?[*]const u8 = &window_name;
    try expect(mem.eql(u8, std.mem.sliceTo(@as([*:0]const u8, @ptrCast(x[0].?)), 0), "window name"));
}
```
```bash
$ zig test test_pointer_coerce_const_optional.zig
1/1 test_pointer_coerce_const_optional.test.cast *[1][*]const u8 to [*]const ?[*]const u8...OK
All 1 tests passed.
```

##### Type Coercion: Integer and Float Widening

–¶–µ–ª—ã–µ —á–∏—Å–ª–∞ –ø—Ä–∏–≤–æ–¥—è—Ç –∫ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–º —Ç–∏–ø–∞–º –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ —Ç–∏–ø–∞ –∏ –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
–∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π –ø—Ä–∏–≤–æ–¥—è—Ç –∫ —Ç–∏–ø–∞–º —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è—Ç—å –∫–∞–∂–¥–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ —Å—Ç–∞—Ä–æ–≥–æ
—Ç–∏–ø–∞.

```zig
const std = @import("std");
const builtin = @import("builtin");
const expect = std.testing.expect;
const mem = std.mem;

test "integer widening" {
    const a: u8 = 250;
    const b: u16 = a;
    const c: u32 = b;
    const d: u64 = c;
    const e: u64 = d;
    const f: u128 = e;
    try expect(f == a);
}

test "implicit unsigned integer to signed integer" {
    const a: u8 = 250;
    const b: i16 = a;
    try expect(b == 250);
}

test "float widening" {
    const a: f16 = 12.34;
    const b: f32 = a;
    const c: f64 = b;
    const d: f128 = c;
    try expect(d == a);
}
```
```bash
$ zig test test_integer_widening.zig
1/3 test_integer_widening.test.integer widening...OK
2/3 test_integer_widening.test.implicit unsigned integer to signed integer...OK
3/3 test_integer_widening.test.float widening...OK
All 3 tests passed.
```


##### Type Coercion: Float to Int

–û—à–∏–±–∫–∞ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä–∞ —É–º–µ—Å—Ç–Ω–∞, –ø–æ—Å–∫–æ–ª—å–∫—É —ç—Ç–æ –Ω–µ–æ–¥–Ω–æ–∑–Ω–∞—á–Ω–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –æ—Å—Ç–∞–≤–ª—è–µ—Ç –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –¥–≤–∞ –≤–∞—Ä–∏–∞–Ω—Ç–∞ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –≤
–¥–µ–π—Å—Ç–≤–∏–µ.
- –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è 54.0 –∫ `comptime_int` –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ `@as(comptime_int, 10)`, –∫–æ—Ç–æ—Ä–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ `@as(f32, 10)`
- –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º 5 –≤ `comptime_float`, –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ –ø–æ–ª—É—á–∞–µ–º `@as(comptime_float, 10.8)`, –∫–æ—Ç–æ—Ä—ã–π –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç—Å—è –≤ `@as(f32, 10.8)`

```zig
// –ü—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è float –≤–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∫ int
test "implicit cast to comptime_int" {
    const f: f32 = 54.0 / 5;
    _ = f;
}
```
```bash
$ zig test test_ambiguous_coercion.zig
doc/langref/test_ambiguous_coercion.zig:3:25: error: ambiguous coercion of division operands 'comptime_float' and 'comptime_int'; non-zero remainder '4'
    const f: f32 = 54.0 / 5;
                   ~~~~~^~~
```

##### Type Coercion: Slices, Arrays and Pointers

```zig
const std = @import("std");
const expect = std.testing.expect;

// –í—ã –º–æ–∂–µ—Ç–µ –Ω–∞–∑–Ω–∞—á–∏—Ç—å –∫–æ–Ω—Å—Ç–∞–Ω—Ç–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –º–∞—Å—Å–∏–≤—ã —Å—Ä–µ–∑—É —Å –ø–æ–º–æ—â—å—é –º–æ–¥–∏—Ñ–∏–∫–∞—Ç–æ—Ä–∞
// const –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —ç–ª–µ–º–µ–Ω—Ç–∞. –ü–æ–ª–µ–∑–Ω–æ, –≤ —á–∞—Å—Ç–Ω–æ—Å—Ç–∏, –¥–ª—è
// —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –ª–∏—Ç–µ—Ä–∞–ª–æ–≤.
test "*const [N]T to []const T" {
    const x1: []const u8 = "hello";
    const x2: []const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1, x2));

    const y: []const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y[0] == 1.2);
}

// –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –∫–æ–≥–¥–∞ —Ç–∏–ø–æ–º –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –æ—à–∏–±–∫–æ–π.
test "*const [N]T to E![]const T" {
    const x1: anyerror![]const u8 = "hello";
    const x2: anyerror![]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, try x1, try x2));

    const y: anyerror![]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect((try y)[0] == 1.2);
}

// –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –∫–æ–≥–¥–∞ —Ç–∏–ø –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º.
test "*const [N]T to ?[]const T" {
    const x1: ?[]const u8 = "hello";
    const x2: ?[]const u8 = &[5]u8{ 'h', 'e', 'l', 'l', 111 };
    try expect(std.mem.eql(u8, x1.?, x2.?));

    const y: ?[]const f32 = &[2]f32{ 1.2, 3.4 };
    try expect(y.?[0] == 1.2);
}

// –ü—Ä–∏ —Ç–∞–∫–æ–º –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–∏ –¥–ª–∏–Ω–∞ –º–∞—Å—Å–∏–≤–∞ —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –¥–ª–∏–Ω–æ–π —Å—Ä–µ–∑–∞.
test "*[N]T to []T" {
    var buf: [5]u8 = "hello".*;
    const x: []u8 = &buf;
    try expect(std.mem.eql(u8, x, "hello"));

    const buf2 = [2]f32{ 1.2, 3.4 };
    const x2: []const f32 = &buf2;
    try expect(std.mem.eql(f32, x2, &[2]f32{ 1.2, 3.4 }));
}

// –£–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –º–∞—Å—Å–∏–≤—ã —Å–æ—Å—Ç–æ—è—â–∏–µ –∏–∑ –æ–¥–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –Ω–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–æ —ç–ª–µ–º–µ–Ω—Ç–æ–≤.
test "*[N]T to [*]T" {
    var buf: [5]u8 = "hello".*;
    const x: [*]u8 = &buf;
    try expect(x[4] == 'o');
    // x[5] –±—ã–ª–æ –±—ã –Ω–µ–ø–µ—Ä–µ—Ö–≤–∞—á–µ–Ω–Ω—ã–º —Ä–∞–∑—ã–º–µ–Ω–æ–≤–∞–Ω–∏–µ–º —É–∫–∞–∑–∞—Ç–µ–ª—è –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –∑–Ω–∞—á–µ–Ω–∏–π!
}

// –ê–Ω–∞–ª–æ–≥–∏—á–Ω–æ, —ç—Ç–æ —Ä–∞–±–æ—Ç–∞–µ—Ç, –∫–æ–≥–¥–∞ —Ç–∏–ø –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–º.
test "*[N]T to ?[*]T" {
    var buf: [5]u8 = "hello".*;
    const x: ?[*]u8 = &buf;
    try expect(x.?[4] == 'o');
}

// –û–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ —É–∫–∞–∑–∞—Ç–µ–ª–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ –æ–¥–Ω–æ—ç–ª–µ–º–µ–Ω—Ç–Ω—ã–µ –º–∞—Å—Å–∏–≤—ã len-1.
test "*T to *[1]T" {
    var x: i32 = 1234;
    const y: *[1]i32 = &x;
    const z: [*]i32 = y;
    try expect(z[0] == 1234);
}
```
```bash
$ zig test test_coerce_slices_arrays_and_pointers.zig
1/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to []const T...OK
2/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to E![]const T...OK
3/7 test_coerce_slices_arrays_and_pointers.test.*const [N]T to ?[]const T...OK
4/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to []T...OK
5/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to [*]T...OK
6/7 test_coerce_slices_arrays_and_pointers.test.*[N]T to ?[*]T...OK
7/7 test_coerce_slices_arrays_and_pointers.test.*T to *[1]T...OK
All 7 tests passed.
```

##### Type Coercion: Optionals

–¢–∏–ø –ø–æ–ª–µ–∑–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ Optionals, –∞ —Ç–∞–∫–∂–µ –∑–Ω–∞—á–µ–Ω–∏–µ null –ø—Ä–∏–≤–æ–¥—è—Ç –∫ –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–º—É —Ç–∏–ø—É.

```zig
const std = @import("std");
const expect = std.testing.expect;

test "coerce to optionals" {
    const x: ?i32 = 1234;
    const y: ?i32 = null;

    try expect(x.? == 1234);
    try expect(y == null);
}
```
```bash
$ zig test test_coerce_optionals.zig
1/1 test_coerce_optionals.test.coerce to optionals...OK
All 1 tests passed.
```

Optionals —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞—é—Ç –≤–ª–æ–∂–µ–Ω–Ω—ã–º–∏ –≤ —Ç–∏–ø –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "coerce to optionals wrapped in error union" {
    const x: anyerror!?i32 = 1234;
    const y: anyerror!?i32 = null;

    try expect((try x).? == 1234);
    try expect((try y) == null);
}
```
```bash
$ zig test test_coerce_optional_wrapped_error_union.zig
1/1 test_coerce_optional_wrapped_error_union.test.coerce to optionals wrapped in error union...OK
All 1 tests passed.
```

##### Type Coercion: Error Unions

–¢–∏–ø –ø–æ–ª–µ–∑–Ω–æ–π –Ω–∞–≥—Ä—É–∑–∫–∏ —Ç–∏–ø–∞ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫, –∞ —Ç–∞–∫–∂–µ —Ç–∏–ø –Ω–∞–±–æ—Ä–∞ –æ—à–∏–±–æ–∫ –æ–ø—Ä–µ–¥–µ–ª—è—é—Ç —Ç–∏–ø –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è –æ—à–∏–±–æ–∫:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "coercion to error unions" {
    const x: anyerror!i32 = 1234;
    const y: anyerror!i32 = error.Failure;

    try expect((try x) == 1234);
    try std.testing.expectError(error.Failure, y);
}
```
```bash
$ zig test test_coerce_to_error_union.zig
1/1 test_coerce_to_error_union.test.coercion to error unions...OK
All 1 tests passed.
```

##### Type Coercion: Compile-Time Known Numbers

–ï—Å–ª–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ —á–∏—Å–ª–æ –≤–æ –≤—Ä–µ–º—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–æ –≤ —Ü–µ–ª–µ–≤–æ–º —Ç–∏–ø–µ, –æ–Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ
–ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–æ:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "coercing large integer type to smaller one when value is comptime-known to fit" {
    const x: u64 = 255;
    const y: u8 = x;
    try expect(y == 255);
}
```
```bash
$ zig test test_coerce_large_to_small.zig
1/1 test_coerce_large_to_small.test.coercing large integer type to smaller one when value is comptime-known to fit...OK
All 1 tests passed.
```

##### Type Coercion: Unions and Enums

Tagged unions –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ enums, –∞ enums –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ tagged unions –µ—Å–ª–∏ –∏–∑–≤–µ—Å—Ç–Ω–æ, —á—Ç–æ –æ–Ω–∏
—è–≤–ª—è—é—Ç—Å—è –ø–æ–ª–µ–º union –∏–º–µ—é—â–∏–º —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, –Ω–∞–ø—Ä–∏–º–µ—Ä void:

```zig
const std = @import("std");
const expect = std.testing.expect;

const E = enum {
    one,
    two,
    three,
};

const U = union(E) {
    one: i32,
    two: f32,
    three,
};

const U2 = union(enum) {
    a: void,
    b: f32,

    fn tag(self: U2) usize {
        switch (self) {
            .a => return 1,
            .b => return 2,
        }
    }
};

test "coercion between unions and enums" {
    const u = U{ .two = 12.34 };
    const e: E = u; // –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ union –∫ enum
    try expect(e == E.two);

    const three = E.three;
    const u_2: U = three; // –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ enum –∫ union
    try expect(u_2 == E.three);

    const u_3: U = .three; // –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ enum literal –∫ union
    try expect(u_3 == E.three);

    const u_4: U2 = .a; // –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ enum literal –∫ union —Å –ø—Ä–µ–¥–ø–æ–ª–æ–≥–∞–µ–º—ã–º enum tag type.
    try expect(u_4.tag() == 1);

    // –°–ª–µ–¥—É—é—â–∏–π –ø—Ä–∏–º–µ—Ä –Ω–µ–≤–µ—Ä–µ–Ω.
    // –æ—à–∏–±–∫–∞: –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∏–∑ enum '@TypeOf(.enum_literal)' –∫ union 'test_coerce_unions_enum.U2' –¥–æ–ª–∂–µ–Ω –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å –ø–æ–ª–µ 'b' 'f32'.
    //var u_5: U2 = .b;
    //try expect(u_5.tag() == 2);
}
```
```bash
$ zig test test_coerce_unions_enums.zig
1/1 test_coerce_unions_enums.test.coercion between unions and enums...OK
All 1 tests passed.
```

##### Type Coercion: undefined

–ó–Ω–∞—á–µ–Ω–∏–µ `undefined` –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–∏–≤–µ–¥–µ–Ω–æ –∫ –ª—é–±–æ–º—É —Ç–∏–ø—É.


##### Type Coercion: Tuples to Arrays

–ö–æ—Ä—Ç–µ–∂–∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω—ã –≤ –º–∞—Å—Å–∏–≤—ã, –µ—Å–ª–∏ –≤—Å–µ –ø–æ–ª—è –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π —Ç–∏–ø.

```zig
const std = @import("std");
const expect = std.testing.expect;

const Tuple = struct { u8, u8 };
test "coercion from homogenous tuple to array" {
    const tuple: Tuple = .{ 5, 6 };
    const array: [2]u8 = tuple;
    _ = array;
}
```
```bash
$ zig test test_coerce_tuples_arrays.zig
1/1 test_coerce_tuples_arrays.test.coercion from homogenous tuple to array...OK
All 1 tests passed.
```

#### Explicit Casts

–Ø–≤–Ω—ã–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —è–≤–Ω—ã–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –±–µ–∑–æ–ø–∞—Å–Ω—ã, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ - –Ω–µ—Ç.
–ù–µ–∫–æ—Ç–æ—Ä—ã–µ —è–≤–Ω—ã–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –≤—ã–ø–æ–ª–Ω—è—é—Ç —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –Ω–∞ —É—Ä–æ–≤–Ω–µ —è–∑—ã–∫–∞, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ - –Ω–µ—Ç. –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —è–≤–Ω—ã–µ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –Ω–µ
–≤—ã–ø–æ–ª–Ω—è—é—Ç—Å—è –≤–æ –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è, –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ - –Ω–µ—Ç.

- `@bitCast` - –∏–∑–º–µ–Ω–∏—Ç—å —Ç–∏–ø, –Ω–æ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –±–∏—Ç–æ–≤–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ
- `@alignCast` - —Å–¥–µ–ª–∞—Ç—å —É–∫–∞–∑–∞—Ç–µ–ª—å –±–æ–ª–µ–µ –≤—ã—Ä–æ–≤–Ω–µ–Ω–Ω—ã–º
- `@enumFromInt` - –ø–æ–ª—É—á–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–µ–≥–∞.
- `@errorFromInt` - –ø–æ–ª—É—á–µ–Ω–∏–µ –∫–æ–¥–∞ –æ—à–∏–±–∫–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –µ–≥–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
- `@errorCast` - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –≤ –º–µ–Ω—å—à–∏–π –Ω–∞–±–æ—Ä –æ—à–∏–±–æ–∫
- `@floatCast` - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –±–æ–ª—å—à–µ–≥–æ —á–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π –≤ –º–µ–Ω—å—à–µ–µ —á–∏—Å–ª–æ —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
- `@floatFromInt` - –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –≤ –∑–Ω–∞—á–µ–Ω–∏–µ —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π
- `@intCast` - –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏—è –º–µ–∂–¥—É —Ü–µ–ª—ã–º–∏ —Ç–∏–ø–∞–º–∏
- `@intFromBool` - –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ true –≤ 1, –∞ –∑–Ω–∞—á–µ–Ω–∏–µ false –≤ 0
- `@intFromEnum` - –ø–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ–≥–∞ –ø–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏—è –∏–ª–∏ –æ–±—ä–µ–¥–∏–Ω–µ–Ω–∏—è —Å —Ç–µ–≥–∞–º–∏
- `@intFromError` - –ø–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–¥–∞ –æ—à–∏–±–∫–∏
- `@intFromFloat` - –ø–æ–ª—É—á–µ–Ω–∏–µ —Ü–µ–ª–æ–π —á–∞—Å—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è —Å –ø–ª–∞–≤–∞—é—â–µ–π —Ç–æ—á–∫–æ–π
- `@intFromPtr` - –ø–æ–ª—É—á–µ–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ —É–∫–∞–∑–∞—Ç–µ–ª—è
- `@ptrFromInt` - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∞–¥—Ä–µ—Å–∞ –≤ —É–∫–∞–∑–∞—Ç–µ–ª—å
- `@ptrCast` - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–µ–∂–¥—É —Ç–∏–ø–∞–º–∏ —É–∫–∞–∑–∞—Ç–µ–ª–µ–π
- `@truncate` - –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –º–µ–∂–¥—É —Ü–µ–ª—ã–º–∏ —Ç–∏–ø–∞–º–∏, –æ—Ç—Å–µ–∫–∞—è –±–∏—Ç—ã

#### Peer Type Resolution

Peer Type Resolution occurs in these places:

- `switch` –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- `if` –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- `while` –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- `for` –≤—ã—Ä–∞–∂–µ–Ω–∏—è
- –ù–µ—Å–∫–æ–ª—å–∫–æ –æ–ø–µ—Ä–∞—Ç–æ—Ä–æ–≤ break –≤ –±–ª–æ–∫–µ
- –ù–µ–∫–æ—Ç–æ—Ä—ã–µ –±–∏–Ω–∞—Ä–Ω—ã–µ –æ–ø–µ—Ä–∞—Ü–∏–∏

–ü—Ä–∏ —Ç–∞–∫–æ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–∏ —Ç–∏–ø–æ–≤ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è —Ç–∏–ø –∫ –∫–æ—Ç–æ—Ä–æ–º—É –º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏–≤—è–∑–∞–Ω—ã –≤—Å–µ –æ–¥–Ω–æ—Ä–∞–Ω–≥–æ–≤—ã–µ —Ç–∏–ø—ã. –í–æ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ
–ø—Ä–∏–º–µ—Ä–æ–≤:

```zig
const std = @import("std");
const expect = std.testing.expect;
const mem = std.mem;

test "peer resolve int widening" {
    const a: i8 = 12;
    const b: i16 = 34;
    const c = a + b;
    try expect(c == 46);
    try expect(@TypeOf(c) == i16);
}

test "peer resolve arrays of different size to const slice" {
    try expect(mem.eql(u8, boolToStr(true), "true"));
    try expect(mem.eql(u8, boolToStr(false), "false"));
    try comptime expect(mem.eql(u8, boolToStr(true), "true"));
    try comptime expect(mem.eql(u8, boolToStr(false), "false"));
}
fn boolToStr(b: bool) []const u8 {
    return if (b) "true" else "false";
}

test "peer resolve array and const slice" {
    try testPeerResolveArrayConstSlice(true);
    try comptime testPeerResolveArrayConstSlice(true);
}
fn testPeerResolveArrayConstSlice(b: bool) !void {
    const value1 = if (b) "aoeu" else @as([]const u8, "zz");
    const value2 = if (b) @as([]const u8, "zz") else "aoeu";
    try expect(mem.eql(u8, value1, "aoeu"));
    try expect(mem.eql(u8, value2, "zz"));
}

test "peer type resolution: ?T and T" {
    try expect(peerTypeTAndOptionalT(true, false).? == 0);
    try expect(peerTypeTAndOptionalT(false, false).? == 3);
    comptime {
        try expect(peerTypeTAndOptionalT(true, false).? == 0);
        try expect(peerTypeTAndOptionalT(false, false).? == 3);
    }
}
fn peerTypeTAndOptionalT(c: bool, b: bool) ?usize {
    if (c) {
        return if (b) null else @as(usize, 0);
    }

    return @as(usize, 3);
}

test "peer type resolution: *[0]u8 and []const u8" {
    try expect(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
    try expect(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    comptime {
        try expect(peerTypeEmptyArrayAndSlice(true, "hi").len == 0);
        try expect(peerTypeEmptyArrayAndSlice(false, "hi").len == 1);
    }
}
fn peerTypeEmptyArrayAndSlice(a: bool, slice: []const u8) []const u8 {
    if (a) {
        return &[_]u8{};
    }

    return slice[0..1];
}
test "peer type resolution: *[0]u8, []const u8, and anyerror![]u8" {
    {
        var data = "hi".*;
        const slice = data[0..];
        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);
        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);
    }
    comptime {
        var data = "hi".*;
        const slice = data[0..];
        try expect((try peerTypeEmptyArrayAndSliceAndError(true, slice)).len == 0);
        try expect((try peerTypeEmptyArrayAndSliceAndError(false, slice)).len == 1);
    }
}
fn peerTypeEmptyArrayAndSliceAndError(a: bool, slice: []u8) anyerror![]u8 {
    if (a) {
        return &[_]u8{};
    }

    return slice[0..1];
}

test "peer type resolution: *const T and ?*T" {
    const a: *const usize = @ptrFromInt(0x123456780);
    const b: ?*usize = @ptrFromInt(0x123456780);
    try expect(a == b);
    try expect(b == a);
}

test "peer type resolution: error union switch" {
    // –°–ª—É—á–∞–∏ –±–µ–∑ –æ—à–∏–±–æ–∫ –∏ error —è–≤–ª—è—é—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º switch;
    // —à–∞–±–ª–æ–Ω "if (x) {...} else |err| blk: { switch (err) {...} }" –Ω–µ —Ä–∞—Å—Å–º–∞—Ç—Ä–∏–≤–∞–µ—Ç
    // —Å–ª—É—á–∞–π –±–µ–∑ –æ—à–∏–±–æ–∫ –∏ —Å–ª—É—á–∞–π —Å –æ—à–∏–±–∫–æ–π –∫–∞–∫ —Ä–∞–≤–Ω–æ–ø—Ä–∞–≤–Ω—ã–µ.
    var a: error{ A, B, C }!u32 = 0;
    _ = &a;
    const b = if (a) |x|
        x + 3
    else |err| switch (err) {
        error.A => 0,
        error.B => 1,
        error.C => null,
    };
    try expect(@TypeOf(b) == ?u32);

    // –í–∞—Ä–∏–∞–Ω—Ç—ã –±–µ–∑ –æ—à–∏–±–æ–∫ –∏ error —è–≤–ª—è—é—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏ —Ç–æ–ª—å–∫–æ –≤ —Ç–æ–º —Å–ª—É—á–∞–µ, –µ—Å–ª–∏ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏ —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–æ—Å—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ–º switch;
    // —à–∞–±–ª–æ–Ω "x catch |err| blk: { switch (err) {...} }" –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç —Ä–∞–∑–≤–µ—Ä–Ω—É—Ç—ã–π `x`
    // –∏ —Å–ª—É—á–∞–π –æ—à–∏–±–∫–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º–∏.
    const c = a catch |err| switch (err) {
        error.A => 0,
        error.B => 1,
        error.C => null,
    };
    try expect(@TypeOf(c) == ?u32);
}
```
```bash
$ zig test test_peer_type_resolution.zig
1/8 test_peer_type_resolution.test.peer resolve int widening...OK
2/8 test_peer_type_resolution.test.peer resolve arrays of different size to const slice...OK
3/8 test_peer_type_resolution.test.peer resolve array and const slice...OK
4/8 test_peer_type_resolution.test.peer type resolution: ?T and T...OK
5/8 test_peer_type_resolution.test.peer type resolution: *[0]u8 and []const u8...OK
6/8 test_peer_type_resolution.test.peer type resolution: *[0]u8, []const u8, and anyerror![]u8...OK
7/8 test_peer_type_resolution.test.peer type resolution: *const T and ?*T...OK
8/8 test_peer_type_resolution.test.peer type resolution: error union switch...OK
All 8 tests passed.
```

------------
### Zero Bit Types

–î–ª—è –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Ç–∏–ø–æ–≤ `@sizeOf` —Ä–∞–≤–Ω–æ 0:

- void
- –¶–µ–ª—ã–µ —á–∏—Å–ª–∞ `u0` –∏ `i0`.
- –ú–∞—Å—Å–∏–≤—ã –∏ –≤–µ–∫—Ç–æ—Ä—ã —Å len 0 –∏–ª–∏ —Å —Ç–∏–ø–æ–º —ç–ª–µ–º–µ–Ω—Ç–∞ –∫–æ—Ç–æ—Ä—ã–π —è–≤–ª—è–µ—Ç—Å—è –Ω—É–ª–µ–≤—ã–º —Ä–∞–∑—Ä—è–¥–Ω—ã–º —Ç–∏–ø–æ–º.
- –ü–µ—Ä–µ—á–∏—Å–ª–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å 1 —Ç–µ–≥–æ–º.
- –°—Ç—Ä—É–∫—Ç—É—Ä–∞, –≤—Å–µ –ø–æ–ª—è –∫–æ—Ç–æ—Ä–æ–π –∏–º–µ—é—Ç –Ω—É–ª–µ–≤—ã–µ —Ä–∞–∑—Ä—è–¥–Ω—ã–µ —Ç–∏–ø—ã.
- –û–±—ä–µ–¥–∏–Ω–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ —Å 1 –ø–æ–ª–µ–º –∫–æ—Ç–æ—Ä–æ–µ –∏–º–µ–µ—Ç –Ω—É–ª–µ–≤–æ–π —Ä–∞–∑—Ä—è–¥–Ω—ã–π —Ç–∏–ø.

–≠—Ç–∏ —Ç–∏–ø—ã –º–æ–≥—É—Ç –∏–º–µ—Ç—å —Ç–æ–ª—å–∫–æ –æ–¥–Ω–æ –≤–æ–∑–º–æ–∂–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏ —Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ –¥–ª—è –∏—Ö –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è —Ç—Ä–µ–±—É–µ—Ç—Å—è 0 –±–∏—Ç. –ö–æ–¥
–∏—Å–ø–æ–ª—å–∑—É—é—â–∏–π —ç—Ç–∏ —Ç–∏–ø—ã –Ω–µ –≤–∫–ª—é—á–∞–µ—Ç—Å—è –≤ –æ–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω—ã–π —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∫–æ–¥:

```zig
export fn entry() void {
    var x: void = {};
    var y: void = {};
    x = y;
    y = x;
}
```

–ö–æ–≥–¥–∞ —ç—Ç–æ –ø—Ä–µ–≤—Ä–∞—â–∞–µ—Ç—Å—è –≤ –º–∞—à–∏–Ω–Ω—ã–π –∫–æ–¥ –≤ —Ç–µ–ª–µ –≤–≤–æ–¥–∞ –Ω–µ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –∫–æ–¥, –¥–∞–∂–µ –≤ —Ä–µ–∂–∏–º–µ –æ—Ç–ª–∞–¥–∫–∏. –ù–∞–ø—Ä–∏–º–µ—Ä, –Ω–∞ x86_64:
```asm
0000000000000010 <entry>:
  10:	55                   	push   %rbp
  11:	48 89 e5             	mov    %rsp,%rbp
  14:	5d                   	pop    %rbp
  15:	c3                   	retq
```

–≠—Ç–∏ –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –ø–æ —Å–±–æ—Ä–∫–µ –Ω–µ —Å–æ–¥–µ—Ä–∂–∞—Ç –Ω–∏–∫–∞–∫–æ–≥–æ –∫–æ–¥–∞ —Å–≤—è–∑–∞–Ω–Ω–æ–≥–æ —Å–æ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ `void` - –æ–Ω–∏ –≤—ã–ø–æ–ª–Ω—è—é—Ç —Ç–æ–ª—å–∫–æ –ø—Ä–æ–ª–æ–≥ –∏
—ç–ø–∏–ª–æ–≥ –≤—ã–∑–æ–≤–∞ —Ñ—É–Ω–∫—Ü–∏–∏.

#### void

`void` –º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–µ–∑–µ–Ω –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —ç–∫–∑–µ–º–ø–ª—è—Ä–æ–≤ —É–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã—Ö —Ç–∏–ø–æ–≤. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –∑–∞–¥–∞–Ω–∞ Map(Key, Value),
–º–æ–∂–Ω–æ –ø–µ—Ä–µ–¥–∞—Ç—å `void` –¥–ª—è —Ç–∏–ø–∞ –∑–Ω–∞—á–µ–Ω–∏—è, —á—Ç–æ–±—ã –ø—Ä–µ–≤—Ä–∞—Ç–∏—Ç—å –µ–≥–æ –≤ –Ω–∞–±–æ—Ä:

```zig
const std = @import("std");
const expect = std.testing.expect;

test "turn HashMap into a set with void" {
    var map = std.AutoHashMap(i32, void).init(std.testing.allocator);
    defer map.deinit();

    try map.put(1, {});
    try map.put(2, {});

    try expect(map.contains(2));
    try expect(!map.contains(3));

    _ = map.remove(2);
    try expect(!map.contains(2));
}
```
```bash
$ zig test test_void_in_hashmap.zig
1/1 test_void_in_hashmap.test.turn HashMap into a set with void...OK
All 1 tests passed.
```

–û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ —ç—Ç–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —Ñ–∏–∫—Ç–∏–≤–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –∑–Ω–∞—á–µ–Ω–∏—è —Ö—ç—à-–º–∞–ø—ã. –ü—Ä–∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–∏
`void` –≤ –∫–∞—á–µ—Å—Ç–≤–µ —Ç–∏–ø–∞ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–∏–ø –∑–∞–ø–∏—Å–∏ —Ö—ç—à-–º–∞–ø—ã –Ω–µ –∏–º–µ–µ—Ç –ø–æ–ª—è –∑–Ω–∞—á–µ–Ω–∏—è –∏ —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º —Ö—ç—à-–º–∞–ø—ã –∑–∞–Ω–∏–º–∞–µ—Ç –º–µ–Ω—å—à–µ
–º–µ—Å—Ç–∞. –î–∞–ª–µ–µ, –≤–µ—Å—å –∫–æ–¥, –∫–æ—Ç–æ—Ä—ã–π —Å–≤—è–∑–∞–Ω —Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –∏ –∑–∞–≥—Ä—É–∑–∫–æ–π –∑–Ω–∞—á–µ–Ω–∏—è, —É–¥–∞–ª—è–µ—Ç—Å—è, –∫–∞–∫ –ø–æ–∫–∞–∑–∞–Ω–æ –≤—ã—à–µ.

`void` –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç `anyopaque`. –ò–∑–≤–µ—Å—Ç–Ω—ã–π —Ä–∞–∑–º–µ—Ä `void` —Ä–∞–≤–µ–Ω 0 –±–∞–π—Ç–∞–º, –∞ `anyopaque` –∏–º–µ–µ—Ç –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π, –Ω–æ –Ω–µ–Ω—É–ª–µ–≤–æ–π
—Ä–∞–∑–º–µ—Ä.

–í—ã—Ä–∞–∂–µ–Ω–∏—è —Ç–∏–ø–∞ `void` - –µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∫–æ—Ç–æ—Ä—ã—Ö –º–æ–∂–Ω–æ –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å. –ù–∞–ø—Ä–∏–º–µ—Ä, –∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –æ—Ç–ª–∏—á–Ω–æ–≥–æ
–æ—Ç `void` –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –æ—à–∏–±–∫–µ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏:

```zig
test "ignoring expression value" {
    foo();
}

fn foo() i32 {
    return 1234;
}
```
```bash

$ zig test test_expression_ignored.zig
doc/langref/test_expression_ignored.zig:2:8: error: value of type 'i32' ignored
    foo();
    ~~~^~
doc/langref/test_expression_ignored.zig:2:8: note: all non-void values must be used
doc/langref/test_expression_ignored.zig:2:8: note: to discard the value, assign it to '_'
```

–û–¥–Ω–∞–∫–æ, –µ—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏–º–µ–µ—Ç —Ç–∏–ø `void` –æ—à–∏–±–∫–∏ –Ω–µ –±—É–¥–µ—Ç. –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –≤—ã—Ä–∞–∂–µ–Ω–∏—è –º–æ–∂–Ω–æ —è–≤–Ω–æ –ø—Ä–æ–∏–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å, –ø—Ä–∏—Å–≤–æ–∏–≤ –∏–º
–∑–Ω–∞—á–µ–Ω–∏–µ _.

```zig
test "void is ignored" {
    returnsVoid();
}

test "explicitly ignoring expression value" {
    _ = foo();
}

fn returnsVoid() void {}

fn foo() i32 {
    return 1234;
}
```
```bash
$ zig test test_void_ignored.zig
1/2 test_void_ignored.test.void is ignored...OK
2/2 test_void_ignored.test.explicitly ignoring expression value...OK
All 2 tests passed.
```

------------
### Result Location Semantics

–í–æ –≤—Ä–µ–º—è –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –∫–∞–∂–¥–æ–º—É **Zig**-–≤—ã—Ä–∞–∂–µ–Ω–∏—é –∏ –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏—é –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–∏
—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞. –≠—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –∫–∞–∫–æ–π —Ç–∏–ø –¥–æ–ª–∂–Ω–æ –∏–º–µ—Ç—å –≤—ã—Ä–∞–∂–µ–Ω–∏–µ (–µ–≥–æ —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞) –∏ –∫—É–¥–∞ —Å–ª–µ–¥—É–µ—Ç –ø–æ–º–µ—Å—Ç–∏—Ç—å
—Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø–∞–º—è—Ç–∏ (–µ–≥–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞). –≠—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è —è–≤–ª—è–µ—Ç—Å—è –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ–π –≤ —Ç–æ–º —Å–º—ã—Å–ª–µ,
—á—Ç–æ –Ω–µ –∫–∞–∂–¥–æ–µ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —ç—Ç—É –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é: –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è `_`, –Ω–∞–ø—Ä–∏–º–µ—Ä, –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –Ω–∏–∫–∞–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
–æ —Ç–∏–ø–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏ –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é —è—á–µ–π–∫—É –ø–∞–º—è—Ç–∏ –¥–ª—è –µ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è.

–í –∫–∞—á–µ—Å—Ç–≤–µ –º–æ—Ç–∏–≤–∏—Ä—É—é—â–µ–≥–æ –ø—Ä–∏–º–µ—Ä–∞ —Ä–∞—Å—Å–º–æ—Ç—Ä–∏–º —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ `const x: u32 = 42;`. –ü—Ä–∏–≤–µ–¥–µ–Ω–Ω–∞—è –∑–¥–µ—Å—å –∞–Ω–Ω–æ—Ç–∞—Ü–∏—è –∫ —Ç–∏–ø—É
–ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–∏–π —Ç–∏–ø `u32` –¥–ª—è –≤—ã—Ä–∞–∂–µ–Ω–∏—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ 42, –¥–∞–≤–∞—è —É–∫–∞–∑–∞–Ω–∏–µ –∫–æ–º–ø–∏–ª—è—Ç–æ—Ä—É –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å —ç—Ç–æ —Ü–µ–ª–æ–µ
—á–∏—Å–ª–æ (–∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —Ç–∏–ø–∞ `comptime_int`) –≤ —ç—Ç–æ—Ç —Ç–∏–ø. –í—Å–∫–æ—Ä–µ –º—ã —É–≤–∏–¥–∏–º –±–æ–ª—å—à–µ –ø—Ä–∏–º–µ—Ä–æ–≤.

–≠—Ç–æ –Ω–µ –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ –¥–µ—Ç–∞–ª—è–º —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏: –ª–æ–≥–∏–∫–∞ –æ–ø–∏—Å–∞–Ω–Ω–∞—è –≤—ã—à–µ –∫–æ–¥–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–∞ –≤ —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏–∏ —è–∑—ã–∫–∞ **Zig** –∏ —è–≤–ª—è–µ—Ç—Å—è
–æ—Å–Ω–æ–≤–Ω—ã–º –º–µ—Ö–∞–Ω–∏–∑–º–æ–º –≤—ã–≤–æ–¥–∞ —Ç–∏–ø–æ–≤ –≤ —è–∑—ã–∫–µ. –≠—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –≤ —Å–æ–≤–æ–∫—É–ø–Ω–æ—Å—Ç–∏ –Ω–∞–∑—ã–≤–∞–µ—Ç—Å—è "–°–µ–º–∞–Ω—Ç–∏–∫–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤".

#### Result Types

–¢–∏–ø—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, –ø–æ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏, —Ä–µ–∫—É—Ä—Å–∏–≤–Ω–æ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è —á–µ—Ä–µ–∑ –≤—ã—Ä–∞–∂–µ–Ω–∏—è. –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ `&e` –∏–º–µ–µ—Ç —Ç–∏–ø
—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ `*u32`, —Ç–æ `e` –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ `u32`, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç —è–∑—ã–∫—É –≤—ã–ø–æ–ª–Ω–∏—Ç—å —ç—Ç–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –ø–µ—Ä–µ–¥
–∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —Å—Å—ã–ª–∫–∏.

–ú–µ—Ö–∞–Ω–∏–∑–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–∏–ø–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å –ø–æ–º–æ—â—å—é –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π, —Ç–∞–∫–∏—Ö –∫–∞–∫ `@intCast`. –í–º–µ—Å—Ç–æ —Ç–æ–≥–æ, —á—Ç–æ–±—ã
–ø—Ä–∏–Ω–∏–º–∞—Ç—å –≤ –∫–∞—á–µ—Å—Ç–≤–µ –∞—Ä–≥—É–º–µ–Ω—Ç–∞ —Ç–∏–ø –∫ –∫–æ—Ç–æ—Ä–æ–º—É –Ω—É–∂–Ω–æ –ø—Ä–∏–≤–µ—Å—Ç–∏, —ç—Ç–∏ –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç —Å–≤–æ–π —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–ª—è
–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —ç—Ç–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏. –¢–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ —á–∞—Å—Ç–æ –∏–∑–≤–µ—Å—Ç–µ–Ω –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞; –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ —Ç–∞–∫, —Ç–æ –¥–ª—è —è–≤–Ω–æ–≥–æ —É–∫–∞–∑–∞–Ω–∏—è —Ç–∏–ø–∞
—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≤—Å—Ç—Ä–æ–µ–Ω–Ω—É—é –æ–ø—Ü–∏—é `@as`.

–ú—ã –º–æ–∂–µ–º —Ä–∞–∑–±–∏—Ç—å —Ç–∏–ø—ã —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –ø—Ä–æ—Å—Ç–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–∏–º –æ–±—Ä–∞–∑–æ–º:

```zig
const expectEqual = @import("std").testing.expectEqual;
test "result type propagates through struct initializer" {
    const S = struct { x: u32 };
    const val: u64 = 123;
    const s: S = .{ .x = @intCast(val) };
    // .{ .x = @intCast(val) } –∏–º–µ–µ—Ç —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ "S" –∏–∑-–∑–∞ –∞–Ω–Ω–æ—Ç–∞—Ü–∏–∏ —Ç–∏–ø–∞
    //         @intCast(val) –∏–º–µ–µ—Ç —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ "u32" –∏–∑-–∑–∞ —Ç–∏–ø–∞ –ø–æ–ª—è `S.x`
    //         val –Ω–µ –∏–º–µ–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–≥–æ —Ç–∏–ø–∞, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –º–æ–∂–µ—Ç –±—ã—Ç—å –ª—é–±–æ–≥–æ —Ü–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω–æ–≥–æ —Ç–∏–ø–∞
    try expectEqual(@as(u32, 123), s.x);
}
```
```bash
$ zig test result_type_propagation.zig
1/1 result_type_propagation.test.result type propagates through struct initializer...OK
All 1 tests passed.
```

–≠—Ç–∞ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Ç–∏–ø–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –ø–æ–ª–µ–∑–Ω–∞ –¥–ª—è –≤—ã—à–µ—É–ø–æ–º—è–Ω—É—Ç—ã—Ö –≤—Å—Ç—Ä–æ–µ–Ω–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è, –∞ —Ç–∞–∫–∂–µ –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã
–∏–∑–±–µ–∂–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏–π –∑–∞–¥–∞–Ω–Ω—ã—Ö –¥–æ –ø—Ä–∏–≤–µ–¥–µ–Ω–∏—è –∏ –¥–ª—è —Ç–æ–≥–æ —á—Ç–æ–±—ã –≤ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–ª—É—á–∞—è—Ö –∏–∑–±–µ–∂–∞—Ç—å –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –≤ —è–≤–Ω–æ–º
–ø—Ä–∏–≤–µ–¥–µ–Ω–∏–∏ —Ç–∏–ø–æ–≤. –í —Å–ª–µ–¥—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü–µ –ø–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—Å–∞–Ω–æ –∫–∞–∫ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—é—Ç —Ç–∏–ø—ã
—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, –≥–¥–µ x –∏ y —è–≤–ª—è—é—Ç—Å—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º–∏ –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏.


|Expression|Parent Result Type|Sub-expression Result Type|
|----|------------|-----------|
|`const val: T = x`| - |`x` is a `T`|
|`var val: T = x`| - |`x` is a `T`|
|`val = x`| - |`x` is a `@TypeOf(val)`|
|`@as(T, x)`| - |`x` is a `T`|
|`&x`| `*T` |`x` is a `T`|
|`&x`| `[]T` |`x` is some array of `T`|
|`f(x)`| - |`x` has the type of the first parameter of `f`|
|`.{x}`| `T` |`x` is a `std.meta.FieldType(T, .@"0")`|
|`.{ .a = x }`| `T` |`x` is a `std.meta.FieldType(T, .a)`|
|`T{x}`| - |`x` is a `std.meta.FieldType(T, .@"0")`|
|`T{ .a = x }`| - |`x` is a `std.meta.FieldType(T, .a)`|
|`@Type(x)`| - |`x` is a `std.builtin.Type`|
|`@typeInfo(x)`| - |`x` is a `type`|
|`x << y`| - |`y` is a `std.math.Log1IntCeil(@TypeOf(x))`|

#### Result Locations

–í –¥–æ–ø–æ–ª–Ω–µ–Ω–∏–µ –∫ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–∏–ø–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, –∫–∞–∂–¥–æ–º—É –≤—ã—Ä–∞–∂–µ–Ω–∏—é –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ –ø—Ä–∏—Å–≤–æ–µ–Ω–æ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ
—Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞: —É–∫–∞–∑–∞—Ç–µ–ª—å, –≤ –∫–æ—Ç–æ—Ä—ã–π –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ –∑–∞–ø–∏—Å–∞–Ω–æ –∑–Ω–∞—á–µ–Ω–∏–µ. –≠—Ç–∞ —Å–∏—Å—Ç–µ–º–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞ –¥–ª—è
–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö –∫–æ–ø–∏–π –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å—Ç—Ä—É–∫—Ç—É—Ä –¥–∞–Ω–Ω—ã—Ö, —á—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–∞–∂–Ω–æ –¥–ª—è —Ç–∏–ø–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –¥–æ–ª–∂–Ω—ã
–∏–º–µ—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∞–¥—Ä–µ—Å –≤ –ø–∞–º—è—Ç–∏ ("–∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ" —Ç–∏–ø—ã).

–ü—Ä–∏ –∫–æ–º–ø–∏–ª—è—Ü–∏–∏ –ø—Ä–æ—Å—Ç–æ–≥–æ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏—è `x = e` –º–Ω–æ–≥–∏–µ —è–∑—ã–∫–∏ —Å–æ–∑–¥–∞–ª–∏ –±—ã –≤—Ä–µ–º–µ–Ω–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ e –≤ —Å—Ç–µ–∫–µ, –∞ –∑–∞—Ç–µ–º
–ø—Ä–∏—Å–≤–æ–∏–ª–∏ –±—ã –µ–≥–æ `x`, –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ –≤—ã–ø–æ–ª–Ω—è—è –ø—Ä–∏–≤–µ–¥–µ–Ω–∏–µ –∫ —Ç–∏–ø—É –≤ –ø—Ä–æ—Ü–µ—Å—Å–µ. **Zig** –ø–æ–¥—Ö–æ–¥–∏—Ç –∫ —ç—Ç–æ–º—É –ø–æ-–¥—Ä—É–≥–æ–º—É. –í—ã—Ä–∞–∂–µ–Ω–∏—é
`e` –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è —Ç–∏–ø —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞, —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–∏–ø—É `x`, –∏ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ - `&x`. –î–ª—è –º–Ω–æ–≥–∏—Ö
—Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏—Ö —Ñ–æ—Ä–º `e` —ç—Ç–æ –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è. –û–¥–Ω–∞–∫–æ —ç—Ç–æ –º–æ–∂–µ—Ç –∏–º–µ—Ç—å –≤–∞–∂–Ω—ã–µ —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–µ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –ø—Ä–∏
—Ä–∞–±–æ—Ç–µ —Å –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–º–∏ —Å–∏–Ω—Ç–∞–∫—Å–∏—á–µ—Å–∫–∏–º–∏ —Ñ–æ—Ä–º–∞–º–∏.

–ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ `.{ .a = x, .b = y }` –∏–º–µ–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ `ptr`, –∑–∞—Ç–µ–º `x` –ø—Ä–∏—Å–≤–∞–∏–≤–∞–µ—Ç—Å—è
—Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ `&ptr.a`, –∞ `y` - —Ä–µ–∑—É–ª—å—Ç–∏—Ä—É—é—â–µ–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ `&ptr.b`. –ë–µ–∑ —ç—Ç–æ–π —Å–∏—Å—Ç–µ–º—ã —ç—Ç–æ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ
—Å–æ–∑–¥–∞–ª–æ –±—ã –≤—Ä–µ–º–µ–Ω–Ω–æ–µ —Å—Ç—Ä—É–∫—Ç—É—Ä–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤ —Å—Ç–µ–∫–µ, –∏ —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –µ–≥–æ –Ω–∞ –∞–¥—Ä–µ—Å –Ω–∞–∑–Ω–∞—á–µ–Ω–∏—è. –ü–æ
—Å—É—Ç–∏, **Zig** –∑–∞–º–µ–Ω—è–µ—Ç –ø—Ä–∏—Å–≤–∞–∏–≤–∞–Ω–∏–µ `foo = .{ .a = x, .b = y }` –¥–≤—É–º –æ–ø–µ—Ä–∞—Ç–æ—Ä–∞–º `foo.a = x; foo.b = y;`.

–ò–Ω–æ–≥–¥–∞ —ç—Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –≤–∞–∂–Ω–æ –ø—Ä–∏ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–∏ –∞–≥—Ä–µ–≥–∞—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è –∫–æ–≥–¥–∞ –≤—ã—Ä–∞–∂–µ–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ
–∑–Ω–∞—á–µ–Ω–∏—è –∞–≥—Ä–µ–≥–∞—Ç–∞. –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π —Å–ø–æ—Å–æ–± –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ - –ø–æ–ø—ã—Ç–∞—Ç—å—Å—è –ø–æ–º–µ–Ω—è—Ç—å –º–µ—Å—Ç–∞–º–∏ –ø–æ–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏–ª–∏ –º–∞—Å—Å–∏–≤–∞
- —Å–ª–µ–¥—É—é—â–∞—è –ª–æ–≥–∏–∫–∞ –≤—ã–≥–ª—è–¥–∏—Ç —Ä–∞–∑—É–º–Ω–æ–π, –Ω–æ –Ω–∞ —Å–∞–º–æ–º –¥–µ–ª–µ —Ç–∞–∫–æ–≤–æ–π –Ω–µ —è–≤–ª—è–µ—Ç—Å—è:

```zig
const expect = @import("std").testing.expect;
test "attempt to swap array elements with array initializer" {
    var arr: [2]u32 = .{ 1, 2 };
    arr = .{ arr[1], arr[0] };
    // –ü—Ä–µ–¥—ã–¥—É—â–∞—è —Å—Ç—Ä–æ–∫–∞ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–Ω–∞ –¥–≤—É–º —Å–ª–µ–¥—É—é—â–∏–º —Å—Ç—Ä–æ–∫–∞–º:
    // arr[0] = arr[1];
    // arr[1] = arr[0];
    // –¢–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —ç—Ç–æ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç!
    try expect(arr[0] == 2); // succeeds
    try expect(arr[1] == 1); // fails
}
```
```bash
$ zig test result_location_interfering_with_swap.zig
1/1 result_location_interfering_with_swap.test.attempt to swap array elements with array initializer...FAIL (TestUnexpectedResult)
/home/andy/src/zig/lib/std/testing.zig:540:14: 0x103ce1f in expect (test)
    if (!ok) return error.TestUnexpectedResult;
             ^
/home/andy/src/zig/doc/langref/result_location_interfering_with_swap.zig:10:5: 0x103cf85 in test.attempt to swap array elements with array initializer (test)
    try expect(arr[1] == 1); // fails
    ^
0 passed; 0 skipped; 1 failed.
error: the following test command failed with exit code 1:
/home/andy/src/zig/.zig-cache/o/c42c6019fdf548f70655aafe3673a46e/test
```

 –í —Å–ª–µ–¥—É—é—â–µ–π —Ç–∞–±–ª–∏—Ü–µ –ø–æ–¥—Ä–æ–±–Ω–æ –æ–ø–∏—Å–∞–Ω–æ, –∫–∞–∫ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω–µ–Ω–Ω—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –ø–µ—Ä–µ–¥–∞—é—Ç –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, –≥–¥–µ
 `x` –∏ `y` —è–≤–ª—è—é—Ç—Å—è –ø—Ä–æ–∏–∑–≤–æ–ª—å–Ω—ã–º–∏ –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏—è–º–∏. –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ, —á—Ç–æ –Ω–µ–∫–æ—Ç–æ—Ä—ã–µ –≤—ã—Ä–∞–∂–µ–Ω–∏—è –Ω–µ –º–æ–≥—É—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–∏—Ç—å
 –∑–Ω–∞—á–∏–º—ã–µ –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –ø–æ–¥–≤—ã—Ä–∞–∂–µ–Ω–∏–π –¥–∞–∂–µ –µ—Å–ª–∏ —É –Ω–∏—Ö —Å–∞–º–∏—Ö –µ—Å—Ç—å –º–µ—Å—Ç–æ–ø–æ–ª–æ–∂–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞.

|Expression|Parent Result Type|Sub-expression Result Type|
|----|------------|-----------|
|`const val: T = x`| - |`x` has result location `&val`|
|`var val: T = x`| - |`x` has result location `&val`|
|`val = x` | - |`x` has result location `&val`|
|`@as(T, x)`| `ptr` |`x` has no result location|
|`&x`| `ptr` |`x` has no result location|
|`f(x)`| `ptr` |`x` has no result location|
|`.{x}`| `ptr` |`x` has result location `&ptr[0]`|
|`.{ .a = x }`| `ptr` |`x` has result location `&ptr.a`|
|`T{x}`| `ptr` |`x` has no result location (typed initializers do not propagate result locations)|
|`T{ .a = x }`| `ptr` |`x` has no result location (typed initializers do not propagate result locations)|
|`@Type(x)`| `ptr` |`x` has no result location|
|`@typeInfo(x)`| `ptr` |`x` has no result location|
|`x << y`| `ptr` |`x` and y do not have result locations|

------------
